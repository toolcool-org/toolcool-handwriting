/* 
Tool Cool Handwriting
Version: 1.0.0
Documentation: https://github.com/toolcool-org/toolcool-handwriting
License: MIT License        
Author: Tool Cool, toolcool.org@gmail.com>                          
*/
(()=>{var vF=Object.create;var Kx=Object.defineProperty;var kF=Object.getOwnPropertyDescriptor;var EF=Object.getOwnPropertyNames;var AF=Object.getPrototypeOf,$F=Object.prototype.hasOwnProperty;var qx=Math.pow;var Vr=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),Jr=(r,t)=>{for(var e in t)Kx(r,e,{get:t[e],enumerable:!0})},DF=(r,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of EF(t))!$F.call(r,n)&&n!==e&&Kx(r,n,{get:()=>t[n],enumerable:!(o=kF(t,n))||o.enumerable});return r};var zc=(r,t,e)=>(e=r!=null?vF(AF(r)):{},DF(t||!r||!r.__esModule?Kx(e,"default",{value:r,enumerable:!0}):e,r));var M=(r,t,e)=>new Promise((o,n)=>{var s=l=>{try{a(e.next(l))}catch(u){n(u)}},i=l=>{try{a(e.throw(l))}catch(u){n(u)}},a=l=>l.done?o(l.value):Promise.resolve(l.value).then(s,i);a((e=e.apply(r,t)).next())});var mC=Vr((p6,pC)=>{pC.exports=de;var Qr=null;try{Qr=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function de(r,t,e){this.low=r|0,this.high=t|0,this.unsigned=!!e}de.prototype.__isLong__;Object.defineProperty(de.prototype,"__isLong__",{value:!0});function Er(r){return(r&&r.__isLong__)===!0}de.isLong=Er;var rC={},oC={};function wa(r,t){var e,o,n;return t?(r>>>=0,(n=0<=r&&r<256)&&(o=oC[r],o)?o:(e=ge(r,(r|0)<0?-1:0,!0),n&&(oC[r]=e),e)):(r|=0,(n=-128<=r&&r<128)&&(o=rC[r],o)?o:(e=ge(r,r<0?-1:0,!1),n&&(rC[r]=e),e))}de.fromInt=wa;function to(r,t){if(isNaN(r))return t?ba:eo;if(t){if(r<0)return ba;if(r>=aC)return cC}else{if(r<=-sC)return kr;if(r+1>=sC)return uC}return r<0?to(-r,t).neg():ge(r%uu|0,r/uu|0,t)}de.fromNumber=to;function ge(r,t,e){return new de(r,t,e)}de.fromBits=ge;var Hf=Math.pow;function ay(r,t,e){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return eo;if(typeof t=="number"?(e=t,t=!1):t=!!t,e=e||10,e<2||36<e)throw RangeError("radix");var o;if((o=r.indexOf("-"))>0)throw Error("interior hyphen");if(o===0)return ay(r.substring(1),t,e).neg();for(var n=to(Hf(e,8)),s=eo,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),l=parseInt(r.substring(i,i+a),e);if(a<8){var u=to(Hf(e,a));s=s.mul(u).add(to(l))}else s=s.mul(n),s=s.add(to(l))}return s.unsigned=t,s}de.fromString=ay;function ko(r,t){return typeof r=="number"?to(r,t):typeof r=="string"?ay(r,t):ge(r.low,r.high,typeof t=="boolean"?t:r.unsigned)}de.fromValue=ko;var nC=1<<16,e_=1<<24,uu=nC*nC,aC=uu*uu,sC=aC/2,iC=wa(e_),eo=wa(0);de.ZERO=eo;var ba=wa(0,!0);de.UZERO=ba;var lu=wa(1);de.ONE=lu;var lC=wa(1,!0);de.UONE=lC;var iy=wa(-1);de.NEG_ONE=iy;var uC=ge(-1,2147483647,!1);de.MAX_VALUE=uC;var cC=ge(-1,-1,!0);de.MAX_UNSIGNED_VALUE=cC;var kr=ge(0,-2147483648,!1);de.MIN_VALUE=kr;var at=de.prototype;at.toInt=function(){return this.unsigned?this.low>>>0:this.low};at.toNumber=function(){return this.unsigned?(this.high>>>0)*uu+(this.low>>>0):this.high*uu+(this.low>>>0)};at.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(kr)){var e=to(t),o=this.div(e),n=o.mul(e).sub(this);return o.toString(t)+n.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=to(Hf(t,6),this.unsigned),i=this,a="";;){var l=i.div(s),u=i.sub(l.mul(s)).toInt()>>>0,c=u.toString(t);if(i=l,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};at.getHighBits=function(){return this.high};at.getHighBitsUnsigned=function(){return this.high>>>0};at.getLowBits=function(){return this.low};at.getLowBitsUnsigned=function(){return this.low>>>0};at.getNumBitsAbs=function(){if(this.isNegative())return this.eq(kr)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&(t&1<<e)==0;e--);return this.high!=0?e+33:e+1};at.isZero=function(){return this.high===0&&this.low===0};at.eqz=at.isZero;at.isNegative=function(){return!this.unsigned&&this.high<0};at.isPositive=function(){return this.unsigned||this.high>=0};at.isOdd=function(){return(this.low&1)===1};at.isEven=function(){return(this.low&1)===0};at.equals=function(t){return Er(t)||(t=ko(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};at.eq=at.equals;at.notEquals=function(t){return!this.eq(t)};at.neq=at.notEquals;at.ne=at.notEquals;at.lessThan=function(t){return this.comp(t)<0};at.lt=at.lessThan;at.lessThanOrEqual=function(t){return this.comp(t)<=0};at.lte=at.lessThanOrEqual;at.le=at.lessThanOrEqual;at.greaterThan=function(t){return this.comp(t)>0};at.gt=at.greaterThan;at.greaterThanOrEqual=function(t){return this.comp(t)>=0};at.gte=at.greaterThanOrEqual;at.ge=at.greaterThanOrEqual;at.compare=function(t){if(Er(t)||(t=ko(t)),this.eq(t))return 0;var e=this.isNegative(),o=t.isNegative();return e&&!o?-1:!e&&o?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};at.comp=at.compare;at.negate=function(){return!this.unsigned&&this.eq(kr)?kr:this.not().add(lu)};at.neg=at.negate;at.add=function(t){Er(t)||(t=ko(t));var e=this.high>>>16,o=this.high&65535,n=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,l=t.low>>>16,u=t.low&65535,c=0,p=0,m=0,f=0;return f+=s+u,m+=f>>>16,f&=65535,m+=n+l,p+=m>>>16,m&=65535,p+=o+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,ge(m<<16|f,c<<16|p,this.unsigned)};at.subtract=function(t){return Er(t)||(t=ko(t)),this.add(t.neg())};at.sub=at.subtract;at.multiply=function(t){if(this.isZero())return eo;if(Er(t)||(t=ko(t)),Qr){var e=Qr.mul(this.low,this.high,t.low,t.high);return ge(e,Qr.get_high(),this.unsigned)}if(t.isZero())return eo;if(this.eq(kr))return t.isOdd()?kr:eo;if(t.eq(kr))return this.isOdd()?kr:eo;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(iC)&&t.lt(iC))return to(this.toNumber()*t.toNumber(),this.unsigned);var o=this.high>>>16,n=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,l=t.high&65535,u=t.low>>>16,c=t.low&65535,p=0,m=0,f=0,h=0;return h+=i*c,f+=h>>>16,h&=65535,f+=s*c,m+=f>>>16,f&=65535,f+=i*u,m+=f>>>16,f&=65535,m+=n*c,p+=m>>>16,m&=65535,m+=s*u,p+=m>>>16,m&=65535,m+=i*l,p+=m>>>16,m&=65535,p+=o*c+n*u+s*l+i*a,p&=65535,ge(f<<16|h,p<<16|m,this.unsigned)};at.mul=at.multiply;at.divide=function(t){if(Er(t)||(t=ko(t)),t.isZero())throw Error("division by zero");if(Qr){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?Qr.div_u:Qr.div_s)(this.low,this.high,t.low,t.high);return ge(e,Qr.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ba:eo;var o,n,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return ba;if(t.gt(this.shru(1)))return lC;s=ba}else{if(this.eq(kr)){if(t.eq(lu)||t.eq(iy))return kr;if(t.eq(kr))return lu;var i=this.shr(1);return o=i.div(t).shl(1),o.eq(eo)?t.isNegative()?lu:iy:(n=this.sub(t.mul(o)),s=o.add(n.div(t)),s)}else if(t.eq(kr))return this.unsigned?ba:eo;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=eo}for(n=this;n.gte(t);){o=Math.max(1,Math.floor(n.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(o)/Math.LN2),l=a<=48?1:Hf(2,a-48),u=to(o),c=u.mul(t);c.isNegative()||c.gt(n);)o-=l,u=to(o,this.unsigned),c=u.mul(t);u.isZero()&&(u=lu),s=s.add(u),n=n.sub(c)}return s};at.div=at.divide;at.modulo=function(t){if(Er(t)||(t=ko(t)),Qr){var e=(this.unsigned?Qr.rem_u:Qr.rem_s)(this.low,this.high,t.low,t.high);return ge(e,Qr.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};at.mod=at.modulo;at.rem=at.modulo;at.not=function(){return ge(~this.low,~this.high,this.unsigned)};at.and=function(t){return Er(t)||(t=ko(t)),ge(this.low&t.low,this.high&t.high,this.unsigned)};at.or=function(t){return Er(t)||(t=ko(t)),ge(this.low|t.low,this.high|t.high,this.unsigned)};at.xor=function(t){return Er(t)||(t=ko(t)),ge(this.low^t.low,this.high^t.high,this.unsigned)};at.shiftLeft=function(t){return Er(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?ge(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):ge(0,this.low<<t-32,this.unsigned)};at.shl=at.shiftLeft;at.shiftRight=function(t){return Er(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?ge(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):ge(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};at.shr=at.shiftRight;at.shiftRightUnsigned=function(t){if(Er(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var o=this.low;return ge(o>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?ge(e,0,this.unsigned):ge(e>>>t-32,0,this.unsigned)};at.shru=at.shiftRightUnsigned;at.shr_u=at.shiftRightUnsigned;at.toSigned=function(){return this.unsigned?ge(this.low,this.high,!1):this};at.toUnsigned=function(){return this.unsigned?this:ge(this.low,this.high,!0)};at.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};at.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};at.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};de.fromBytes=function(t,e,o){return o?de.fromBytesLE(t,e):de.fromBytesBE(t,e)};de.fromBytesLE=function(t,e){return new de(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};de.fromBytesBE=function(t,e){return new de(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}});var KC=Vr(()=>{});var qC=Vr(()=>{});var yI=Vr((xI,lb)=>{(function(r,t,e){function o(a){var l=this,u=i();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(a),l.s0<0&&(l.s0+=1),l.s1-=u(a),l.s1<0&&(l.s1+=1),l.s2-=u(a),l.s2<0&&(l.s2+=1),u=null}function n(a,l){return l.c=a.c,l.s0=a.s0,l.s1=a.s1,l.s2=a.s2,l}function s(a,l){var u=new o(a),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&n(c,u),p.state=function(){return n(u,{})}),p}function i(){var a=4022871197,l=function(u){u=String(u);for(var c=0;c<u.length;c++){a+=u.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(xI,typeof lb=="object"&&lb,typeof define=="function"&&define)});var wI=Vr((bI,ub)=>{(function(r,t,e){function o(i){var a=this,l="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,a.next()}function n(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var l=new o(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&n(u,l),c.state=function(){return n(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(bI,typeof ub=="object"&&ub,typeof define=="function"&&define)});var II=Vr((CI,cb)=>{(function(r,t,e){function o(i){var a=this,l="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,u==l.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function n(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var l=new o(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&n(u,l),c.state=function(){return n(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(CI,typeof cb=="object"&&cb,typeof define=="function"&&define)});var NI=Vr((SI,pb)=>{(function(r,t,e){function o(i){var a=this;a.next=function(){var u=a.x,c=a.i,p,m,f;return p=u[c],p^=p>>>7,m=p^p<<24,p=u[c+1&7],m^=p^p>>>10,p=u[c+3&7],m^=p^p>>>3,p=u[c+4&7],m^=p^p<<7,p=u[c+7&7],p=p^p<<13,m^=p^p<<9,u[c]=m,a.i=c+1&7,m};function l(u,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],u.x=f,u.i=0,p=256;p>0;--p)u.next()}l(a,i)}function n(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var l=new o(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.x&&n(u,l),c.state=function(){return n(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(SI,typeof pb=="object"&&pb,typeof define=="function"&&define)});var vI=Vr((TI,mb)=>{(function(r,t,e){function o(i){var a=this;a.next=function(){var u=a.w,c=a.X,p=a.i,m,f;return a.w=u=u+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(u^u>>>16)|0};function l(u,c){var p,m,f,h,d,g=[],x=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,x=Math.max(x,c.length)),f=0,h=-32;h<x;++h)c&&(m^=c.charCodeAt((h+32)%c.length)),h===0&&(d=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,h>=0&&(d=d+1640531527|0,p=g[h&127]^=m+d,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,h=4*128;h>0;--h)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;u.w=d,u.X=g,u.i=f}l(a,i)}function n(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var l=new o(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.X&&n(u,l),c.state=function(){return n(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(TI,typeof mb=="object"&&mb,typeof define=="function"&&define)});var EI=Vr((kI,fb)=>{(function(r,t,e){function o(i){var a=this,l="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):l+=i;for(var u=0;u<l.length+20;u++)a.b^=l.charCodeAt(u)|0,a.next()}function n(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var l=new o(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&n(u,l),c.state=function(){return n(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(kI,typeof fb=="object"&&fb,typeof define=="function"&&define)});var AI=Vr(()=>{});var DI=Vr(($I,ph)=>{(function(r,t,e){var o=256,n=6,s=52,i="random",a=e.pow(o,n),l=e.pow(2,s),u=l*2,c=o-1,p;function m(C,w,I){var E=[];w=w==!0?{entropy:!0}:w||{};var A=g(d(w.entropy?[C,b(t)]:C==null?x():C,3),E),$=new f(E),_=function(){for(var L=$.g(n),B=a,V=0;L<l;)L=(L+V)*o,B*=o,V=$.g(1);for(;L>=u;)L/=2,B/=2,V>>>=1;return(L+V)/B};return _.int32=function(){return $.g(4)|0},_.quick=function(){return $.g(4)/4294967296},_.double=_,g(b($.S),t),(w.pass||I||function(L,B,V,G){return G&&(G.S&&h(G,$),L.state=function(){return h($,{})}),V?(e[i]=L,B):L})(_,A,"global"in w?w.global:this==e,w.state)}function f(C){var w,I=C.length,E=this,A=0,$=E.i=E.j=0,_=E.S=[];for(I||(C=[I++]);A<o;)_[A]=A++;for(A=0;A<o;A++)_[A]=_[$=c&$+C[A%I]+(w=_[A])],_[$]=w;(E.g=function(L){for(var B,V=0,G=E.i,U=E.j,W=E.S;L--;)B=W[G=c&G+1],V=V*o+W[c&(W[G]=W[U=c&U+B])+(W[U]=B)];return E.i=G,E.j=U,V})(o)}function h(C,w){return w.i=C.i,w.j=C.j,w.S=C.S.slice(),w}function d(C,w){var I=[],E=typeof C,A;if(w&&E=="object")for(A in C)try{I.push(d(C[A],w-1))}catch($){}return I.length?I:E=="string"?C:C+"\0"}function g(C,w){for(var I=C+"",E,A=0;A<I.length;)w[c&A]=c&(E^=w[c&A]*19)+I.charCodeAt(A++);return b(w)}function x(){try{var C;return p&&(C=p.randomBytes)?C=C(o):(C=new Uint8Array(o),(r.crypto||r.msCrypto).getRandomValues(C)),b(C)}catch(E){var w=r.navigator,I=w&&w.plugins;return[+new Date,r,I,r.screen,b(t)]}}function b(C){return String.fromCharCode.apply(0,C)}if(g(e.random(),t),typeof ph=="object"&&ph.exports){ph.exports=m;try{p=AI()}catch(C){}}else typeof define=="function"&&define.amd?define(function(){return m}):e["seed"+i]=m})(typeof self!="undefined"?self:$I,[],Math)});var lp=Vr((Pnt,RI)=>{var oP=yI(),nP=wI(),sP=II(),iP=NI(),aP=vI(),lP=EI(),La=DI();La.alea=oP;La.xor128=nP;La.xorwow=sP;La.xorshift7=iP;La.xor4096=aP;La.tychei=lP;RI.exports=La});var Iv=Vr(()=>{});var na=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},dn=class{refCount(t){return vr("refCount")}incRef(t){return vr("incRef")}timerAvailable(){return!0}time(t){return vr("time")}read(t){return vr("read")}readSync(t){return vr("readSync")}readToGPU(t,e){return vr("readToGPU")}numDataIds(){return vr("numDataIds")}disposeData(t,e){return vr("disposeData")}write(t,e,o){return vr("write")}move(t,e,o,n,s){return vr("move")}createTensorFromGPUData(t,e,o){return vr("createTensorFromGPUData")}memory(){return vr("memory")}floatPrecision(){return vr("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return vr("dispose")}};function vr(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function U0(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Cf(r,t,e)}function RF(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,o=0;for(;e>0;)o=Math.random()*e|0,e--,Cf(r,e,o),Cf(t,e,o)}function xl(r,t,e){return Math.max(r,Math.min(t,e))}function FF(r){return r%2===0?r:r+1}function Cf(r,t,e){let o=r[t];r[t]=r[e],r[e]=o}function _F(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function OF(r,t){let e=Math.random();return t*e+(1-e)*r}function LF(r,t){let e=0;for(let o=0;o<r.length;o++){let n=Number(r[o])-Number(t[o]);e+=n*n}return e}function k(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function If(r,t,e=""){k(zs(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function Mc(r){k(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Bt(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function PF(r){return r.length===0}function zs(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function gn(r){return r%1===0}function zF(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function MF(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function BF(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return U0(t),t}function ia(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function VF(r,t=n=>0,e,o){return new Promise((n,s)=>{let i=0,a=()=>{if(r()){n();return}i++;let l=t(i);if(e!=null&&i>=e){s();return}o!=null?o(a,l):setTimeout(a,l)};a()})}function GF(r,t){let e=1,o=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)e*=r[s];else if(r[s]===-1){if(o!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${o} and dim ${s}`);o=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(o===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let n=r.slice();return n[o]=t/e,n}function Ee(r,t){let e=t.length;return r=r==null?t.map((o,n)=>n):[].concat(r),k(r.every(o=>o>=-e&&o<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),k(r.every(o=>gn(o)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(o=>o<0?e+o:o)}function jx(r,t){let e=[],o=[],n=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||n?null:Ee(t,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(e.push(r[a]),o.push(a)),s[i]<=a&&i++}r[a]!==1&&(e.push(r[a]),o.push(a))}return{newShape:e,keptDims:o}}function WF(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${r}`);return e}function Xx(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function Yx(r,t){for(let e=0;e<r.length;e++){let o=r[e];if(isNaN(o)||!isFinite(o))throw Error(`A tensor of type ${t} being uploaded contains ${o}.`)}}function Zx(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function UF(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function yl(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function Jx(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function bl(r){return typeof r=="string"||r instanceof String}function H0(r){return typeof r=="boolean"}function K0(r){return typeof r=="number"}function wl(r){return Array.isArray(r)?wl(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":K0(r)?"float32":bl(r)?"string":H0(r)?"bool":"float32"}function Cl(r){return!!(r&&r.constructor&&r.call&&r.apply)}function Il(r,t){for(let e=t;e<r;++e)if(r%e===0)return e;return r}function Wo(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let o=t-3;o>=0;--o)e[o]=e[o+1]*r[o+1];return e}function q0(r,t,e,o=!1){let n=new Array;if(t.length===1){let s=t[0]*(o?2:1);for(let i=0;i<s;i++)n[i]=e[r+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((l,u)=>l*u)*(o?2:1);for(let l=0;l<s;l++)n[l]=q0(r+l*a,i,e,o)}return n}function sa(r,t,e=!1){if(r.length===0)return t[0];let o=r.reduce((n,s)=>n*s)*(e?2:1);if(o===0)return[];if(o!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return q0(0,r,t,e)}function HF(r,t){if(Array.isArray(r))return r;if(t==="float32")return r instanceof Float32Array?r:new Float32Array(r);if(t==="int32")return r instanceof Int32Array?r:new Int32Array(r);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${t}`)}function Bc(r,t){let e=Sl(r,t);for(let o=0;o<e.length;o++)e[o]=1;return e}function Sl(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function KF(r,t){let e=r.reduce((o,n)=>o*n,1);if(t==null||t==="float32")return sa(r,new Float32Array(e));if(t==="int32")return sa(r,new Int32Array(e));if(t==="bool")return sa(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Ve(r){r.forEach(t=>{k(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function qF(r,t,e){if(t===0)return 0;if(t===1)return r[0];let o=r[r.length-1];for(let n=0;n<r.length-1;++n)o+=e[n]*r[n];return o}function jF(r,t,e){if(t===0)return[];if(t===1)return[r];let o=new Array(t);for(let n=0;n<o.length-1;++n)o[n]=Math.floor(r/e[n]),r-=o[n]*e[n];return o[o.length-1]=r,o}function aa(r){return r&&r.then&&typeof r.then=="function"}var j0="tfjsflags",Vc=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=YF,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,o){if(this.flagRegistry[t]={evaluationFn:e,setHook:o},this.urlFlags[t]!=null){let n=this.urlFlags[t];P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${n}.`),this.set(t,n)}}getAsync(t){return M(this,null,function*(){return t in this.flags?this.flags[t]:(this.flags[t]=yield this.evaluateFlag(t),this.flags[t])})}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(aa(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=this.getQueryParams(this.global.location.search);j0 in t&&t[j0].split(",").forEach(o=>{let[n,s]=o.split(":");this.urlFlags[n]=JF(n,s)})}};function YF(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...o)=>(ZF(t,o[0],o[1]),o.join("="))),t}function ZF(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function JF(r,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${r}.`)}function P(){return Qx}var Qx=null;function X0(r){Qx=r}var ty;function ey(){if(ty==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");ty=r}return ty}function QF(){let r=ey();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Gc(r,t){let e=QF();if(e.has(r))return e.get(r);{let o=t();return e.set(r,o),e.get(r)}}var Ms="Abs",xn="Acos",yn="Acosh",vo="Add",Nl="AddN",Tl="All",vl="Any",Bs="ArgMax",Vs="ArgMin",bn="Asin",wn="Asinh",Cn="Atan",In="Atanh",Sn="Atan2",Gs="AvgPool",kl="AvgPoolGrad",Ws="AvgPool3D",El="AvgPool3DGrad",Us="BatchMatMul",Hs="BatchToSpaceND",Al="Bincount",Y0="BroadcastTo",Sf="BroadcastArgs",Uo="Cast",Nn="Ceil",Tn="ClipByValue",$l="Complex",Ks="ComplexAbs",qs="Concat",js="Conv2D",Dl="Conv2DBackpropFilter",Xs="Conv2DBackpropInput",Ys="Conv3D",Rl="Conv3DBackpropFilterV2",Fl="Conv3DBackpropInputV2",vn="Cos",kn="Cosh",_l="Cumprod",Zs="Cumsum",Ol="CropAndResize",Ll="DenseBincount",Pl="DepthToSpace",Js="DepthwiseConv2dNative",zl="DepthwiseConv2dNativeBackpropFilter",Ml="DepthwiseConv2dNativeBackpropInput",Nf="Diag",Qs="Dilation2D",Wc="Dilation2DBackpropInput",Uc="Dilation2DBackpropFilter",En="RealDiv",Tf="Einsum",An="Elu",Bl="EluGrad",$n="Erf",la="Equal",Dn="Exp",ti="ExpandDims",Rn="Expm1",Vl="FFT",Gl="Fill",Wl="FlipLeftRight",Fn="Floor",_n="FloorDiv",ei="FusedBatchNorm",ri="GatherV2",vf="GatherNd",ua="Greater",On="GreaterEqual",Ho="Identity",Ul="IFFT",Hl="Imag",Ln="IsFinite",Pn="IsInf",zn="IsNan",oi="LeakyRelu",ca="Less",pa="LessEqual",kf="LinSpace",Mn="Log",Bn="Log1p",ma="LogicalAnd",fa="LogicalNot",ha="LogicalOr";var Z0="LogSoftmax";var ni="LRN",Kl="LRNGrad",si="Max",Vn="Maximum",ii="MaxPool",ql="MaxPoolGrad",ai="MaxPool3D",jl="MaxPool3DGrad",Ef="MaxPoolWithArgmax",li="Mean",ui="Min",Gn="Minimum",ci="MirrorPad",Wn="Mod",Af="Multinomial",Un="Multiply",pi="Neg",da="NotEqual",Xl="NonMaxSuppressionV3",Yl="NonMaxSuppressionV4",Zl="NonMaxSuppressionV5",mi="OnesLike",fi="OneHot",hi="Pack",di="PadV2";var Hn="Pow",gi="Prelu",xi="Prod",$f="RaggedGather",Df="RaggedRange",Rf="RaggedTensorToTensor",Jl="Range",Ql="Real",Kn="Reciprocal",qn="Relu",yi="Reshape",bi="ResizeNearestNeighbor",tu="ResizeNearestNeighborGrad",wi="ResizeBilinear",eu="ResizeBilinearGrad",jn="Relu6",Ci="Reverse",Xn="Round",Yn="Rsqrt",Ff="ScatterNd",_f="SearchSorted",Ii="Select",Zn="Selu",Si="Slice",Jn="Sin",Qn="Sinh",ts="Sign",es="Sigmoid",rs="Softplus",os="Sqrt",Ni="Sum",Ti="SpaceToBatchND",vi="SplitV",ki="Softmax",Of="SparseFillEmptyRows",Lf="SparseReshape",Pf="SparseSegmentMean",zf="SparseSegmentSum",Mf="SparseToDense",ns="SquaredDifference",ru="Square",ou="StridedSlice",Bf="StringNGrams",Vf="StringSplit",Gf="StringToHashBucketFast",ss="Sub",is="Tan",as="Tanh",Ko="Tile",nu="TopK",su="Transform",qo="Transpose",iu="Unique",Ei="Unpack",Ai="UnsortedSegmentSum";var $i="ZerosLike",ls="Step",J0="FromPixels",au="RotateWithOffset",ga="_FusedMatMul",xa="FusedConv2D",ya="FusedDepthwiseConv2D";function jo(...r){P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(...r)}function t_(...r){P().getBool("IS_TEST")||P().getBool("PROD")||console.log(...r)}var Wf=Gc("kernelRegistry",()=>new Map),ry=Gc("gradRegistry",()=>new Map);function oy(r,t){let e=eC(r,t);return Wf.get(e)}function ny(r){return ry.get(r)}function sy(r){let t=Wf.entries(),e=[];for(;;){let{done:o,value:n}=t.next();if(o)break;let[s,i]=n,[a]=s.split("_");a===r&&e.push(i)}return e}function Uf(r){let{kernelName:t,backendName:e}=r,o=eC(t,e);Wf.has(o)&&jo(`The kernel '${t}' for backend '${e}' is already registered`),Wf.set(o,r)}function tC(r){let{kernelName:t}=r;ry.has(t)&&P().getBool("DEBUG")&&jo(`Overriding the gradient for '${t}'`),ry.set(t,r)}function eC(r,t){return`${t}_${r}`}var y={};Jr(y,{arraysEqual:()=>zs,assert:()=>k,assertNonNegativeIntegerDimensions:()=>Ve,assertNonNull:()=>Mc,assertShapesMatch:()=>If,bytesFromStringArray:()=>Jx,bytesPerElement:()=>yl,checkConversionForErrors:()=>Yx,clamp:()=>xl,computeStrides:()=>Wo,convertBackendValuesAndArrayBuffer:()=>HF,createScalarValue:()=>a_,createShuffledIndices:()=>BF,decodeString:()=>mu,distSquared:()=>LF,encodeString:()=>pu,fetch:()=>u_,fingerPrint64:()=>i_,flatten:()=>Ri,getArrayFromDType:()=>Xx,getTypedArrayFromDType:()=>WF,hasEncodingLoss:()=>UF,hexToLong:()=>Hc,indexToLoc:()=>jF,inferDtype:()=>wl,inferFromImplicitShape:()=>GF,isBoolean:()=>H0,isFunction:()=>Cl,isInt:()=>gn,isNumber:()=>K0,isPromise:()=>aa,isScalarShape:()=>PF,isString:()=>bl,isTypedArray:()=>br,isValidDtype:()=>Zx,locToIndex:()=>qF,makeOnesTypedArray:()=>Bc,makeZerosNestedTypedArray:()=>KF,makeZerosTypedArray:()=>Sl,nearestDivisor:()=>Il,nearestLargerEven:()=>FF,now:()=>Sa,parseAxisParam:()=>Ee,randUniform:()=>OF,repeatedTry:()=>VF,rightPad:()=>ia,shuffle:()=>U0,shuffleCombo:()=>RF,sizeFromShape:()=>Bt,sizeToSquarishShape:()=>MF,squeezeShape:()=>jx,sum:()=>_F,swap:()=>Cf,tanh:()=>zF,toNestedArray:()=>sa,toTypedArray:()=>cu});var uy=zc(mC());var Ia=uy.default||uy;function Hc(r){return Ia.fromString(r,!0,16)}var hC=Hc("c3a5c85c97cb3127"),Ca=Hc("b492b66fbe98f273"),cr=Hc("9ae16a3b2f90404f");function ly(r){return r.xor(r.shru(47))}function dC(r,t,e){let o=r.slice(t,t+e);return Ia.fromBytes(Array.from(o),!0,!0)}function ce(r,t){return dC(r,t,8)}function fC(r,t){return dC(r,t,4)}function Ge(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function Di(r,t,e=Hc("9ddfea08eb382d69")){let o=r.xor(t).mul(e);o=o.xor(o.shru(47));let n=t.xor(o).mul(e);return n=n.xor(n.shru(47)),n=n.mul(e),n}function r_(r,t,e,o,n,s){n=n.add(r),s=Ge(s.add(n).add(o),21);let i=n;return n=n.add(t),n=n.add(e),s=s.add(Ge(n,44)),[n.add(o),s.add(i)]}function Kf(r,t,e,o){return r_(ce(r,t),ce(r,t+8),ce(r,t+16),ce(r,t+24),e,o)}function o_(r,t=r.length){if(t>=8){let e=cr.add(t*2),o=ce(r,0).add(cr),n=ce(r,t-8),s=Ge(n,37).mul(e).add(o),i=Ge(o,25).add(n).mul(e);return Di(s,i,e)}if(t>=4){let e=cr.add(t*2),o=fC(r,0);return Di(o.shl(3).add(t),fC(r,t-4),e)}if(t>0){let e=r[0],o=r[t>>1],n=r[t-1],s=e+(o<<8),i=t+(n<<2);return ly(cr.mul(s).xor(hC.mul(i))).mul(cr)}return cr}function n_(r,t=r.length){let e=cr.add(t*2),o=ce(r,0).mul(Ca),n=ce(r,8),s=ce(r,t-8).mul(e),i=ce(r,t-16).mul(cr);return Di(Ge(o.add(n),43).add(Ge(s,30)).add(i),o.add(Ge(n.add(cr),18)).add(s),e)}function s_(r,t=r.length){let e=cr.add(t*2),o=ce(r,0).mul(cr),n=ce(r,8),s=ce(r,t-8).mul(e),i=ce(r,t-16).mul(cr),a=Ge(o.add(n),43).add(Ge(s,30)).add(i),l=Di(a,o.add(Ge(n.add(cr),18)).add(s),e),u=ce(r,16).mul(e),c=ce(r,24),p=a.add(ce(r,t-32)).mul(e),m=l.add(ce(r,t-24)).mul(e);return Di(Ge(u.add(c),43).add(Ge(p,30)).add(m),u.add(Ge(c.add(o),18)).add(p),e)}function i_(r,t=r.length){let e=Ia.fromNumber(81,!0);if(t<=32)return t<=16?o_(r,t):n_(r,t);if(t<=64)return s_(r,t);let o=e,n=e.mul(Ca).add(113),s=ly(n.mul(cr).add(113)).mul(cr),i=[Ia.UZERO,Ia.UZERO],a=[Ia.UZERO,Ia.UZERO];o=o.mul(cr).add(ce(r,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do o=Ge(o.add(n).add(i[0]).add(ce(r,l+8)),37).mul(Ca),n=Ge(n.add(i[1]).add(ce(r,l+48)),42).mul(Ca),o=o.xor(a[1]),n=n.add(i[0]).add(ce(r,l+40)),s=Ge(s.add(a[0]),33).mul(Ca),i=Kf(r,l,i[1].mul(Ca),o.add(a[0])),a=Kf(r,l+32,s.add(a[1]),n.add(ce(r,l+16))),[s,o]=[o,s],l+=64;while(l!==u);let p=Ca.add(s.and(255).shl(1));return l=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),o=Ge(o.add(n).add(i[0]).add(ce(r,l+8)),37).mul(p),n=Ge(n.add(i[1]).add(ce(r,l+48)),42).mul(p),o=o.xor(a[1].mul(9)),n=n.add(i[0].mul(9).add(ce(r,l+40))),s=Ge(s.add(a[0]),33).mul(p),i=Kf(r,l,i[1].mul(p),o.add(a[0])),a=Kf(r,l+32,s.add(a[1]),n.add(ce(r,l+16))),[s,o]=[o,s],Di(Di(i[0],a[0],p).add(ly(n).mul(hC)).add(s),Di(i[1],a[1],p).add(o),p)}function a_(r,t){return t==="string"?pu(r):cu([r],t)}function l_(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function cu(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Ri(r)),P().getBool("DEBUG")&&Yx(r,t),l_(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let o=0;o<e.length;++o)Math.round(r[o])!==0&&(e[o]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Sa(){return P().platform.now()}function u_(r,t){return P().platform.fetch(r,t)}function pu(r,t="utf-8"){return t=t||"utf-8",P().platform.encode(r,t)}function mu(r,t="utf-8"){return t=t||"utf-8",P().platform.decode(r,t)}function br(r){return P().platform.isTypedArray(r)}function Ri(r,t=[],e=!1){if(t==null&&(t=[]),typeof r=="boolean"||typeof r=="number"||typeof r=="string"||aa(r)||r==null||br(r)&&e)t.push(r);else if(Array.isArray(r)||br(r))for(let o=0;o<r.length;++o)Ri(r[o],t,e);else{let o=-1;for(let n of Object.keys(r))/^([1-9]+[0-9]*|0)$/.test(n)&&(o=Math.max(o,Number(n)));for(let n=0;n<=o;n++)Ri(r[n],t,e)}return t}var qf=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new cy)}profileKernel(t,e,o){let n,s=()=>{n=o()},i,a=Sa();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let u of n)u.dataSync();i=Promise.resolve({kernelMs:Sa()-a})}if(P().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<n.length;u++){let c=n[u];c.data().then(p=>{c_(p,c.dtype,t)})}return{kernelName:t,outputs:n,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:o,timeMs:n,inputs:s,extraInfo:i}=t;o.forEach(a=>{Promise.all([a.data(),n,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],s,l[2])})})}};function c_(r,t,e){if(t!=="float32")return!1;for(let o=0;o<r.length;o++){let n=r[o];if(isNaN(n)||!isFinite(n))return console.warn(`Found ${n} in the result of '${e}'`),!0}return!1}var cy=class{logKernelProfile(t,e,o,n,s,i){let a=typeof n=="number"?ia(`${n}ms`,9):n.error,l=ia(t,25),u=e.rank,c=e.size,p=ia(e.shape.toString(),14),m="";for(let f in s){let h=s[f];if(h!=null){let d=h.shape||e.shape,g=d.length;m+=`${f}: ${g}D ${g>0?d:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${p}	%c${c}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function gC(r,t,e){let o={},n={};for(let l=0;l<t.length;l++)o[t[l].id]=!0;for(let l=0;l<r.length;l++){let u=r[l],c=u.inputs;for(let p in c){let m=c[p],f=!1;for(let h=0;h<t.length;h++)if(o[m.id]){u.outputs.forEach(d=>o[d.id]=!0),f=!0,n[u.id]=!0;break}if(f)break}}let s={};s[e.id]=!0;let i={};for(let l=r.length-1;l>=0;l--){let u=r[l],c=u.inputs;for(let p=0;p<u.outputs.length;p++)if(s[u.outputs[p].id]){for(let m in c)s[c[m].id]=!0,i[u.id]=!0;break}}let a=[];for(let l=0;l<r.length;l++){let u=r[l];if(n[u.id]&&i[u.id]){let c={};for(let m in u.inputs){let f=u.inputs[m];o[f.id]&&(c[m]=f)}let p=Object.assign({},u);p.inputs=c,p.outputs=u.outputs,a.push(p)}}return a}function xC(r,t,e,o){for(let n=t.length-1;n>=0;n--){let s=t[n],i=[];if(s.outputs.forEach(l=>{let u=r[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);let u=e(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[l];if(!zs(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=u;else{let p=r[c.id];r[c.id]=o(p,u),p.dispose()}}}}var yC=20,Kc=3,py=7;function bC(r,t,e,o){let n=Wo(t),s=p_(r,t,e,n),i=t.length,a=jf(r,t,e,n,s),l=["Tensor"];return o&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function p_(r,t,e,o){let n=Bt(t),s=o[o.length-1],i=new Array(s).fill(0),a=t.length,l=e==="complex64"?jc(r):r;if(a>1)for(let u=0;u<n/s;u++){let c=u*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],qc(l[c+p],0,e).length)}return i}function qc(r,t,e){let o;return Array.isArray(r)?o=`${parseFloat(r[0].toFixed(py))} + ${parseFloat(r[1].toFixed(py))}j`:bl(r)?o=`'${r}'`:e==="bool"?o=wC(r):o=parseFloat(r.toFixed(py)).toString(),ia(o,t)}function wC(r){return r===0?"false":"true"}function jf(r,t,e,o,n,s=!0){let i=e==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(e==="complex64"){let d=jc(r);return[qc(d[0],0,e)]}return e==="bool"?[wC(r[0])]:[r[0].toString()]}if(l===1){if(a>yC){let g=Kc*i,x=Array.from(r.slice(0,g)),b=Array.from(r.slice((a-Kc)*i,a*i));return e==="complex64"&&(x=jc(x),b=jc(b)),["["+x.map((C,w)=>qc(C,n[w],e)).join(", ")+", ..., "+b.map((C,w)=>qc(C,n[a-Kc+w],e)).join(", ")+"]"]}return["["+(e==="complex64"?jc(r):Array.from(r)).map((g,x)=>qc(g,n[x],e)).join(", ")+"]"]}let u=t.slice(1),c=o.slice(1),p=o[0]*i,m=[];if(a>yC){for(let d=0;d<Kc;d++){let g=d*p,x=g+p;m.push(...jf(r.slice(g,x),u,e,c,n,!1))}m.push("...");for(let d=a-Kc;d<a;d++){let g=d*p,x=g+p;m.push(...jf(r.slice(g,x),u,e,c,n,d===a-1))}}else for(let d=0;d<a;d++){let g=d*p,x=g+p;m.push(...jf(r.slice(g,x),u,e,c,n,d===a-1))}let f=l===2?",":"";m[0]="["+(a>0?m[0]+f:"");for(let d=1;d<m.length-1;d++)m[d]=" "+m[d]+f;let h=`,
`;for(let d=2;d<l;d++)h+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":h),m}function jc(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var Ut=class{constructor(t,e,o){if(this.dtype=e,this.shape=t.slice(),this.size=Bt(t),o!=null){let n=o.length;k(n===this.size,()=>`Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=o||Xx(e,this.size),this.strides=Wo(t)}set(t,...e){e.length===0&&(e=[0]),k(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let o=this.locToIndex(e);this.values[o]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let n of t){if(n<0||n>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let o=t[t.length-1];for(let n=0;n<t.length-1;++n)o+=this.strides[n]*t[n];return this.values[o]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let o=0;o<t.length-1;++o)e+=this.strides[o]*t[o];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let o=0;o<e.length-1;++o)e[o]=Math.floor(t/this.strides[o]),t-=e[o]*this.strides[o];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Eo().makeTensor(this.values,this.shape,this.dtype)}},Eo=null,fu=null,m_=null;function CC(r){Eo=r}function IC(r){fu=r}function SC(r){m_=r}var _t=class{constructor(t,e,o,n){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Bt(t),this.strides=Wo(t),this.dataId=o,this.id=n,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){return M(this,null,function*(){let t=yield this.data();return fu.buffer(this.shape,this.dtype,t)})}bufferSync(){return fu.buffer(this.shape,this.dtype,this.dataSync())}array(){return M(this,null,function*(){let t=yield this.data();return sa(this.shape,t,this.dtype==="complex64")})}arraySync(){return sa(this.shape,this.dataSync(),this.dtype==="complex64")}data(){return M(this,null,function*(){this.throwIfDisposed();let t=Eo().read(this.dataId);if(this.dtype==="string"){let e=yield t;try{return e.map(o=>mu(o))}catch(o){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})}dataToGPU(t){return this.throwIfDisposed(),Eo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=Eo().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>mu(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){return M(this,null,function*(){this.throwIfDisposed();let t=yield Eo().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)})}dispose(){this.isDisposed||(Eo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return fu.print(this,t)}clone(){return this.throwIfDisposed(),fu.clone(this)}toString(t=!1){let e=this.dataSync();return bC(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),fu.cast(this,t)}variable(t=!0,e,o){return this.throwIfDisposed(),Eo().makeVariable(this,t,e,o)}};Object.defineProperty(_t,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function D(){return Gc("Tensor",()=>_t)}D();var us=class extends _t{constructor(t,e,o,n){super(t.shape,t.dtype,t.dataId,n),this.trainable=e,this.name=o}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!zs(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Eo().disposeTensor(this),this.dataId=t.dataId,Eo().incRef(this,null)}dispose(){Eo().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(us,Symbol.hasInstance,{value:r=>r instanceof _t&&r.assign!=null&&r.assign instanceof Function});var ro={};Jr(ro,{assertTypesMatch:()=>h_,getTensorsInContainer:()=>Xc,isTensorInList:()=>d_,makeTypesMatch:()=>$t});var my;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(my||(my={}));var fy;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(fy||(fy={}));var hy;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(hy||(hy={}));var dy;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(dy||(dy={}));var gy;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(gy||(gy={}));var f_={float32:dy,int32:fy,bool:hy,complex64:gy};function Te(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return f_[r][t]}function Na(r){return Te(r,"int32")}function $t(r,t){if(r.dtype===t.dtype)return[r,t];let e=Te(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function h_(r,t){k(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function d_(r,t){return t.some(e=>e.id===r.id)}function Xc(r){let t=[];return NC(r,t,new Set),t}function NC(r,t,e){if(r==null)return;if(r instanceof _t){t.push(r);return}if(!g_(r))return;let o=r;for(let n in o){let s=o[n];e.has(s)||(e.add(s),NC(s,t,e))}}function g_(r){return Array.isArray(r)||typeof r=="object"}function xy(r){return r.kernelName!=null}var Xf=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Fi=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Xf}ready(){return M(this,null,function*(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let o=t[e];if(yield this.initializeBackend(o).success){yield this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")})}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,o=1){return t in this.registryFactory?(jo(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:o},!0)}setBackend(t){return M(this,null,function*(){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:o}=this.initializeBackend(t);if(!(o?yield e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new qf(this.backendInstance),!0})}setupRegisteredKernels(){sy(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){sy(t).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let o=e.factory();if(o&&!(o instanceof dn)&&typeof o.then=="function"){let n=++this.pendingBackendInitId,s=o.then(i=>n<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(n<this.pendingBackendInitId||(this.pendingBackendInit=null,jo(`Initialization of backend ${t} failed`),jo(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=o,{success:!0,asyncInit:!1}}catch(o){return jo(`Initialization of backend ${t} failed`),jo(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let o=t[e],{success:n,asyncInit:s}=this.initializeBackend(o);if(s||n)return{name:o,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let o=this.state.tensorInfo.get(e),n=o.backend,s=this.readSync(e),i=n.refCount(e);n.disposeData(e,!0),o.backend=t,t.move(e,s,o.shape,o.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let o=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}let n;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,o){t();try{let n=o();return e(),n}catch(n){throw e(),n}}nextTensorId(){return Fi.nextTensorId++}nextVariableId(){return Fi.nextVariableId++}clone(t){let e=T.runKernel(Ho,{x:t}),o={x:t},n=i=>({x:()=>{let a="float32",l={x:i},u={dtype:a};return T.runKernel(Uo,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,o,[e],n,s,{}),e}runKernel(t,e,o){if(this.backendName==null&&this.backend,!(oy(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,o){let n=this.backend.numDataIds(),s=0;o.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=n-e-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,o=[],n=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l,u=xy(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(xy(t)){let{kernelName:h,inputs:d,attrs:g}=t;this.backendName==null&&this.backend;let x=oy(h,this.backendName);k(x!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),a=()=>{let b=this.backend.numDataIds();l=x.kernelFunc({inputs:d,attrs:g,backend:this.backend});let C=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,b,C);let w=C.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(n){let I=this.getTensorsForGradient(h,d,w);o=this.saveTensorsForBackwardMode(I)}return w}}else{let{forwardFunc:h}=t,d=g=>{!n||(o=g.map(x=>this.keep(this.clone(x))))};a=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>h(this.backend,d));let x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,x),x}}let{inputs:c,attrs:p}=t,m=xy(t)?null:t.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(f=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs)}),n&&this.addTapeNode(u,c,e,m,o,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(h=>c[h]!=null?c[h].shape:null),outputShapes:e.map(h=>h.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(t,e,o){let n=ny(t);if(n!=null){let s=n.inputsToSave||[],i=n.outputsToSave||[],a;n.saveAllInputs?(k(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(u=>e[u])):a=s.map(u=>e[u]);let l=o.filter((u,c)=>i[c]);return a.concat(l)}return[]}makeTensor(t,e,o,n){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",n=n||this.backend;let s=t;o==="string"&&bl(t[0])&&(s=t.map(l=>pu(l)));let i=n.write(s,e,o),a=new _t(e,o,i,this.nextTensorId());if(this.trackTensor(a,n),o==="string"){let l=this.state.tensorInfo.get(i),u=Jx(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(t,e,o,n){o=o||"float32";let s={dataId:t,shape:e,dtype:o};return this.makeTensorFromTensorInfo(s,n)}makeTensorFromTensorInfo(t,e){let{dataId:o,shape:n,dtype:s}=t,i=new _t(n,s,o,this.nextTensorId());return this.trackTensor(i,e),i}makeVariable(t,e=!0,o,n){o=o||this.nextVariableId().toString(),n!=null&&n!==t.dtype&&(t=t.cast(n));let s=new us(t,e,o,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let o=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(o=t.size*yl(t.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:o})),t instanceof us||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let o=t.size*yl(t.dtype);this.state.numBytes-=o}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}profile(t){return M(this,null,function*(){this.state.profiling=!0;let e=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=yield t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(n=>n.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let n of this.state.activeProfile.kernels)n.kernelTimeMs=yield n.kernelTimeMs,n.extraInfo=yield n.extraInfo;return this.state.activeProfile})}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,o,n,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:o,saved:s},l=ny(t);l!=null&&(n=l.gradFunc),n!=null&&(a.gradient=u=>(u=u.map((c,p)=>{if(c==null){let m=o[p],f=Sl(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),n(u.length>1?u:u[0],s,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=Xc(t),o=new Set(e.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!o.has(i.id)&&i.dispose()}let n=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(s=>{!s.kept&&s.scopeId===n.id&&this.track(s)})}gradients(t,e,o,n=!1){if(k(e.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));k(s instanceof _t,()=>"The result y returned by f() must be a tensor.");let i=gC(this.state.activeTape,e,s);if(!n&&i.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=o==null?x_(s.shape):o,xC(a,i,u=>this.tidy(u),y_);let l=e.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return k(Cl(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{k(e.every(a=>a instanceof _t),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,n={};e.forEach((a,l)=>{n[l]=a});let s=(a,l)=>(o=t(...e,l),k(o.value instanceof _t,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),k(Cl(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),i=(a,l)=>{let u=o.gradFunc(a,l),c=Array.isArray(u)?u:[u];k(c.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),k(c.every(m=>m instanceof _t),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,f)=>{p[f]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:n})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}time(t){return M(this,null,function*(){let e=Sa(),o=yield this.backend.time(t);return o.wallMs=Sa()-e,o})}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Xf;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Fi.nextTensorId=0;Fi.nextVariableId=0;function x_(r){let t=Bc(Bt(r),"float32");return T.makeTensor(t,r,"float32")}function yy(){let r=ey();if(r._tfengine==null){let t=new Vc(r);r._tfengine=new Fi(t)}return X0(r._tfengine.ENV),CC(()=>r._tfengine),r._tfengine}var T=yy();function y_(r,t){let e={a:r,b:t};return T.runKernel(vo,e)}var _i={};Jr(_i,{isBrowser:()=>wy,isMobile:()=>C_,mockIsMobile:()=>w_});function b_(){return typeof navigator!="undefined"&&navigator!=null}var by;function w_(r){by=r}function C_(r){if(by!==void 0)return by;if(r||b_()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let e=r;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function wy(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Gr=P();Gr.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Gr.registerFlag("IS_BROWSER",()=>wy());Gr.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Gr.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Gr.registerFlag("PROD",()=>!1);Gr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Gr.getBool("DEBUG"));Gr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Gr.registerFlag("IS_TEST",()=>!1);Gr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Gr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Gr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Gr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Ta(r,t){let e=r;if(br(r))return t==="string"?[]:[r.length];if(typeof r=="object"){if("texture"in r){let s=r.channels||"RGBA";return[r.height,r.width*s.length]}else if("buffer"in r&&!(r.buffer instanceof ArrayBuffer))return[r.buffer.size/(t==null?4:yl(t))]}if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||br(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&P().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&vC(r,n,[]),n}function vC(r,t,e){if(e=e||[],!Array.isArray(r)&&!br(r)){k(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}k(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),k(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let o=t.slice(1);for(let n=0;n<r.length;++n)vC(r[n],o,e.concat(n))}function TC(r,t,e,o){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${o}' must be ${r} tensor, but got ${t} tensor`)}}function N(r,t,e,o="numeric"){if(r instanceof _t)return TC(o,r.dtype,t,e),r;let n=wl(r);if(n!=="string"&&["bool","int32","float32"].indexOf(o)>=0&&(n=o),TC(o,n,t,e),r==null||!br(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let l=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}let s=Ta(r,n);!br(r)&&!Array.isArray(r)&&(r=[r]);let a=n!=="string"?cu(r,n):Ri(r,[],!0);return T.makeTensor(a,s,n)}function Yf(r,t,e,o="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>N(s,`${t}[${i}]`,e,o))}var I_="__op";function v(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],o=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+I_;let n=(...s)=>{T.startScope(e);try{let i=o(...s);return aa(i)&&console.error("Cannot return a Promise inside of tidy."),T.endScope(i),i}catch(i){throw T.endScope(null),i}};return Object.defineProperty(n,"name",{value:e,configurable:!0}),n}function S_(r,t){let e=N(r,"real","complex"),o=N(t,"imag","complex");If(e.shape,o.shape,`real and imag shapes, ${e.shape} and ${o.shape}, must match in call to tf.complex().`);let n={real:e,imag:o};return T.runKernel($l,n)}var Wr=v({complex_:S_});function Oi(r,t,e,o){if(o==null)o=wl(r);else if(o==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof r=="object"&&("texture"in r||"buffer"in r&&!(r.buffer instanceof ArrayBuffer))){if(o!=="float32"&&o!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${o}.`);return T.backend.createTensorFromGPUData(r,t||e,o)}if(!br(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Ve(t);let n=Bt(t),s=Bt(e);k(n===s,()=>`Based on the provided shape, [${t}], the tensor should have ${n} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],l=i===e.length-1?a!==Bt(t.slice(i)):!0;k(e[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!br(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=o!=="string"?cu(r,o):Ri(r,[],!0),T.makeTensor(r,t,o)}function Ar(r,t,e){let o=Ta(r,e);return Oi(r,t,o,e)}var Yc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Zf=4;function EC(r,t){return M(this,null,function*(){let e=[],o=[],n=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<n.length;++i){let a=n[i],l=Array.isArray(r)?r[i].tensor:r[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);let u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(p=>M(this,null,function*(){let m=yield l.bytes(),f=m.reduce((g,x)=>g+x.length,0)+Zf*m.length,h=new Uint8Array(f),d=0;for(let g=0;g<m.length;g++){let x=m[g],b=new Uint8Array(new Uint32Array([x.length]).buffer);h.set(b,d),d+=Zf,h.set(x,d),d+=x.length}p(h)}));o.push(c)}else o.push(l.data());t!=null&&(u.group=t),e.push(u)}let s=yield Promise.all(o);return{data:N_(s),specs:e}})}function Jf(r,t){let e={},o,n=0;for(let s of t){let i=s.name,a=s.dtype,l=s.shape,u=Bt(l),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=Yc[p.dtype],f=r.slice(n,n+u*m),h=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(a==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(h.length);for(let d=0;d<h.length;d++){let g=h[d];c[d]=g*p.scale+p.min}}else if(p.dtype==="float16")o===void 0&&(o=E_()),c=o(h);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(a==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let d=0;d<h.length;d++){let g=h[d];c[d]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);n+=u*m}else if(a==="string"){let p=Bt(s.shape);c=[];for(let m=0;m<p;m++){let f=new Uint32Array(r.slice(n,n+Zf))[0];n+=Zf;let h=new Uint8Array(r.slice(n,n+f));c.push(h),n+=f}}else{let p=Yc[a],m=r.slice(n,n+u*p);if(a==="float32")c=new Float32Array(m);else if(a==="int32")c=new Int32Array(m);else if(a==="bool")c=new Uint8Array(m);else if(a==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),h=new Float32Array(c.length/2);for(let x=0;x<f.length;x++)f[x]=c[x*2],h[x]=c[x*2+1];let d=Ar(f,l,"float32"),g=Ar(h,l,"float32");e[i]=Wr(d,g),d.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);n+=u*p}a!=="complex64"&&(e[i]=Ar(c,l,a))}return e}function N_(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let o=new Uint8Array(t),n=0;return e.forEach(s=>{o.set(new Uint8Array(s.buffer),n),n+=s.byteLength}),o.buffer}var Cy=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function kC(r){return Cy?Buffer.byteLength(r):new Blob([r]).size}function AC(r){if(Cy)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let o=0,n=t.length;o<n;o++)e+=String.fromCharCode(t[o]);return btoa(e)}function $C(r){if(Cy){let o=Buffer.from(r,"base64");return o.buffer.slice(o.byteOffset,o.byteOffset+o.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let o=0;o<t.length;++o)e.set([t.charCodeAt(o)],o);return e.buffer}function hu(r){if(r.length===1)return r[0];let t=0;r.forEach(n=>{t+=n.byteLength});let e=new Uint8Array(t),o=0;return r.forEach(n=>{e.set(new Uint8Array(n),o),o+=n.byteLength}),e.buffer}function Iy(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function Qf(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(e.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),e}function Sy(r,t,e){let o={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(o.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");o.weightSpecs=t,o.weightData=e}return r.signature!=null&&(o.signature=r.signature),r.userDefinedMetadata!=null&&(o.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(o.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(o.initializerSignature=r.initializerSignature),o}function du(r,t){return M(this,null,function*(){let e,o;return r.weightsManifest!=null&&([e,o]=yield t(r.weightsManifest)),Sy(r,e,o)})}function Xo(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:kC(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:kC(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function th(r){let t=[];for(let e of r)t.push(...e.weights);return t}function T_(){let r=e=>{let o=e<<13,n=0;for(;(o&8388608)===0;)n-=8388608,o<<=1;return o&=-8388609,n+=947912704,o|n},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function v_(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function k_(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function E_(){let r=T_(),t=v_(),e=k_();return o=>{let n=new ArrayBuffer(4*o.length),s=new Uint32Array(n);for(let i=0;i<o.length;i++){let a=o[i],l=r[e[a>>10]+(a&1023)]+t[a>>10];s[i]=l}return new Float32Array(n)}}var Yt=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Yt.instance==null&&(Yt.instance=new Yt),Yt.instance}static registerSaveRouter(t){Yt.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Yt.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Yt.getHandlers(t,"save")}static getLoadHandlers(t,e){return Yt.getHandlers(t,"load",e)}static getHandlers(t,e,o){let n=[];return(e==="load"?Yt.getInstance().loadRouters:Yt.getInstance().saveRouters).forEach(i=>{let a=i(t,o);a!==null&&n.push(a)}),n}},DC=r=>Yt.registerSaveRouter(r),RC=r=>Yt.registerLoadRouter(r),FC=r=>Yt.getSaveHandlers(r),_C=(r,t)=>Yt.getLoadHandlers(r,t);var Ny="tensorflowjs",Ty=1,va="models_store",Li="model_info_store";function OC(){if(!P().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function vy(r){let t=r.result;t.createObjectStore(va,{keyPath:"modelPath"}),t.createObjectStore(Li,{keyPath:"modelPath"})}var Yo=class{constructor(t){if(this.indexedDB=OC(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}save(t){return M(this,null,function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)})}load(){return M(this,null,function*(){return this.databaseAction(this.modelPath)})}databaseAction(t,e){return new Promise((o,n)=>{let s=this.indexedDB.open(Ny,Ty);s.onupgradeneeded=()=>vy(s),s.onsuccess=()=>{let i=s.result;if(e==null){let a=i.transaction(va,"readonly"),u=a.objectStore(va).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(u.result.modelArtifacts)},u.onerror=c=>(i.close(),n(u.error)),a.oncomplete=()=>i.close()}else{let a=Xo(e),l=i.transaction(Li,"readwrite"),u=l.objectStore(Li),c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a}),p;c.onsuccess=()=>{p=i.transaction(va,"readwrite");let f=p.objectStore(va).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a});f.onsuccess=()=>o({modelArtifactsInfo:a}),f.onerror=h=>{u=l.objectStore(Li);let d=u.delete(this.modelPath);d.onsuccess=()=>(i.close(),n(f.error)),d.onerror=g=>(i.close(),n(f.error))}},c.onerror=m=>(i.close(),n(c.error)),l.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},s.onerror=i=>n(s.error)})}};Yo.URL_SCHEME="indexeddb://";var LC=r=>P().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Yo.URL_SCHEME)?A_(r.slice(Yo.URL_SCHEME.length)):null;Yt.registerSaveRouter(LC);Yt.registerLoadRouter(LC);function A_(r){return new Yo(r)}function $_(r){return r.startsWith(Yo.URL_SCHEME)?r.slice(Yo.URL_SCHEME.length):r}var eh=class{constructor(){this.indexedDB=OC()}listModels(){return M(this,null,function*(){return new Promise((t,e)=>{let o=this.indexedDB.open(Ny,Ty);o.onupgradeneeded=()=>vy(o),o.onsuccess=()=>{let n=o.result,s=n.transaction(Li,"readonly"),a=s.objectStore(Li).getAll();a.onsuccess=()=>{let l={};for(let u of a.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},a.onerror=l=>(n.close(),e(a.error)),s.oncomplete=()=>n.close()},o.onerror=n=>e(o.error)})})}removeModel(t){return M(this,null,function*(){return t=$_(t),new Promise((e,o)=>{let n=this.indexedDB.open(Ny,Ty);n.onupgradeneeded=()=>vy(n),n.onsuccess=()=>{let s=n.result,i=s.transaction(Li,"readwrite"),a=i.objectStore(Li),l=a.get(t),u;l.onsuccess=()=>{if(l.result==null)return s.close(),o(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{u=s.transaction(va,"readwrite");let f=u.objectStore(va).delete(t);f.onsuccess=()=>e(l.result.modelArtifactsInfo),f.onerror=h=>o(l.error)};c.onsuccess=p,c.onerror=m=>(p(),s.close(),o(l.error))}},l.onerror=c=>(s.close(),o(l.error)),i.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},n.onerror=s=>o(n.error)})})}};var cs="/",gu="tensorflowjs_models",PC="info",D_="model_topology",R_="weight_specs",F_="weight_data",__="model_metadata";function zC(r){return{info:[gu,r,PC].join(cs),topology:[gu,r,D_].join(cs),weightSpecs:[gu,r,R_].join(cs),weightData:[gu,r,F_].join(cs),modelMetadata:[gu,r,__].join(cs)}}function MC(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function O_(r){let t=r.split(cs);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(cs)}function L_(r){return r.startsWith(Zo.URL_SCHEME)?r.slice(Zo.URL_SCHEME.length):r}var Zo=class{constructor(t){if(!P().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=zC(this.modelPath)}save(t){return M(this,null,function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),o=JSON.stringify(t.weightSpecs),n=Xo(t);try{this.LS.setItem(this.keys.info,JSON.stringify(n)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,AC(t.weightData));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:n}}catch(s){throw MC(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${n.modelTopologyBytes}, weightSpecsBytes=${n.weightSpecsBytes}, weightDataBytes=${n.weightDataBytes}.`)}}})}load(){return M(this,null,function*(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=o;let n=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(n==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=n;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(e.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=$C(i),e})}};Zo.URL_SCHEME="localstorage://";var BC=r=>P().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Zo.URL_SCHEME)?P_(r.slice(Zo.URL_SCHEME.length)):null;Yt.registerSaveRouter(BC);Yt.registerLoadRouter(BC);function P_(r){return new Zo(r)}var rh=class{constructor(){k(P().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),k(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){return M(this,null,function*(){let t={},e=gu+cs,o=cs+PC;for(let n=0;n<this.LS.length;++n){let s=this.LS.key(n);if(s.startsWith(e)&&s.endsWith(o)){let i=O_(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t})}removeModel(t){return M(this,null,function*(){t=L_(t);let e=zC(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let o=JSON.parse(this.LS.getItem(e.info));return MC(e),o})}};var xu="://",We=class{constructor(){this.managers={}}static getInstance(){return We.instance==null&&(We.instance=new We),We.instance}static registerManager(t,e){k(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(xu)&&(t=t.slice(0,t.indexOf(xu))),k(t.length>0,()=>"scheme must not be an empty string.");let o=We.getInstance();k(o.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),o.managers[t]=e}static getManager(t){let e=We.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(We.getInstance().managers)}};function oh(r){if(r.indexOf(xu)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${We.getSchemes().join(",")}`);return{scheme:r.split(xu)[0],path:r.split(xu)[1]}}function VC(r,t,e=!1){return M(this,null,function*(){k(r!==t,()=>`Old path and new path are the same: '${r}'`);let o=Yt.getLoadHandlers(r);k(o.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),k(o.length<2,()=>`Copying failed because more than one (${o.length}) load handlers for source URL ${r}.`);let n=o[0],s=Yt.getSaveHandlers(t);k(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),k(s.length<2,()=>`Copying failed because more than one (${o.length}) save handlers for destination URL ${t}.`);let i=s[0],a=oh(r).scheme,l=oh(r).path,u=a===oh(r).scheme,c=yield n.load();e&&u&&(yield We.getManager(a).removeModel(l));let p=yield i.save(c);return e&&!u&&(yield We.getManager(a).removeModel(l)),p.modelArtifactsInfo})}function GC(){return M(this,null,function*(){let r=We.getSchemes(),t={};for(let e of r){let o=yield We.getManager(e).listModels();for(let n in o){let s=e+xu+n;t[s]=o[n]}}return t})}function WC(r){return M(this,null,function*(){let t=oh(r);return We.getManager(t.scheme).removeModel(t.path)})}function UC(r,t){return M(this,null,function*(){return VC(r,t,!1)})}function HC(r,t){return M(this,null,function*(){return VC(r,t,!0)})}var ky=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window=="undefined"||!P().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",o=>{if(o.source===window&&o.data.name===this.messageName){o.stopPropagation();let n=this.functionRefs[o.data.index];n(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}};if(P().get("IS_BROWSER")){P().setPlatform("browser",new ky);try{We.registerManager(Zo.URL_SCHEME,new rh)}catch(r){}try{We.registerManager(Yo.URL_SCHEME,new eh)}catch(r){}}var z_={importFetch:()=>KC()},Ey;var Ay=class{constructor(){this.util=qC(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return P().global.fetch!=null?P().global.fetch(t,e):(Ey==null&&(Ey=z_.importFetch()),Ey(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}};P().get("IS_NODE")&&!P().get("IS_BROWSER")&&P().setPlatform("node",new Ay);function ft(r,t="float32",e){return t=t||"float32",Ve(r),new Ut(r,t,e)}function M_(r,t){let e=N(r,"x","cast");if(!Zx(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let o={x:e},n={dtype:t};return T.runKernel(Uo,o,n)}var Y=v({cast_:M_});function B_(r){let e={x:N(r,"x","clone","string_or_numeric")};return T.runKernel(Ho,e)}var $r=v({clone_:B_});function jC(r,t=!1){console.log(r.toString(t))}yy();var V_={buffer:ft,cast:Y,clone:$r,print:jC};IC(V_);function G_(r){P().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}SC(G_);function oo(){return T}function Zc(){return T.memory()}function z(r,t){return T.tidy(r,t)}function wt(r){Xc(r).forEach(e=>e.dispose())}function Oe(r){return T.keep(r)}function nh(r,t,e=1){return T.registerBackend(r,t,e)}function XC(){return T.backend}function W_(r,t){let e=N(r,"a","add"),o=N(t,"b","add");[e,o]=$t(e,o);let n={a:e,b:o};return T.runKernel(vo,n)}var X=v({add_:W_});function U_(r,t){let e=N(r,"a","floorDiv"),o=N(t,"b","floorDiv");[e,o]=$t(e,o);let n={a:e,b:o};return T.runKernel(_n,n)}var sh=v({floorDiv_:U_});function H_(r,t){let e=N(r,"a","div"),o=N(t,"b","div");if([e,o]=$t(e,o),e.dtype==="int32"&&o.dtype==="int32")return sh(e,o);let n={a:e,b:o},s={};return T.runKernel(En,n,s)}var ot=v({div_:H_});function K_(r,t){let e=N(r,"a","mul"),o=N(t,"b","mul");[e,o]=$t(e,o);let n={a:e,b:o};return T.runKernel(Un,n)}var R=v({mul_:K_});function q_(r){let t=N(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return T.runKernel(Ks,e)}else{let e={x:t};return T.runKernel(Ms,e)}}var ve=v({abs_:q_});function j_(r){let e={x:N(r,"x","acos")};return T.runKernel(xn,e)}var $y=v({acos_:j_});function X_(r){let e={x:N(r,"x","acosh")};return T.runKernel(yn,e)}var Dy=v({acosh_:X_});function Y_(r,t=null,e=!1){let n={x:N(r,"x","all","bool")},s={axis:t,keepDims:e};return T.runKernel(Tl,n,s)}var Jc=v({all_:Y_});function Z_(r,t=null,e=!1){let n={x:N(r,"x","any","bool")},s={axis:t,keepDims:e};return T.runKernel(vl,n,s)}var yu=v({any_:Z_});function J_(r,t=0){let o={x:N(r,"x","argMax")},n={axis:t};return T.runKernel(Bs,o,n)}var ps=v({argMax_:J_});function Q_(r,t=0){let o={x:N(r,"x","argMin")},n={axis:t};return T.runKernel(Vs,o,n)}var YC=v({argMin_:Q_});function tO(r){let e={x:N(r,"x","asin")};return T.runKernel(bn,e)}var Ry=v({asin_:tO});function eO(r){let e={x:N(r,"x","asinh")};return T.runKernel(wn,e)}var Fy=v({asinh_:eO});function rO(r){let e={x:N(r,"x","atan")};return T.runKernel(Cn,e)}var _y=v({atan_:rO});function oO(r,t){let e=N(r,"a","atan2"),o=N(t,"b","atan2");[e,o]=$t(e,o);let n={a:e,b:o};return T.runKernel(Sn,n)}var ZC=v({atan2_:oO});function nO(r){let e={x:N(r,"x","atanh")};return T.runKernel(In,e)}var Oy=v({atanh_:nO});function sO(r,t,e,o,n="NHWC",s){let i=r[3],a=[...t,i],l=QC(n);return ka(r,a,e,s,o,null,null,l)}function Py(r,t,e,o,n,s,i="channelsLast"){let[a,l]=Qc(t),u;if(i==="channelsLast")u=[a,l,r[3],r[3]];else if(i==="channelsFirst")u=[a,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return ka(r,u,e,o,n,s,!1,i)}function iO(r,t,e,o,n,s,i="NDHWC"){let[a,l,u]=Ly(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,l,u,r[4],r[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,l,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return JC(r,c,e,o,n,!1,p,s)}function ka(r,t,e,o,n,s,i=!1,a="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,p]=r;else if(a==="channelsFirst")[l,p,u,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[m,f,,h]=t,[d,g]=Qc(e),[x,b]=Qc(o),C=bu(m,x),w=bu(f,b),{padInfo:I,outHeight:E,outWidth:A}=uO(n,u,c,d,g,C,w,s,a),$=i?h*p:h,_;return a==="channelsFirst"?_=[l,$,E,A]:a==="channelsLast"&&(_=[l,E,A,$]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:p,outHeight:E,outWidth:A,outChannels:$,padInfo:I,strideHeight:d,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:C,effectiveFilterWidth:w,dilationHeight:x,dilationWidth:b,inShape:r,outShape:_,filterShape:t}}function JC(r,t,e,o,n,s=!1,i="channelsLast",a){let[l,u,c,p,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,p,m]=r;else if(i==="channelsFirst")[l,m,u,c,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[f,h,d,,g]=t,[x,b,C]=Ly(e),[w,I,E]=Ly(o),A=bu(f,w),$=bu(h,I),_=bu(d,E),{padInfo:L,outDepth:B,outHeight:V,outWidth:G}=cO(n,u,c,p,x,b,C,A,$,_,a),U=s?g*m:g,W;return i==="channelsFirst"?W=[l,U,B,V,G]:i==="channelsLast"&&(W=[l,B,V,G,U]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:p,inChannels:m,outDepth:B,outHeight:V,outWidth:G,outChannels:U,padInfo:L,strideDepth:x,strideHeight:b,strideWidth:C,filterDepth:f,filterHeight:h,filterWidth:d,effectiveFilterDepth:A,effectiveFilterHeight:$,effectiveFilterWidth:_,dilationDepth:w,dilationHeight:I,dilationWidth:E,inShape:r,outShape:W,filterShape:t}}function aO(r,t,e,o,n){o==null&&(o=zy(r,t,e));let s=r[0],i=r[1],a=tp((s-t+2*o)/e+1,n),l=tp((i-t+2*o)/e+1,n);return[a,l]}function lO(r,t,e,o,n,s){n==null&&(n=zy(r,t[0],o[0]));let i=[0,0,0,e];for(let a=0;a<3;a++)r[a]+2*n>=t[a]&&(i[a]=tp((r[a]-t[a]+2*n)/o[a]+1,s));return i}function zy(r,t,e,o=1){let n=bu(t,o);return Math.floor((r[0]*(e-1)-e+n)/2)}function Qc(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function Ly(r){return typeof r=="number"?[r,r,r]:r}function bu(r,t){return t<=1?r:r+(r-1)*(t-1)}function uO(r,t,e,o,n,s,i,a,l){let u,c,p;if(typeof r=="number"){u={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=aO([t,e],s,o,r,a);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(t/o),p=Math.ceil(e/n);let m=Math.max(0,(c-1)*o+s-t),f=Math.max(0,(p-1)*n+i-e),h=Math.floor(m/2),d=m-h,g=Math.floor(f/2),x=f-g;u={top:h,bottom:d,left:g,right:x,type:"SAME"}}else if(r==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/o),p=Math.ceil((e-i+1)/n);else if(typeof r=="object"){let m=l==="channelsLast"?r[1][0]:r[2][0],f=l==="channelsLast"?r[1][1]:r[2][1],h=l==="channelsLast"?r[2][0]:r[3][0],d=l==="channelsLast"?r[2][1]:r[3][1];u={top:m,bottom:f,left:h,right:d,type:m===0&&f===0&&h===0&&d===0?"VALID":"EXPLICIT"},c=tp((t-s+m+f)/o+1,a),p=tp((e-i+h+d)/n+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:u,outHeight:c,outWidth:p}}function cO(r,t,e,o,n,s,i,a,l,u,c){let p,m,f,h;if(r==="valid"&&(r=0),typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=lO([t,e,o,1],[a,l,u],1,[n,s,i],r,c);m=g[0],f=g[1],h=g[2]}else if(r==="same"){m=Math.ceil(t/n),f=Math.ceil(e/s),h=Math.ceil(o/i);let d=(m-1)*n+a-t,g=(f-1)*s+l-e,x=(h-1)*i+u-o,b=Math.floor(d/2),C=d-b,w=Math.floor(g/2),I=g-w,E=Math.floor(x/2),A=x-E;p={top:w,bottom:I,left:E,right:A,front:b,back:C,type:"SAME"}}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:m,outHeight:f,outWidth:h}}function tp(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ur(r){let[t,e,o]=Qc(r);return t===1&&e===1&&o===1}function Ue(r,t){return Ur(r)||Ur(t)}function Jo(r){return Qc(r).every(t=>t>0)}function QC(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Zt(r,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")k(gn(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(o=>{o.forEach(n=>{k(gn(n),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function pO(r,t){let o={x:N(r,"x","reshape","string_or_numeric")},n={shape:t};return T.runKernel(yi,o,n)}var F=v({reshape_:pO});function mO(r,t,e,o,n){let s=N(r,"x","avgPool","float32"),i=1;k(Ue(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Zt("avgPool",o,n);let u={x:a},c={filterSize:t,strides:e,pad:o,dimRoundingMode:n},p=T.runKernel(Gs,u,c);return p=Y(p,s.dtype),l?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ea=v({avgPool_:mO});function fO(r,t,e,o,n,s="NDHWC"){let i=N(r,"x","avgPool3d","float32"),a=i,l=!1;i.rank===4&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),k(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),Zt("avgPool3d",o,n);let u={x:a},c={filterSize:t,strides:e,pad:o,dimRoundingMode:n,dataFormat:s},p=T.runKernel(Ws,u,c);return p=Y(p,a.dtype),l?F(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var My=v({avgPool3d_:fO});function hO(r,t=0){k(r.length>=1,()=>"Pass at least one tensor to concat");let e=Yf(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return $r(e[0]);let o=e,n={axis:t};return T.runKernel(qs,o,n)}var te=v({concat_:hO});function dO(r,t,e=!1,o=!1){let n=N(r,"a","matMul"),s=N(t,"b","matMul");[n,s]=$t(n,s);let i={a:n,b:s},a={transposeA:e,transposeB:o};return T.runKernel(Us,i,a)}var Pt=v({matMul_:dO});function gO(r){let e={x:N(r,"x","sigmoid","float32")};return T.runKernel(es,e)}var no=v({sigmoid_:gO});function xO(r,t,e){let o=N(r,"x","slice","string_or_numeric");if(o.rank===0)throw new Error("Slicing scalar is not possible");let n={x:o},s={begin:t,size:e};return T.runKernel(Si,n,s)}var Rt=v({slice_:xO});function yO(r){let e={x:N(r,"x","tanh","float32")};return T.runKernel(as,e)}var wu=v({tanh_:yO});function bO(r,t,e){let o=N(r,"x","batchToSpaceND"),n=t.reduce((a,l)=>a*l);k(o.rank>=1+t.length,()=>`input rank is ${o.rank} but should be > than blockShape.length ${t.length}`),k(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),k(o.shape[0]%n===0,()=>`input tensor batch is ${o.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${n}`);let s={x:o},i={blockShape:t,crops:e};return T.runKernel(Hs,s,i)}var Cu=v({batchToSpaceND_:bO});function tI(r){let t;return r.rank===0||r.rank===1?t=F(r,[1,1,1,r.size]):r.rank===2?t=F(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function wO(r,t,e,o,n,s){s==null&&(s=.001);let i=N(r,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm"),u;n!=null&&(u=N(n,"scale","batchNorm"));let c;o!=null&&(c=N(o,"offset","batchNorm")),k(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:tI(i),scale:u,offset:c,mean:a,variance:l},f={varianceEpsilon:s},h=T.runKernel(ei,m,f);return F(h,i.shape)}var Pi=v({batchNorm_:wO});function CO(r,t,e,o,n,s){let i=N(r,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm"),u;n!=null&&(u=N(n,"scale","batchNorm"));let c;return o!=null&&(c=N(o,"offset","batchNorm")),k(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),k(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),k(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&k(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Pi(i,a,l,c,u,s)}var By=v({batchNorm2d_:CO});function IO(r,t,e,o,n,s){let i=N(r,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm"),u;n!=null&&(u=N(n,"scale","batchNorm"));let c;return o!=null&&(c=N(o,"offset","batchNorm")),k(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),k(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),k(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&k(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Pi(i,a,l,c,u,s)}var Vy=v({batchNorm3d_:IO});function SO(r,t,e,o,n,s){let i=N(r,"x","batchNorm"),a=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm"),u;n!=null&&(u=N(n,"scale","batchNorm"));let c;return o!=null&&(c=N(o,"offset","batchNorm")),k(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),k(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),k(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&k(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Pi(i,a,l,c,u,s)}var Gy=v({batchNorm4d_:SO});function NO(r,t,e){let o=N(r,"x","bincount"),n=N(t,"weights","bincount");k(o.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${o.dtype}`),k(e>=0,()=>`size must be non-negative, but got ${e}.`),k(n.size===o.size||n.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${o.shape}, weights shape: ${n.shape}.`);let s={x:o,weights:n},i={size:e};return T.runKernel(Al,s,i)}var eI=v({bincount_:NO});function TO(r,t){let e=N(r,"broadcastTo","x"),o=e.shape;if(Ve(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=F(e,u)}let n=e.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(n[u]===t[u])s[u]=1;else if(e.shape[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${t}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return $r(e);let a={x:e},l={reps:s};return T.runKernel(Ko,a,l)}var ms=v({broadcastTo_:TO});function vO(r){let e={x:N(r,"x","ceil","float32")};return T.runKernel(Nn,e)}var Wy=v({ceil_:vO});function fs(r,t,e){Ve(r);let o={shape:r,value:t,dtype:e};return T.runKernel(Gl,{},o)}function kO(r,t,e){let o=N(r,"x","clipByValue");if(k(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return fs(o.shape,t,o.dtype);let n={x:o},s={clipValueMin:t,clipValueMax:e};return T.runKernel(Tn,n,s)}var He=v({clipByValue_:kO});function EO(r){return te(r,0)}var Uy=v({concat1d_:EO});function AO(r,t){return te(r,t)}var Hy=v({concat2d_:AO});function $O(r,t){return te(r,t)}var Ky=v({concat3d_:$O});function DO(r,t){return te(r,t)}var qy=v({concat4d_:DO});function RO(r,t,e,o,n="NHWC",s=[1,1],i){let a=N(r,"x","conv2d","float32"),l=N(t,"filter","conv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),k(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Zt("conv2d",o,i);let p=n==="NHWC"?u.shape[3]:u.shape[1];k(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),k(Ue(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),k(Jo(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),k(Jo(e),()=>"Error in conv2D: Strides should be larger than 0.");let m={x:u,filter:l},f={strides:e,pad:o,dataFormat:n,dilations:s,dimRoundingMode:i},h=T.runKernel(js,m,f);return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Dr=v({conv2d_:RO});function FO(r,t,e,o,n="NWC",s=1,i){let a=N(r,"x","conv1d"),l=N(t,"filter","conv1d"),u=a,c=!1;a.rank===2&&(c=!0,u=F(a,[1,a.shape[0],a.shape[1]])),k(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),k(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Zt("conv1d",o,i),k(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),k(Ue(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),k(Jo(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),k(Jo(e),()=>"Error in conv1D: Stride should be larger than 0."),k(n==="NWC",()=>`Error in conv1d: got dataFormat of ${n} but only NWC is currently supported.`);let p=F(l,[1,l.shape[0],l.shape[1],l.shape[2]]),m=F(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Dr(m,p,[1,e],o,"NHWC",[1,s],i);return c?F(g,[g.shape[2],g.shape[3]]):F(g,[g.shape[0],g.shape[2],g.shape[3]])}var ep=v({conv1d_:FO});function _O(r,t,e,o,n,s="NHWC",i){k(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,l=t,u=!1;t.rank===3&&(u=!0,l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,r[0],r[1],r[2]]),k(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),k(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),k(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?l.shape[3]:l.shape[1];k(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),k(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),Zt("conv2dDerInput",n,i);let m={dy:l,filter:e},f={strides:o,pad:n,dataFormat:s,dimRoundingMode:i,inputShape:a},h=T.runKernel(Xs,m,f);return u?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Iu=v({conv2DBackpropInput_:_O});function OO(r,t,e,o,n,s){let i=N(r,"x","conv2dTranspose"),a=N(t,"filter","conv2dTranspose");return Iu(e,i,a,o,n,"NHWC",s)}var rp=v({conv2dTranspose_:OO});function LO(r,t,e,o,n="NDHWC",s=[1,1,1]){let i=N(r,"x","conv3d"),a=N(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),k(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),k(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),k(Ue(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),k(n==="NDHWC",()=>`Error in conv3d: got dataFormat of ${n} but only NDHWC is currently supported.`),k(Jo(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),k(Jo(e),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:a},p={strides:e,pad:o,dataFormat:n,dilations:s},m=T.runKernel(Ys,c,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var jy=v({conv3d_:LO});function PO(r,t,e,o,n){k(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let s=r,i=t,a=!1;t.rank===4&&(a=!0,i=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let l=s[4],u=i.shape[4];k(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),k(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),k(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),k(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),k(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:n,strides:o,inputShape:s},m=T.runKernel(Fl,c,p);return a?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var ih=v({conv3DBackpropInput_:PO});function zO(r,t,e,o,n){let s=N(r,"x","conv3dTranspose"),i=N(t,"filter","conv3dTranspose");return ih(e,s,i,o,n)}var Xy=v({conv3dTranspose_:zO});function MO(r){let e={x:N(r,"x","cos","float32")};return T.runKernel(vn,e)}var Aa=v({cos_:MO});function BO(r){let e={x:N(r,"x","cosh","float32")};return T.runKernel(kn,e)}var op=v({cosh_:BO});function VO(r,t=0,e=!1,o=!1){let s={x:N(r,"x","cumprod")},i={axis:t,exclusive:e,reverse:o};return T.runKernel(_l,s,i)}var np=v({cumprod_:VO});function GO(r,t=0,e=!1,o=!1){let s={x:N(r,"x","cumsum")},i={axis:t,exclusive:e,reverse:o};return T.runKernel(Zs,s,i)}var ah=v({cumsum_:GO});function WO(r,t,e,o=!1){let n=N(r,"x","denseBincount"),s=N(t,"weights","denseBincount");k(n.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${n.dtype}`),k(n.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${n.rank}.`),k(e>=0,()=>`size must be non-negative, but got ${e}.`),k(s.size===n.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${n.shape}, weights shape: ${s.shape}.`);let i={x:n,weights:s},a={size:e,binaryOutput:o};return T.runKernel(Ll,i,a)}var lh=v({denseBincount_:WO});function UO(r,t,e="NHWC"){let o=N(r,"x","depthToSpace","float32"),n=e==="NHWC"?o.shape[1]:o.shape[2],s=e==="NHWC"?o.shape[2]:o.shape[3],i=e==="NHWC"?o.shape[3]:o.shape[1];k(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),k(n*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${n} and ${t}  for depthToSpace with input shape
    ${o.shape}`),k(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${o.shape}`),k(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${o.shape}`);let a={x:o},l={blockSize:t,dataFormat:e};return T.runKernel(Pl,a,l)}var rI=v({depthToSpace_:UO});function HO(r,t,e,o,n="NHWC",s=[1,1],i){let a=N(r,"x","depthwiseConv2d","float32"),l=N(t,"filter","depthwiseConv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),k(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let p=n==="NHWC"?u.shape[3]:u.shape[1];k(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),Zt("depthwiseConv2d",o,i);let m={x:u,filter:l},f={strides:e,pad:o,dataFormat:n,dilations:s,dimRoundingMode:i},h=T.runKernel(Js,m,f);return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var hs=v({depthwiseConv2d_:HO});function KO(r,t,e,o,n=[1,1],s="NHWC"){let i=N(r,"x","dilation2d"),a=N(t,"filter","dilation2d");k(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),k(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),k(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),k(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);let c={x:l,filter:a},p={strides:e,pad:o,dilations:n},m=T.runKernel(Qs,c,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var oI=v({dilation2d_:KO});var Rr={};Jr(Rr,{assertAndGetBroadcastShape:()=>Nt,getBroadcastDims:()=>nI,getReductionAxes:()=>Ht});function nI(r,t){let e=r.length,o=[];for(let n=0;n<e;n++){let s=e-1-n,i=r[s]||1;(t[t.length-1-n]||1)>1&&i===1&&o.unshift(s)}return o}function Ht(r,t){let e=[];for(let o=0;o<t.length;o++){let n=r[r.length-o-1],s=t.length-o-1,i=t[s];(n==null||n===1&&i>1)&&e.unshift(s)}return e}function Nt(r,t){let e=[],o=Math.max(r.length,t.length);for(let n=0;n<o;n++){let s=r[r.length-n-1];s==null&&(s=1);let i=t[t.length-n-1];if(i==null&&(i=1),s===1)e.unshift(i);else if(i===1)e.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(a)}else e.unshift(s)}return e}function qO(r,t){let e=N(r,"a","equal","string_or_numeric"),o=N(t,"b","equal","string_or_numeric");[e,o]=$t(e,o),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(la,n)}var pr=v({equal_:qO});function jO(r,t,e){let o=N(t,"a","where"),n=N(e,"b","where"),s=N(r,"condition","where","bool"),i=Nt(Nt(s.shape,o.shape),n.shape),a=ms(s,i),l=ms(o,i),u=ms(n,i),c={condition:a,t:l,e:u};return T.runKernel(Ii,c)}var ne=v({where_:jO});function XO(r){let e={x:N(r,"x","zerosLike")};return T.runKernel($i,e)}var ht=v({zerosLike_:XO});function YO(r,t){let e=N(r,"a","div"),o=N(t,"b","div");[e,o]=$t(e,o);let n=ot(e,o),s=ht(n),i=pr(o,s);return ne(i,s,n)}var sI=v({divNoNan_:YO});function ZO(r,t){let e=N(r,"t1","dot"),o=N(t,"t2","dot");k((e.rank===1||e.rank===2)&&(o.rank===1||o.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${o.rank}.`);let n=e.rank===1?e.size:e.shape[1],s=o.rank===1?o.size:o.shape[0];if(k(n===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${n} and ${s}.`),e.rank===1&&o.rank===1){let i=F(e,[1,-1]),a=F(o,[-1,1]),l=Pt(i,a);return F(l,[])}else if(e.rank===1&&o.rank===2){let i=F(e,[1,-1]),a=F(o,[o.shape[0],o.shape[1]]),l=Pt(i,a);return F(l,[l.size])}else if(e.rank===2&&o.rank===1){let i=F(o,[-1,1]),a=Pt(e,i);return F(a,[a.size])}else{let i=F(o,[o.shape[0],o.shape[1]]);return Pt(e,i)}}var iI=v({dot_:ZO});function JO(r){let e={x:N(r,"x","elu","float32")};return T.runKernel(An,e)}var ds=v({elu_:JO});function QO(r){let t=N(r,"x","erf");k(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Y(t,"float32"));let e={x:t};return T.runKernel($n,e)}var Yy=v({erf_:QO});function Zy(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function aI(r,t,e){let o=r.length+t.length,n=[],s=0,i=0;for(let a=0;a<o;a++)e.indexOf(a)===-1?n.push(r[s++]):n.push(t[i++]);return n}function Jy(r,t){let e=[],o=r.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&e.push(r[s]);let n=t.map(s=>r[s]);return[e,n]}function Qo(r,t){let e=t.map(o=>1);return aI(r,e,t)}function tL(r,t,e){k(Zy(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Qy(r,t){if(Zy(r,t))return null;let e=[];for(let o=0;o<t;++o)r.indexOf(o)===-1&&e.push(o);return r.forEach(o=>e.push(o)),e}function sp(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function eL(r,t){let e=[];for(let o=t-r;o<t;++o)e.push(o);return e}function rL(r,t=null,e=!1){let n={x:N(r,"x","max")},s={reductionIndices:t,keepDims:e};return T.runKernel(si,n,s)}var Ke=v({max_:rL});function oL(r,t=null,e=!1){let n={x:N(r,"x","min")},s={axis:t,keepDims:e};return T.runKernel(ui,n,s)}var zi=v({min_:oL});function nL(r,t){let e=N(r,"base","pow"),o=N(t,"exp","pow");[e,o]=$t(e,o);let n={a:e,b:o};return T.runKernel(Hn,n)}var so=v({pow_:nL});function xt(r,t){if((br(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&br(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Oi(r,[],[],t)}function sL(r){let e={x:N(r,"x","sqrt","float32")};return T.runKernel(os,e)}var ee=v({sqrt_:sL});function iL(r){let t=N(r,"x","square"),e={};return T.runKernel("Square",{x:t},e)}var At=v({square_:iL});function aL(r,t=null,e=!1){let o=N(r,"x","sum");o.dtype==="bool"&&(o=Y(o,"int32"));let n={x:o},s={axis:t,keepDims:e};return T.runKernel(Ni,n,s)}var it=v({sum_:aL});function lL(r,t="euclidean",e=null,o=!1){r=N(r,"x","norm");let n=lI(r,t,e),s=n.shape;if(o){let i=Ee(e,r.shape);s=Qo(n.shape,i)}return F(n,s)}function lI(r,t,e=null){if(r.rank===0)return ve(r);if(r.rank!==1&&e===null)return lI(F(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return it(ve(r),e);if(t===1/0)return Ke(ve(r),e);if(t===-1/0)return zi(ve(r),e);if(t==="euclidean"||t===2)return ee(it(so(ve(r),xt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Ke(it(ve(r),e[0]),e[1]-1);if(t===1/0)return Ke(it(ve(r),e[1]),e[0]);if(t===-1/0)return zi(it(ve(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return ee(it(At(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var Mi=v({norm_:lL});function uL(r,t=null,e=!1){return Mi(r,"euclidean",t,e)}var uI=v({euclideanNorm_:uL});function cL(r){let e={x:N(r,"x","exp")};return T.runKernel(Dn,e)}var Ze=v({exp_:cL});function pL(r,t=0){let e=N(r,"x","expandDims","string_or_numeric");k(t<=e.rank,()=>"Axis must be <= rank of the tensor");let o={input:e},n={dim:t};return T.runKernel(ti,o,n)}var Ae=v({expandDims_:pL});function mL(r){let e={x:N(r,"x","expm1")};return T.runKernel(Rn,e)}var eb=v({expm1_:mL});function fL(r,t){let e=N(r,"x","tile","string_or_numeric");k(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let o={x:e},n={reps:t};return T.runKernel(Ko,o,n)}var Je=v({tile_:fL});function hL(r,t,e,o="float32"){t==null&&(t=r);let n=ft([r,t],o),s=r<=t?r:t;for(let a=0;a<s;++a)n.set(1,a,a);let i=F(n.toTensor(),[r,t]);if(e==null)return i;if(e.length===1)return Je(Ae(i,0),[e[0],1,1]);if(e.length===2)return Je(Ae(Ae(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return Je(Ae(Ae(Ae(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var Su=v({eye_:hL});function dL(r){let e={x:N(r,"x","floor","float32")};return T.runKernel(Fn,e)}var gs=v({floor_:dL});function gL(r,t,e=0,o=0){let n=N(r,"x","gather"),s=N(t,"indices","gather","int32"),i={x:n,indices:s},a={axis:e,batchDims:o};return T.runKernel(ri,i,a)}var $a=v({gather_:gL});function xL(r,t){let e=N(r,"a","greater","string_or_numeric"),o=N(t,"b","greater","string_or_numeric");[e,o]=$t(e,o),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(ua,n)}var xe=v({greater_:xL});function yL(r,t){let e=N(r,"a","greaterEqual","string_or_numeric"),o=N(t,"b","greaterEqual","string_or_numeric");[e,o]=$t(e,o),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(On,n)}var wr=v({greaterEqual_:yL});function bL(r){let e={input:N(r,"input","imag")};return T.runKernel(Hl,e)}var Nu=v({imag_:bL});function wL(r){let e={x:N(r,"x","isFinite")};return T.runKernel(Ln,e)}var rb=v({isFinite_:wL});function CL(r){let e={x:N(r,"x","isInf")};return T.runKernel(Pn,e)}var ob=v({isInf_:CL});function IL(r){let e={x:N(r,"x","isNaN")};return T.runKernel(zn,e)}var nb=v({isNaN_:IL});function SL(r,t=.2){let o={x:N(r,"x","leakyRelu")},n={alpha:t};return T.runKernel(oi,o,n)}var Da=v({leakyRelu_:SL});function NL(r,t){let e=N(r,"a","less","string_or_numeric"),o=N(t,"b","less","string_or_numeric");[e,o]=$t(e,o),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(ca,n)}var uh=v({less_:NL});function TL(r,t){let e=N(r,"a","lessEqual","string_or_numeric"),o=N(t,"b","lessEqual","string_or_numeric");[e,o]=$t(e,o),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(pa,n)}var io=v({lessEqual_:TL});function vL(r,t=5,e=1,o=1,n=.5){let s=N(r,"x","localResponseNormalization");k(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),k(gn(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:e,alpha:o,beta:n},c=T.runKernel(ni,l,u);return a?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var cI=v({localResponseNormalization_:vL});function kL(r){let e={x:N(r,"x","log","float32")};return T.runKernel(Mn,e)}var mr=v({log_:kL});function EL(r){let e={x:N(r,"x","log1p")};return T.runKernel(Bn,e)}var ip=v({log1p_:EL});function sb(r,t){k(Cl(r),()=>"The f passed in variableGrads(f) must be a function"),k(t==null||Array.isArray(t)&&t.every(u=>u instanceof us),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let u in T.registeredVariables)t.push(T.registeredVariables[u])}let o=e?t.filter(u=>!u.trainable):null,n=t.length;t=t.filter(u=>u.trainable),k(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${n} variables is trainable.`);let s=!0,{value:i,grads:a}=T.gradients(r,t,null,s);k(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),k(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),o!=null&&o.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Kr(r){return T.customGrad(r)}function AL(r){let e={x:N(r,"x","neg")};return T.runKernel(pi,e)}var zt=v({neg_:AL});function $L(r){let e={x:N(r,"x","softplus")};return T.runKernel(rs,e)}var tn=v({softplus_:$L});function DL(r){let t=N(r,"x","logSigmoid");return Kr(o=>({value:zt(tn(zt(o))),gradFunc:i=>R(i,no(zt(o)))}))(t)}var ib=v({logSigmoid_:DL});function RL(r,t){let e=N(r,"a","sub"),o=N(t,"b","sub");[e,o]=$t(e,o);let n={a:e,b:o};return T.runKernel(ss,n)}var ct=v({sub_:RL});function FL(r,t=-1){let e=N(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Kr((n,s)=>{let a=Ke(n,t,!0),l=ct(n,a),u=ct(Y(l,"float32"),mr(it(Ze(l),t,!0)));return s([u]),{value:u,gradFunc:(p,m)=>{let[f]=m,h=!0,d=Ze(f);return ct(p,R(it(p,t,h),d))}}})(e)}var ap=v({logSoftmax_:FL});function _L(r,t=null,e=!1){let o=N(r,"x","logSumExp"),n=Ee(t,o.shape),s=Ke(o,n,!0),i=ct(o,s),a=Ze(i),l=it(a,n),u=mr(l),c=X(F(s,u.shape),u);if(e){let p=Qo(c.shape,n);return F(c,p)}return c}var pI=v({logSumExp_:_L});function OL(r,t){let e=N(r,"a","logicalAnd","bool"),o=N(t,"b","logicalAnd","bool");Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(ma,n)}var nr=v({logicalAnd_:OL});function LL(r){let e={x:N(r,"x","logicalNot","bool")};return T.runKernel(fa,e)}var Tu=v({logicalNot_:LL});function PL(r,t){let e=N(r,"a","logicalOr","bool"),o=N(t,"b","logicalOr","bool");Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(ha,n)}var ch=v({logicalOr_:PL});function zL(r,t){let e=N(r,"a","logicalXor","bool"),o=N(t,"b","logicalXor","bool");return Nt(e.shape,o.shape),nr(ch(r,t),Tu(nr(r,t)))}var mI=v({logicalXor_:zL});function ML(r,t,e,o,n){let s=N(r,"x","maxPool"),i=1,a=s,l=!1;s.rank===3&&(l=!0,a=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),k(Ue(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Zt("maxPool",o,n);let u={x:a},c={filterSize:t,strides:e,pad:o,dimRoundingMode:n},p=T.runKernel(ii,u,c);return l?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ra=v({maxPool_:ML});function BL(r,t=[1,1,1],e,o,n,s="NDHWC"){let i=N(r,"x","maxPool3d"),a=i,l=!1;i.rank===4&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Zt("maxPool3d",o,n);let u={x:a},c={filterSize:t,strides:e,pad:o,dimRoundingMode:n,dataFormat:s},p=T.runKernel(ai,u,c);return l?F(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var ab=v({maxPool3d_:BL});function VL(r,t){let e=N(r,"a","maximum"),o=N(t,"b","maximum");[e,o]=$t(e,o),e.dtype==="bool"&&(e=Y(e,"int32"),o=Y(o,"int32")),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(Vn,n)}var Fr=v({maximum_:VL});function GL(r,t=null,e=!1){let n={x:N(r,"x","mean")},s={axis:t,keepDims:e};return T.runKernel(li,n,s)}var se=v({mean_:GL});function re(r,t="float32"){if(Ve(r),t==="complex64"){let o=re(r,"float32"),n=re(r,"float32");return Wr(o,n)}let e=Sl(Bt(r),t);return T.makeTensor(e,r,t)}function _r(r,t="float32"){if(Ve(r),t==="complex64"){let o=_r(r,"float32"),n=re(r,"float32");return Wr(o,n)}let e=Bc(Bt(r),t);return T.makeTensor(e,r,t)}function WL(r,t){let e=N(r,"a","minimum"),o=N(t,"b","minimum");[e,o]=$t(e,o),e.dtype==="bool"&&(e=Y(e,"int32"),o=Y(o,"int32")),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(Gn,n)}var Fa=v({minimum_:WL});function UL(r,t,e){k(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let o=N(r,"x","mirrorPad");if(o.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(t.length===o.rank,()=>`Padding doesn't match input. Must be ${o.rank}. Got ${t.length}.`);let n=e==="reflect"?1:0;for(let a=0;a<o.rank;a++)k(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),k(t[a][0]>=0&&t[a][0]<=o.shape[a]-n&&t[a][1]>=0&&t[a][1]<=o.shape[a]-n,()=>`Padding in dimension ${a} cannot be greater than or equal to ${o.shape[a]-n} or less than 0 for input of shape ${o.shape}`);let s={paddings:t,mode:e},i={x:o};return T.runKernel(ci,i,s)}var fI=v({mirrorPad_:UL});function HL(r,t){let e=N(r,"a","mod"),o=N(t,"b","mod");[e,o]=$t(e,o);let n={a:e,b:o};return T.runKernel(Wn,n)}var hI=v({mod_:HL});function KL(r,t=null,e=!1){r=N(r,"x","moments");let o=Ee(t,r.shape),n=se(r,o,e),s=n.shape;e||(s=Qo(n.shape,o));let i=At(ct(Y(r,"float32"),F(n,s))),a=se(i,o,e);return{mean:n,variance:a}}var vu=v({moments_:KL});function qL(r,t){let e=N(r,"a","notEqual","string_or_numeric"),o=N(t,"b","notEqual","string_or_numeric");[e,o]=$t(e,o),Nt(e.shape,o.shape);let n={a:e,b:o};return T.runKernel(da,n)}var Bi=v({notEqual_:qL});function jL(r,t,e=1,o=0,n="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:N(r,"indices","oneHot","int32")},a={dtype:n,depth:t,onValue:e,offValue:o};return T.runKernel(fi,i,a)}var ku=v({oneHot_:jL});function XL(r){let e={x:N(r,"x","onesLike")};return T.runKernel(mi,e)}var Le=v({onesLike_:XL});function YL(r,t,e=0){let o=N(r,"x","pad");if(o.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let n={paddings:t,constantValue:e},s={x:o};return T.runKernel(di,s,n)}var _a=v({pad_:YL});function ZL(r,t,e){let o=N(r,"x","spaceToBatchND");k(o.rank>=1+t.length,()=>`input rank ${o.rank} should be > than [blockShape] ${t.length}`),k(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),k(o.shape.reduce((i,a,l)=>l>0&&l<=t.length?i&&(a+e[l-1][0]+e[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let n={x:o},s={blockShape:t,paddings:e};return T.runKernel(Ti,n,s)}var Eu=v({spaceToBatchND_:ZL});function JL(r,t,e,o,n,s,i){n==null&&(n=[1,1]),s==null&&(s=1),o===0&&(o="valid");let a=N(r,"x","maxPool"),l=a,u=!1;a.rank===3&&(u=!0,l=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(Ue(s,n),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${n}'`);let c=Py(l.shape,t,s,n,o),p=[c.dilationHeight,c.dilationWidth],m;o==="same"?m=tP([c.filterHeight,c.filterWidth],p):m=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[h,d]=QL([c.inHeight,c.inWidth],p,m),g=f?o:"valid",x=f?l:Eu(l,p,h),C=(e==="avg"?()=>Ea(x,t,s,g,i):()=>Ra(x,t,s,g,i))(),w=f?C:Cu(C,p,d);return u?F(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function QL(r,t,e){let o=e.map(c=>c[0]),n=e.map(c=>c[1]),s=r.concat(o,n),i=t.map((c,p)=>(c-s[p]%c)%c),a=n.map((c,p)=>c+i[p]),l=t.map((c,p)=>[o[p],a[p]]),u=t.map((c,p)=>[0,i[p]]);return[l,u]}function tP(r,t){let o=r.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),n=o.map(i=>Math.floor(i/2)),s=o.map((i,a)=>i-n[a]);return o.map((i,a)=>[n[a],s[a]])}var dI=v({pool_:JL});function eP(r,t){let e=N(r,"x","prelu"),o=N(t,"alpha","prelu"),n={x:e,alpha:o};return T.runKernel(gi,n)}var Oa=v({prelu_:eP});function rP(r,t=null,e=!1){let o=N(r,"x","prod");o.dtype==="bool"&&(o=Y(o,"int32"));let n={x:o},s={axis:t,keepDims:e};return T.runKernel(xi,n,s)}var gI=v({prod_:rP});var hb=zc(lp());var Au=class{constructor(t,e,o,n,s){this.mean=t,this.stdDev=e,this.dtype=o,this.nextVal=NaN,this.truncated=n,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=hb.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let n=this.nextVal;return this.nextVal=NaN,n}let t,e,o=!1;for(;!o;){let n,s,i;do n=2*this.random()-1,s=2*this.random()-1,i=n*n+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*n*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(o=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}};var mh=class{constructor(t=0,e=1,o,n){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=o,n==null&&(n=Math.random()),typeof n=="number"&&(n=n.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=hb.alea(n)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function uP(r,t=0,e=1,o,n){if(Ve(r),o!=null&&o==="bool")throw new Error(`Unsupported data type ${o}`);let s=new Au(t,e,o,!1,n),i=ft(r,o);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var fh=v({randomNormal_:uP});function cP(r,t=0,e=1,o="float32",n){Ve(r);let s=ft(r,o),i=new mh(t,e,null,n);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var xs=v({randomUniform_:cP});function ys(r,t,e=1,o="float32"){if(e===0)throw new Error("Cannot have a step of zero");let n={start:r,stop:t,step:e,dtype:o};return T.runKernel(Jl,{},n)}function pP(r){let e={input:N(r,"input","real")};return T.runKernel(Ql,e)}var Pa=v({real_:pP});function mP(r){let e={x:N(r,"x","reciprocal")};return T.runKernel(Kn,e)}var db=v({reciprocal_:mP});function fP(r){let e={x:N(r,"x","relu")};return T.runKernel(qn,e)}var Or=v({relu_:fP});function hP(r){let e={x:N(r,"x","relu6")};return T.runKernel(jn,e)}var hh=v({relu6_:hP});function dP(r,t){let o={x:N(r,"x","reverse")},n={dims:t};return T.runKernel(Ci,o,n)}var qr=v({reverse_:dP});function gP(r){let e={x:N(r,"x","round")};return T.runKernel(Xn,e)}var up=v({round_:gP});function xP(r){let e={x:N(r,"x","rsqrt","float32")};return T.runKernel(Yn,e)}var cp=v({rsqrt_:xP});function yP(r){let e={x:N(r,"x","selu")};return T.runKernel(Zn,e)}var pp=v({selu_:yP});function bP(r,t,e,o,n,s=[1,1],i="NHWC"){let a=N(r,"x","separableConv2d"),l=N(t,"depthwiseFilter","separableConv2d"),u=N(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");k(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),k(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),k(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),k(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),k(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let m=l.shape[2],f=l.shape[3];k(u.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${u.shape[2]}.`);let h=hs(c,l,o,n,i,s),g=Dr(h,u,1,"valid",i);return p?F(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var mp=v({separableConv2d_:bP});function wP(r){let e={x:N(r,"x","sign")};return T.runKernel(ts,e)}var gb=v({sign_:wP});function CP(r){let e={x:N(r,"x","sin","float32")};return T.runKernel(Jn,e)}var fp=v({sin_:CP});function IP(r){let e={x:N(r,"x","sinh")};return T.runKernel(Qn,e)}var hp=v({sinh_:IP});function SP(r,t,e){let o=N(r,"x","slice1d");return k(o.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${o.rank} tensor`),Rt(o,[t],[e])}var dp=v({slice1d_:SP});function NP(r,t,e){let o=N(r,"x","slice2d");return k(o.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${o.rank} tensor`),Rt(o,t,e)}var dh=v({slice2d_:NP});function TP(r,t,e){let o=N(r,"x","slice3d");return k(o.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${o.rank} tensor`),Rt(o,t,e)}var gp=v({slice3d_:TP});function vP(r,t,e){let o=N(r,"x","slice4d");return k(o.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${o.rank} tensor`),Rt(o,t,e)}var $u=v({slice4d_:vP});function kP(r,t=-1){let e=N(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let o={logits:e},n={dim:t};return T.runKernel(ki,o,n)}var za=v({softmax_:kP});function EP(r){k(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return T.runKernel(Vl,t)}var xp=v({fft_:EP});function AP(r){k(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return T.runKernel(Ul,t)}var Du=v({ifft_:AP});function $P(r){let t=r.shape[r.shape.length-1],e=r.size/t,o;if(t<=2){let n=F(r,[e,t]);o=Du(n)}else{let n=[e,2*(t-1)],s=F(Pa(r),[e,t]),i=F(Nu(r),[e,t]),a=qr(Rt(s,[0,1],[e,t-2]),1),l=R(qr(Rt(i,[0,1],[e,t-2]),1),xt(-1)),u=te([s,a],1),c=te([i,l],1),p=F(Wr(u,c),[n[0],n[1]]);o=Du(p)}if(o=Pa(o),r.rank===3&&r.shape[0]!==0){let n=o,s=r.shape[0];o=F(o,[s,o.shape[0]/s,o.shape[1]]),n.dispose()}return o}var xb=v({irfft_:$P});function DP(r,t,e=0){let n={x:N(r,"x","split")},s={numOrSizeSplits:t,axis:e};return T.runKernel(vi,n,s)}var Re=v({split_:DP});function RP(r,t){k(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],o=r.size/e,n;if(t!=null&&t<e){let h=r.shape.map(g=>0),d=r.shape.map(g=>g);d[r.shape.length-1]=t,n=Rt(r,h,d),e=t}else if(t!=null&&t>e){let h=r.shape.map(d=>d);h[r.shape.length-1]=t-e,n=te([r,re(h)],r.shape.length-1),e=t}else n=r;let s=ht(n),i=F(Wr(n,s),[o,e]),a=xp(i),l=Math.floor(e/2)+1,u=Pa(a),c=Nu(a),p=Re(u,[l,e-l],u.shape.length-1),m=Re(c,[l,e-l],c.shape.length-1),f=n.shape.slice();return f[n.shape.length-1]=l,F(Wr(p[0],m[0]),f)}var yb=v({rfft_:RP});function FP(r,t){let e=N(r,"a","squaredDifference"),o=N(t,"b","squaredDifference");[e,o]=$t(e,o),Nt(e.shape,o.shape);let n={a:e,b:o},s={};return T.runKernel(ns,n,s)}var FI=v({squaredDifference_:FP});function _P(r,t){let e=N(r,"x","squeeze","string_or_numeric");return F(e,jx(e.shape,t).newShape)}var Ao=v({squeeze_:_P});function OP(r,t=0){let e=Yf(r,"tensors","stack","string_or_numeric");k(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&k(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let o=e,n={axis:t};return T.runKernel(hi,o,n)}var Fe=v({stack_:OP});function LP(r,t=0){let o={x:N(r,"x","step")},n={alpha:t};return T.runKernel(ls,o,n)}var $o=v({step_:LP});function PP(r,t,e,o,n=0,s=0,i=0,a=0,l=0){let c={x:N(r,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:o,beginMask:n,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return T.runKernel(ou,c,p)}var bb=v({stridedSlice_:PP});function zP(r){let e={x:N(r,"x","tan","float32")};return T.runKernel(is,e)}var wb=v({tan_:zP});function $e(r,t){Mc(r);let e=Ta(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Oi(r,null,e,t)}function yp(r,t,e){if(Mc(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let o=Ta(r,e);if(o.length!==2&&o.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(o.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Oi(r,t,o,e)}function MP(r,t=1,e=!0){let o=N(r,"x","topk");if(o.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let n=o.shape[o.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>n)throw new Error(`'k' passed to topk() must be <= the last dimension (${n}) but got ${t}`);let s={x:o},i={k:t,sorted:e},[a,l]=T.runKernel(nu,s,i);return{values:a,indices:l}}var _I=v({topk_:MP});function BP(r,t=0,e=1,o,n){if(Ve(r),o!=null&&o==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new Au(t,e,o,!0,n),i=ft(r,o);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var bp=v({truncatedNormal_:BP});function VP(r,t=0){let e=N(r,"x","unique","string_or_numeric");k(e.rank>0,()=>"The input tensor must be at least 1D");let o={x:e},n={axis:t},[s,i]=T.runKernel(iu,o,n);return{values:s,indices:i}}var OI=v({unique_:VP});function GP(r,t,e){let o=N(r,"x","unsortedSegmentSum"),n=N(t,"segmentIds","unsortedSegmentSum","int32");k(gn(e),()=>"numSegments must be of dtype int");let s={x:o,segmentIds:n},i={numSegments:e};return T.runKernel(Ai,s,i)}var gh=v({unsortedSegmentSum_:GP});function WP(r,t=0){let e=N(r,"x","unstack","string_or_numeric");k(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let o={value:e},n={axis:t};return T.runKernel(Ei,o,n)}var sr=v({unstack_:WP});function Cb(r,t=!0,e,o){return T.makeVariable(r,t,e,o)}function LI(r,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let o=ft(r,"int32"),n=ft([e.length,r.length],"int32");for(let s=0;s<e.length;s++){let i=o.indexToLoc(e[s]),a=s*r.length;n.values.set(i,a)}return n.toTensor()}function UP(r,t,e){let o=N(r,"x","transpose");if(t==null&&(t=o.shape.map((i,a)=>a).reverse()),k(o.rank===t.length,()=>`Error in transpose: rank of input ${o.rank} must match length of perm ${t}.`),t.forEach(i=>{k(i>=0&&i<o.rank,()=>`All entries in 'perm' must be between 0 and ${o.rank-1} but got ${t}`)}),o.rank<=1)return o.clone();let n={x:o},s={perm:t};return o.dtype==="complex64"?z(()=>{let i=Pa(o),a=Nu(o);return i=T.runKernel(qo,{x:i},s),a=T.runKernel(qo,{x:a},s),e&&(a=zt(a)),Wr(i,a)}):T.runKernel(qo,n,s)}var vt=v({transpose_:UP});function PI(r,t,e){let o=t.rank>1?t.shape[t.rank-1]:1,n=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${o}, and batchDim: ${n}.`;if(e.rank<n)throw new Error(s+` update.rank < ${n}. `);if(r.length<o+(e.rank-n))throw new Error(s+` Output shape length < ${o+(e.rank-n)}`);if(e.rank!==n+r.length-o)throw new Error(s+` update.rank != ${n+r.length-o}`);for(let i=0;i<n;++i)if(e.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-n;++i)if(e.shape[i+n]!==r[i+o])throw new Error(s+` updates.shape[${i+n}] (${e.shape[i+n]}) != shape[${i+n}] (${r[i+n]})`)}function HP(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}PI(e,t,r)}function KP(r,t,e){let o=t.shape.length,n=o>1?t.shape[o-1]:1,s=e.length,i=1;for(let p=n;p<s;++p)i*=e[p];let a=n<1?1:n,l=Bt(t.shape)/a,u=[...Wo(e.slice(0,n)),1],c=Bt(e);return{sliceRank:n,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}function zI(r,t){if(t==null)return r.shape.slice();if(zs(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let o=0;o<r.shape.length;o++)t[o]==null&&r.shape[o]!=null?e.push(r.shape[o]):e.push(t[o]);return e}return t}function qP(r,t,e,o){let n=N(r,"x","dropout");if(k(n.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${n.dtype} tensor instead.`),k(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof _t?n.clone():n;let s=zI(n,e),i=1-t,a=ot(gs(X(xs(s,0,1,"float32",o),i)),i);return R(n,a)}var MI=v({dropout_:qP});var Wa={};Jr(Wa,{conv2d:()=>BI,depthwiseConv2d:()=>VI,matMul:()=>GI});function jP(r,t,e,o,n,s="NHWC",i){let a=r;r.rank===3&&(a=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=t;l.rank===3&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),k(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),k(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),k(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let u=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];k(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),k(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),Zt("conv2dDerFilter",n,i);let p={x:a,dy:l},m={strides:o,pad:n,dataFormat:s,dimRoundingMode:i,filterShape:e};return T.runKernel(Dl,p,m)}var Ru=v({conv2DBackpropFilter_:jP});function Ma(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return R(r,$o(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Ba(r,t){let e=t,o=Ht(r.shape,t.shape);return o.length>0&&(e=it(e,o)),F(e,r.shape)}function Va(r,t,e,o){if(t==="linear")return r;if(t==="relu")return Or(r);if(t==="elu")return ds(r);if(t==="relu6")return hh(r);if(t==="prelu")return Oa(r,e);if(t==="leakyrelu")return Da(r,o);if(t==="sigmoid")return no(r);throw new Error(`Unknown fused activation ${t}.`)}var Ga=(r,t)=>!(r>0)||t==="linear";function XP({x:r,filter:t,strides:e,pad:o,dataFormat:n="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",Ga(T.state.gradientDepth,l)===!1){k(n==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${n} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=Dr(r,t,e,o,n,s,i);return a!=null&&(E=X(E,a)),Va(E,l,u,c)}let p=N(r,"x","conv2d","float32"),m=N(t,"filter","conv2d","float32"),f=p,h=!1;p.rank===3&&(h=!0,f=F(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),k(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Zt("fused conv2d",o,i);let d=n==="NHWC"?f.shape[3]:f.shape[1];k(m.shape[2]===d,()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${m.shape[2]}.`),k(Ue(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let g=ka(f.shape,m.shape,e,s,o,i),x;a!=null&&(x=N(a,"bias","fused conv2d"),[x]=$t(x,p),n==="NHWC"?Nt(g.outShape,x.shape):(k(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),k(x.shape.length===0||x.shape[0]===g.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){let E=u.shape;if(k(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)k(E[0]===1||E[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${g.outChannels}).`);else if(E.length===3)try{Nt(E,g.outShape)}catch(A){let $=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error($)}b=N(u,"prelu weights","fused conv2d")}let C=(E,A)=>{k(n==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${n} but only NHWC is currently supported.`);let[$,_,L,B]=A,V=Ma(E,L,l);k(Ur(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let G=Iu(_.shape,V,$,e,o),U=Ru(_,V,$.shape,e,o),W=[G,U];if(B!=null){let q=Ba(B,V);W.push(q)}return W},w={x:f,filter:m,bias:x,preluActivationWeights:b},I={strides:e,pad:o,dataFormat:n,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?Kr((A,$,_)=>{let L=T.runKernel(xa,w,I);return _([$,A,L]),h&&(L=F(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:C}})(f,m):Kr((A,$,_,L)=>{let B=T.runKernel(xa,w,I);return L([$,A,B,_]),h&&(B=F(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:C}})(f,m,x)}var BI=v({fusedConv2d_:XP});function YP(r,t,e,o,n,s=[1,1],i){let a=r;r.rank===3&&(a=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=t;l.rank===3&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:a,dy:l},c={strides:o,pad:n,dimRoundingMode:i,dilations:s,filterShape:e};return T.runKernel(zl,u,c)}var xh=v({depthwiseConv2dNativeBackpropFilter_:YP});function ZP(r,t,e,o,n,s=[1,1],i){let a=t,l=!1;t.rank===3&&(l=!0,a=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:a,filter:e},c={strides:o,pad:n,dimRoundingMode:i,dilations:s,inputShape:r},p=T.runKernel(Ml,u,c);return l?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var yh=v({depthwiseConv2dNativeBackpropInput_:ZP});function JP({x:r,filter:t,strides:e,pad:o,dataFormat:n="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(Ga(T.state.gradientDepth,l)===!1){let I=hs(r,t,e,o,n,s,i);return a!=null&&(I=X(I,a)),Va(I,l,u,c)}let p=N(r,"x","depthwiseConv2d","float32"),m=N(t,"filter","depthwiseConv2d","float32"),f=p,h=!1;p.rank===3&&(h=!0,f=F(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),k(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),k(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),k(Ue(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),Zt("fused depthwiseConv2d",o,i);let d=ka(f.shape,m.shape,e,s,o,i,!0),g;a!=null&&(g=N(a,"bias","fused conv2d"),[g]=$t(g,p),Nt(d.outShape,g.shape));let x;u!=null&&(x=N(u,"prelu weights","fused depthwiseConv2d"));let b=(I,E)=>{k(Ur(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[A,$,_,L]=E,B=Ma(I,_,l),V=yh($.shape,B,A,e,o,s,i),G=xh($,B,A.shape,e,o,s,i);if(L!=null){let U=Ba(g,B);return[V,G,U]}return[V,G]},C={x:f,filter:m,bias:g,preluActivationWeights:x},w={strides:e,pad:o,dataFormat:n,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?Kr((E,A,$)=>{let _=T.runKernel(ya,C,w);return $([A,E,_]),h&&(_=F(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:b}})(f,m):Kr((E,A,$,_)=>{let L=T.runKernel(ya,C,w);return _([A,E,L,$]),h&&(L=F(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:b}})(f,m,g)}var VI=v({fusedDepthwiseConv2d_:JP});function QP({a:r,b:t,transposeA:e=!1,transposeB:o=!1,bias:n,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Ga(T.state.gradientDepth,s)===!1){let B=Pt(r,t,e,o);return n!=null&&(B=X(B,n)),Va(B,s,i,a)}let l=N(r,"a","fused matMul"),u=N(t,"b","fused matMul");[l,u]=$t(l,u);let c=e?l.shape[l.rank-2]:l.shape[l.rank-1],p=o?u.shape[u.rank-1]:u.shape[u.rank-2],m=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=o?u.shape[u.rank-2]:u.shape[u.rank-1],h=l.shape.slice(0,-2),d=u.shape.slice(0,-2),g=Bt(h),x=Bt(d);k(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${o} must match.`);let C=Nt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([m,f]),w=e?F(l,[g,c,m]):F(l,[g,m,c]),I=o?F(u,[x,f,p]):F(u,[x,p,f]),E;n!=null&&(E=N(n,"bias","fused matMul"),[E]=$t(E,l),Nt(C,E.shape));let A;i!=null&&(A=N(i,"prelu weights","fused matMul"));let $=(B,V)=>{let[G,U,W,q]=V,Z=Ma(F(B,W.shape),W,s),K,J;if(!e&&!o?(K=Pt(Z,U,!1,!0),J=Pt(G,Z,!0,!1)):!e&&o?(K=Pt(Z,U,!1,!1),J=Pt(Z,G,!0,!1)):e&&!o?(K=Pt(U,Z,!1,!0),J=Pt(G,Z,!1,!1)):(K=Pt(U,Z,!0,!0),J=Pt(Z,G,!0,!0)),n!=null){let tt=Ba(q,Z);return[K,J,tt]}else return[K,J]},_={a:w,b:I,bias:E,preluActivationWeights:A},L={transposeA:e,transposeB:o,activation:s,leakyreluAlpha:a};return n==null?Kr((V,G,U)=>{let W=T.runKernel(ga,_,L);return U([V,G,W]),{value:F(W,C),gradFunc:$}})(w,I):Kr((V,G,U,W)=>{let q=T.runKernel(ga,_,L);return W([V,G,q,U]),{value:F(q,C),gradFunc:$}})(w,I,E)}var GI=v({fusedMatMul_:QP});function tz(r,t,e,o,n="bilinear",s=0){let i=N(r,"image","cropAndResize"),a=N(t,"boxes","cropAndResize","float32"),l=N(e,"boxInd","cropAndResize","int32"),u=a.shape[0];k(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),k(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),k(o.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${o.length}.`),k(o[0]>=1&&o[1]>=1,()=>`cropSize must be atleast [1,1], but was ${o}`),k(n==="bilinear"||n==="nearest",()=>`method must be bilinear or nearest, but was ${n}`);let c={image:i,boxes:a,boxInd:l},p={method:n,extrapolationValue:s,cropSize:o};return T.runKernel(Ol,c,p)}var WI=v({cropAndResize_:tz});function ez(r){let t=N(r,"image","flipLeftRight","float32");k(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return T.runKernel(Wl,e,{})}var UI=v({flipLeftRight_:ez});function rz(r){let t=N(r,"image","grayscaleToRGB"),e=t.rank-1,o=t.shape[e];k(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),k(o===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${o}.`);let n=new Array(t.rank);return n.fill(1,0,e),n[e]=3,Je(t,n)}var HI=v({grayscaleToRGB_:rz});function oz(r,t,e=0,o=.5){let n=N(r,"image","rotateWithOffset","float32");k(n.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${n.rank}.`);let s={image:n},i={radians:t,fillValue:e,center:o};return T.runKernel(au,s,i)}var KI=v({rotateWithOffset_:oz});function ao(r,t,e,o,n,s){o==null&&(o=.5),n==null&&(n=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return e=Math.min(e,i),k(0<=o&&o<=1,()=>`iouThreshold must be in [0, 1], but was '${o}'`),k(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),k(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),k(t.rank===1,()=>"scores must be a 1D tensor"),k(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),k(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:o,scoreThreshold:n,softNmsSigma:s}}function nz(r,t,e,o=.5,n=Number.NEGATIVE_INFINITY){let s=N(r,"boxes","nonMaxSuppression","float32"),i=N(t,"scores","nonMaxSuppression","float32"),a=ao(s,i,e,o,n);e=a.maxOutputSize,o=a.iouThreshold,n=a.scoreThreshold;let l={maxOutputSize:e,iouThreshold:o,scoreThreshold:n};return T.runKernel(Xl,{boxes:s,scores:i},l)}var qI=v({nonMaxSuppression_:nz});function jI(r,t,e){let o=sz(r,t,e),n=o<0?-(o+1):o;r.splice(n,0,t)}function sz(r,t,e){return az(r,t,e||iz)}function iz(r,t){return r>t?1:r<t?-1:0}function az(r,t,e){let o=0,n=r.length,s=0,i=!1;for(;o<n;){s=o+(n-o>>>1);let a=e(t,r[s]);a>0?o=s+1:(n=s,i=!a)}return i?o:-o-1}function bh(r,t,e,o,n){return Ib(r,t,e,o,n,0)}function wh(r,t,e,o,n,s){return Ib(r,t,e,o,n,0,!1,s,!0)}function Ch(r,t,e,o,n,s){return Ib(r,t,e,o,n,s,!0)}function Ib(r,t,e,o,n,s,i=!1,a=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>n&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(XI);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<e&&u.length>0;){let g=u.pop(),{score:x,boxIndex:b,suppressBeginIndex:C}=g;if(x<n)break;let w=!1;for(let I=p.length-1;I>=C;--I){let E=lz(r,b,p[I]);if(E>=o){w=!0;break}if(g.score=g.score*uz(o,c,E),g.score<=n)break}g.suppressBeginIndex=p.length,w||(g.score===x?(p.push(b),m.push(g.score)):g.score>n&&jI(u,g,XI))}let f=p.length,h=e-f;a&&h>0&&(p.push(...new Array(h).fill(0)),m.push(...new Array(h).fill(0)));let d={selectedIndices:p};return i&&(d.selectedScores=m),l&&(d.validOutputs=f),d}function lz(r,t,e){let o=r.subarray(t*4,t*4+4),n=r.subarray(e*4,e*4+4),s=Math.min(o[0],o[2]),i=Math.min(o[1],o[3]),a=Math.max(o[0],o[2]),l=Math.max(o[1],o[3]),u=Math.min(n[0],n[2]),c=Math.min(n[1],n[3]),p=Math.max(n[0],n[2]),m=Math.max(n[1],n[3]),f=(a-s)*(l-i),h=(p-u)*(m-c);if(f<=0||h<=0)return 0;let d=Math.max(s,u),g=Math.max(i,c),x=Math.min(a,p),b=Math.min(l,m),C=Math.max(x-d,0)*Math.max(b-g,0);return C/(f+h-C)}function uz(r,t,e){let o=Math.exp(t*e*e);return e<=r?o:0}function XI(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}function cz(s,i,a){return M(this,arguments,function*(r,t,e,o=.5,n=Number.NEGATIVE_INFINITY){let l=N(r,"boxes","nonMaxSuppressionAsync"),u=N(t,"scores","nonMaxSuppressionAsync"),c=ao(l,u,e,o,n);e=c.maxOutputSize,o=c.iouThreshold,n=c.scoreThreshold;let p=yield Promise.all([l.data(),u.data()]),m=p[0],f=p[1],{selectedIndices:h}=bh(m,f,e,o,n);return l!==r&&l.dispose(),u!==t&&u.dispose(),$e(h,"int32")})}var YI=cz;function pz(r,t,e,o=.5,n=Number.NEGATIVE_INFINITY,s=0){let i=N(r,"boxes","nonMaxSuppression"),a=N(t,"scores","nonMaxSuppression"),l=ao(i,a,e,o,n,s);e=l.maxOutputSize,o=l.iouThreshold,n=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:o,scoreThreshold:n,softNmsSigma:s},p=T.runKernel(Zl,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var ZI=v({nonMaxSuppressionWithScore_:pz});function mz(i,a,l){return M(this,arguments,function*(r,t,e,o=.5,n=Number.NEGATIVE_INFINITY,s=0){let u=N(r,"boxes","nonMaxSuppressionAsync"),c=N(t,"scores","nonMaxSuppressionAsync"),p=ao(u,c,e,o,n,s);e=p.maxOutputSize,o=p.iouThreshold,n=p.scoreThreshold,s=p.softNmsSigma;let m=yield Promise.all([u.data(),c.data()]),f=m[0],h=m[1],{selectedIndices:d,selectedScores:g}=Ch(f,h,e,o,n,s);return u!==r&&u.dispose(),c!==t&&c.dispose(),{selectedIndices:$e(d,"int32"),selectedScores:$e(g)}})}var JI=mz;function fz(r,t,e,o=.5,n=Number.NEGATIVE_INFINITY,s=!1){let i=N(r,"boxes","nonMaxSuppression"),a=N(t,"scores","nonMaxSuppression"),l=ao(i,a,e,o,n,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,m={boxes:i,scores:a},f={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},h=T.runKernel(Yl,m,f);return{selectedIndices:h[0],validOutputs:h[1]}}var QI=v({nonMaxSuppressionPadded_:fz});function hz(i,a,l){return M(this,arguments,function*(r,t,e,o=.5,n=Number.NEGATIVE_INFINITY,s=!1){let u=N(r,"boxes","nonMaxSuppressionAsync"),c=N(t,"scores","nonMaxSuppressionAsync"),p=ao(u,c,e,o,n,null),m=p.maxOutputSize,f=p.iouThreshold,h=p.scoreThreshold,[d,g]=yield Promise.all([u.data(),c.data()]),{selectedIndices:x,validOutputs:b}=wh(d,g,m,f,h,s);return u!==r&&u.dispose(),c!==t&&c.dispose(),{selectedIndices:$e(x,"int32"),validOutputs:xt(b,"int32")}})}var tS=hz;function dz(r,t,e=!1,o=!1){let n=N(r,"images","resizeBilinear");k(n.rank===3||n.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${n.rank}.`),k(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),k(o===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=n,i=!1;n.rank===3&&(i=!0,s=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let[]=t,a={images:s},l={alignCorners:e,halfPixelCenters:o,size:t},u=T.runKernel(wi,a,l);return i?F(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Ih=v({resizeBilinear_:dz});function gz(r,t,e=!1,o=!1){let n=N(r,"images","resizeNearestNeighbor");k(n.rank===3||n.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${n.rank}.`),k(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),k(n.dtype==="float32"||n.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),k(o===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=n,i=!1;n.rank===3&&(i=!0,s=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let[]=t,a={images:s},l={alignCorners:e,halfPixelCenters:o,size:t},u=T.runKernel(bi,a,l);return i?F(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Sh=v({resizeNearestNeighbor_:gz});function xz(r,t="binary",e=!1,o=.5){let n=N(r,"image","threshold"),s=.2989,i=.587,a=.114,l=n.shape[0]*n.shape[1],u=R($e([o]),255),c,p,m,f;if(k(n.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${n.rank}.`),k(n.shape[2]===3||n.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${n.shape[2]}.`),k(n.dtype==="int32"||n.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${n.dtype}.`),k(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),n.shape[2]===3){[c,p,m]=Re(n,[1,1,1],-1);let g=R(c,s),x=R(p,i),b=R(m,a);f=X(X(g,x),b)}else f=r;if(t==="otsu"){let g=eI(Y(up(f),"int32"),Ar([]),256);u=yz(g,l)}let h=e?io(f,u):xe(f,u);return Y(R(h,255),"int32")}function yz(r,t){let e=$e([-1]),o=$e([0]),n=$e([0]),s,i,a,l,u,c;for(let p=0;p<r.size-1;p++){s=Rt(r,0,p+1),i=Rt(r,p+1),u=ot(it(s),t),c=ot(it(i),t);let m=it(R(s,ys(0,s.size)));a=ot(m,it(s));let f=fs(i.shape,s.size),h=X(ys(0,i.size),f),d=R(i,h);l=ot(it(d),it(i));let g=ct(a,l),x=ct(a,l),b=R(u,c);n=R(R(b,g),x);let C=xe(n,o);o=ne(C,n,o),e=ne(C,$e([p]),e)}return e}var eS=v({threshold_:xz});function bz(r,t,e="nearest",o="constant",n=0,s){let i=N(r,"image","transform","float32"),a=N(t,"transforms","transform","float32");k(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),k(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:a},u={interpolation:e,fillMode:o,fillValue:n,outputShape:s};return T.runKernel(su,l,u)}var rS=v({transform_:bz});function wz(r,t,e){k(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),k(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let o=N(r,"a","bandPart");k(o.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${o.rank}.`);let n=o.shape,[s,i]=o.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),e<0&&(e=i);let a=F(ys(0,s,1,"int32"),[-1,1]),l=ys(0,i,1,"int32"),u=ct(a,l),c=nr(io(u,xt(+t,"int32")),wr(u,xt(-e,"int32"))),p=re([s,i],o.dtype);return F(Fe(sr(F(o,[-1,s,i])).map(m=>ne(c,m,p))),n)}var oS=v({bandPart_:wz});function Cz(r){let t;if(Array.isArray(r)){t=!1,k(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let n=r[0].shape[0];for(let s=1;s<r.length;++s)k(r[s].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${n})`)}else t=!0,r=Re(r,r.shape[0],0).map(n=>Ao(n,[0]));k(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],o=r;for(let n=0;n<r.length;++n)e.push(T.tidy(()=>{let s=o[n];if(n>0)for(let i=0;i<n;++i){let a=R(it(R(e[i],s)),e[i]);s=ct(s,a)}return ot(s,Mi(s,"euclidean"))}));return t?Fe(e,0):e}var nS=v({gramSchmidt_:Cz});function Iz(r,t=!1){if(k(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return sS(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((l,u)=>l*u),o=sr(F(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),n=[],s=[];o.forEach(l=>{let[u,c]=sS(l,t);n.push(u),s.push(c)});let i=F(Fe(n,0),r.shape),a=F(Fe(s,0),r.shape);return[i,a]}}function sS(r,t=!1){return T.tidy(()=>{k(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],o=r.shape[1],n=Su(e),s=$r(r),i=yp([[1]],[1,1]),a=$r(i),l=e>=o?o:e;for(let u=0;u<l;++u){let c=s,p=a,m=n;[a,s,n]=T.tidy(()=>{let f=Rt(s,[u,u],[e-u,1]),h=Mi(f),d=Rt(s,[u,u],[1,1]),g=ne(xe(d,0),yp([[-1]]),yp([[1]])),x=ct(d,R(g,h)),b=ot(f,x);b.shape[0]===1?a=$r(i):a=te([i,Rt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let C=zt(ot(Pt(g,x),h)),w=Rt(s,[u,0],[e-u,o]),I=R(C,a),E=vt(a);if(u===0)s=ct(w,Pt(I,Pt(E,w)));else{let _=ct(w,Pt(I,Pt(E,w)));s=te([Rt(s,[0,0],[u,o]),_],0)}let A=vt(I),$=Rt(n,[0,u],[e,n.shape[1]-u]);if(u===0)n=ct($,Pt(Pt($,a),A));else{let _=ct($,Pt(Pt($,a),A));n=te([Rt(n,[0,0],[e,u]),_],1)}return[a,s,n]}),wt([c,p,m])}return!t&&e>o&&(n=Rt(n,[0,0],[e,o]),s=Rt(s,[0,0],[o,o])),[n,s]})}var iS=v({qr_:Iz});var Do={flipLeftRight:UI,grayscaleToRGB:HI,resizeNearestNeighbor:Sh,resizeBilinear:Ih,rotateWithOffset:KI,cropAndResize:WI,nonMaxSuppression:qI,nonMaxSuppressionAsync:YI,nonMaxSuppressionWithScore:ZI,nonMaxSuppressionWithScoreAsync:JI,nonMaxSuppressionPadded:QI,nonMaxSuppressionPaddedAsync:tS,threshold:eS,transform:rS},aS={bandPart:oS,gramSchmidt:nS,qr:iS};var H={};Jr(H,{Serializable:()=>wp,SerializationMap:()=>en,registerClass:()=>Sb});var wp=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},en=class{constructor(){this.classNameMap={}}static getMap(){return en.instance==null&&(en.instance=new en),en.instance}static register(t){en.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Sb(r){k(r.className!=null,()=>"Class being registered does not have the static className property defined."),k(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),k(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),en.register(r)}var Qe=class extends wp{minimize(t,e=!1,o){let{value:n,grads:s}=this.computeGradients(t,o);if(o!=null){let i=o.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return wt(s),e?n:(n.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return sb(t,e)}dispose(){this.iterations_!=null&&wt(this.iterations_)}saveIterations(){return M(this,null,function*(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:xt(this.iterations_,"int32")}})}getWeights(){return M(this,null,function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})}setWeights(t){return M(this,null,function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)})}extractIterations(t){return M(this,null,function*(){return this.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})}};Object.defineProperty(Qe,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var Fu=class extends Qe{constructor(t,e,o=null){super(),this.learningRate=t,this.rho=e,this.epsilon=o,this.accumulatedGrads=[],this.accumulatedUpdates=[],o==null&&(this.epsilon=T.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,n)=>{let s=T.registeredVariables[o],i=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${o}/accum_grad`,variable:z(()=>ht(s).variable(i))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${o}/accum_var`,variable:z(()=>ht(s).variable(i))});let a=Array.isArray(t)?t[n].tensor:t[o];if(a==null)return;let l=this.accumulatedGrads[n].variable,u=this.accumulatedUpdates[n].variable;z(()=>{let c=X(R(l,this.rho),R(At(a),1-this.rho)),p=R(ot(ee(X(u,this.epsilon)),ee(X(l,this.epsilon))),a),m=X(R(u,this.rho),R(At(p),1-this.rho));l.assign(c),u.assign(m);let f=X(R(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(wt(this.accumulatedGrads.map(t=>t.variable)),wt(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){return M(this,null,function*(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return M(this,null,function*(){t=yield this.extractIterations(t);let e=t.length/2,o=!1;this.accumulatedGrads=t.slice(0,e).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.accumulatedUpdates=t.slice(e,e*2).map(n=>({originalName:n.name,variable:n.tensor.variable(o)}))})}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};var _u=class extends Qe{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,n)=>{let s=T.registeredVariables[o];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${o}/accumulator`,variable:z(()=>fs(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[n].tensor:t[o];if(i==null)return;let a=this.accumulatedGrads[n].variable;z(()=>{let l=X(a,At(i));a.assign(l);let u=X(R(ot(i,ee(X(l,T.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&wt(this.accumulatedGrads.map(t=>t.variable))}getWeights(){return M(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return M(this,null,function*(){t=yield this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(o=>({originalName:o.name,variable:o.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};var Ou=class extends Qe{constructor(t,e,o,n=null){super(),this.learningRate=t,this.beta1=e,this.beta2=o,this.epsilon=n,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],z(()=>{this.accBeta1=xt(e).variable(),this.accBeta2=xt(o).variable()}),n==null&&(this.epsilon=T.backend.epsilon())}static get className(){return"Adam"}applyGradients(t){let e=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);z(()=>{let o=ct(1,this.accBeta1),n=ct(1,this.accBeta2);e.forEach((s,i)=>{let a=T.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:z(()=>ht(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:z(()=>ht(a).variable(l))});let u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,m=X(R(c,this.beta1),R(u,1-this.beta1)),f=X(R(p,this.beta2),R(At(u),1-this.beta2)),h=ot(m,o),d=ot(f,n);c.assign(m),p.assign(f);let g=X(R(ot(h,X(ee(d),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(R(this.accBeta1,this.beta1)),this.accBeta2.assign(R(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&wt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&wt(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){return M(this,null,function*(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return M(this,null,function*(){t=yield this.extractIterations(t),z(()=>{this.accBeta1.assign(so(this.beta1,this.iterations_+1)),this.accBeta2.assign(so(this.beta2,this.iterations_+1))});let e=t.length/2,o=!1;this.accumulatedFirstMoment=t.slice(0,e).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(n=>({originalName:n.name,variable:n.tensor.variable(o)}))})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};var Lu=class extends Qe{constructor(t,e,o,n=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=o,this.epsilon=n,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],z(()=>{this.iteration=xt(0).variable(),this.accBeta1=xt(e).variable()}),n==null&&(this.epsilon=T.backend.epsilon())}static get className(){return"Adamax"}applyGradients(t){let e=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);z(()=>{let o=ct(1,this.accBeta1),n=ot(-this.learningRate,X(R(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=T.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:ht(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:ht(a).variable(l)});let u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,m=X(R(c,this.beta1),R(u,1-this.beta1)),f=R(p,this.beta2),h=ve(u),d=Fr(f,h);c.assign(m),p.assign(d);let g=X(R(ot(n,o),ot(m,X(d,this.epsilon))),a);a.assign(g)}),this.iteration.assign(X(this.iteration,1)),this.accBeta1.assign(R(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&wt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&wt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return M(this,null,function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})}setWeights(t){return M(this,null,function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};var Vi=class extends Qe{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}static get className(){return"SGD"}applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,n)=>{let s=Array.isArray(t)?t[n].tensor:t[o];if(s==null)return;let i=T.registeredVariables[o];z(()=>{let a=X(R(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Oe(xt(-t))}dispose(){this.c.dispose()}getWeights(){return M(this,null,function*(){return[yield this.saveIterations()]})}setWeights(t){return M(this,null,function*(){if(t=yield this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")})}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};var Pu=class extends Vi{constructor(t,e,o=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=o,this.accumulations=[],this.m=xt(this.momentum)}static get className(){return"Momentum"}applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,n)=>{let s=T.registeredVariables[o];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${o}/momentum`,variable:z(()=>ht(s).variable(!1))});let i=this.accumulations[n].variable,a=Array.isArray(t)?t[n].tensor:t[o];a!=null&&z(()=>{let l,u=X(R(this.m,i),a);this.useNesterov?l=X(R(this.c,X(a,R(u,this.m))),s):l=X(R(this.c,u),s),i.assign(u),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&wt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){return M(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return M(this,null,function*(){t=yield this.extractIterations(t);let e=!1;this.accumulations=t.map(o=>({originalName:o.name,variable:o.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};var zu=class extends Qe{constructor(t,e=.9,o=0,n=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=o,this.epsilon=n,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,n==null&&(this.epsilon=T.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,n)=>{let s=T.registeredVariables[o],i=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${o}/rms`,variable:z(()=>ht(s).variable(i))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${o}/momentum`,variable:z(()=>ht(s).variable(i))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${o}/mg`,variable:z(()=>ht(s).variable(i))});let a=Array.isArray(t)?t[n].tensor:t[o];if(a==null)return;let l=this.accumulatedMeanSquares[n].variable,u=this.accumulatedMoments[n].variable;z(()=>{let c=X(R(l,this.decay),R(At(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[n].variable,m=X(R(p,this.decay),R(a,1-this.decay)),f=ot(R(a,this.learningRate),ee(ct(c,X(At(m),this.epsilon)))),h=X(R(u,this.momentum),f);l.assign(c),p.assign(m),u.assign(h);let d=ct(s,h);s.assign(d)}else{let p=X(R(l,this.decay),R(At(a),1-this.decay)),m=X(R(u,this.momentum),ot(R(a,this.learningRate),ee(X(p,this.epsilon))));l.assign(p),u.assign(m);let f=ct(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&wt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&wt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&wt(this.accumulatedMoments.map(t=>t.variable))}getWeights(){return M(this,null,function*(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return M(this,null,function*(){t=yield this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,o=!1;this.accumulatedMeanSquares=t.slice(0,e).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.accumulatedMoments=t.slice(e,e*2).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})))})}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};var Sz=[Fu,_u,Ou,Lu,Pu,zu,Vi];function lS(){for(let r of Sz)Sb(r)}var ws={};Jr(ws,{browserFiles:()=>cS,browserHTTPRequest:()=>fS,concatenateArrayBuffers:()=>hu,copyModel:()=>UC,decodeWeights:()=>Jf,encodeWeights:()=>EC,fromMemory:()=>hS,fromMemorySync:()=>Ab,getLoadHandlers:()=>_C,getModelArtifactsForJSON:()=>du,getModelArtifactsForJSONSync:()=>Sy,getModelArtifactsInfoForJSON:()=>Xo,getSaveHandlers:()=>FC,getWeightSpecs:()=>th,http:()=>Th,isHTTPScheme:()=>Nh,listModels:()=>GC,loadWeights:()=>pS,moveModel:()=>HC,registerLoadRouter:()=>RC,registerSaveRouter:()=>DC,removeModel:()=>WC,weightsLoaderFactory:()=>kb,withSaveHandler:()=>dS,withSaveHandlerSync:()=>gS});var Nz="model",Tz=".json",vz=".weights.bin";function uS(r){return new Promise(t=>setTimeout(t)).then(r)}var bs=class{constructor(t){if(!P().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(bs.URL_SCHEME)&&(t=t.slice(bs.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Nz),this.modelJsonFileName=t+Tz,this.weightDataFileName=t+vz}save(t){return M(this,null,function*(){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let o=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],n=Qf(t,o),s=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,yield uS(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=e,yield uS(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Xo(t)}}})}};bs.URL_SCHEME="downloads://";var Nb=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){return M(this,null,function*(){return new Promise((t,e)=>{let o=new FileReader;o.onload=n=>{let s=JSON.parse(n.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let l=du(s,u=>this.loadWeights(u));t(l)},o.onerror=n=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),o.readAsText(this.jsonFile)})})}loadWeights(t){let e=[],o=[];for(let i of t)e.push(...i.weights),o.push(...i.paths);let n=this.checkManifestAndWeightFiles(t),s=o.map(i=>this.loadWeightsFile(i,n[i]));return Promise.all(s).then(i=>[e,hu(i)])}loadWeightsFile(t,e){return new Promise((o,n)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;o(a)},s.onerror=i=>n(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],o=this.weightsFiles.map(s=>Iy(s.name)),n={};for(let s of t)s.paths.forEach(i=>{let a=Iy(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),o.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);n[i]=this.weightsFiles[o.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return n}},kz=r=>P().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(bs.URL_SCHEME)?Ez(r.slice(bs.URL_SCHEME.length)):null;Yt.registerSaveRouter(kz);function Ez(r="model"){return new bs(r)}function cS(r){return new Nb(r)}function Tb(r,t,e,o){i(r),e=e==null?0:e,o=o==null?1:o,a(e,o);let n=0,s=l=>(l.then(u=>{let c=e+ ++n/r.length*(o-e);return t(c),u}),l);function i(l){k(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){k(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),k(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),k(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(r.map(s))}function vb(r,t){return M(this,null,function*(){t==null&&(t={});let e=t.fetchFunc==null?P().platform.fetch:t.fetchFunc,o=r.map(p=>e(p,t.requestInit,{isBinary:!0})),n=0,s=.5,a=(t.onProgress==null?yield Promise.all(o):yield Tb(o,t.onProgress,n,s)).map(p=>p.arrayBuffer()),l=.5,u=1;return t.onProgress==null?yield Promise.all(a):yield Tb(a,t.onProgress,l,u)})}function pS(r,t="",e,o){return M(this,null,function*(){return kb(i=>vb(i,{requestInit:o}))(r,t,e)})}function kb(r){return(t,e="",o)=>M(this,null,function*(){let n=t.map(()=>!1),s={},i=o!=null?o.map(()=>!1):[],a=[];if(t.forEach((f,h)=>{let d=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,b=Yc[x]*Bt(g.shape),C=()=>{n[h]=!0,s[h]==null&&(s[h]=[]),s[h].push({manifestEntry:g,groupOffset:d,sizeBytes:b})};o!=null?o.forEach((w,I)=>{w===g.name&&(C(),i[I]=!0)}):C(),a.push(g.name),d+=b})}),!i.every(f=>f)){let f=o.filter((h,d)=>!i[d]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let l=n.reduce((f,h,d)=>(h&&f.push(d),f),[]),u=[];l.forEach(f=>{t[f].paths.forEach(h=>{let d=e+(e.endsWith("/")?"":"/")+h;u.push(d)})});let c=yield r(u),p={},m=0;return l.forEach(f=>{let h=t[f].paths.length,d=0;for(let w=0;w<h;w++)d+=c[m+w].byteLength;let g=new ArrayBuffer(d),x=new Uint8Array(g),b=0;for(let w=0;w<h;w++){let I=new Uint8Array(c[m+w]);x.set(I,b),b+=I.byteLength}s[f].forEach(w=>{let I=g.slice(w.groupOffset,w.groupOffset+w.sizeBytes),E=Jf(I,[w.manifestEntry]);for(let A in E)p[A]=E[A]}),m+=h}),p})}var Az="application/octet-stream",$z="application/json",Cp=class{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(k(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=P().platform.fetch,k(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&k(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}save(t){return M(this,null,function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],n=Qf(t,o);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:$z}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:Az}),"model.weights.bin");let s=yield this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:Xo(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)})}load(){return M(this,null,function*(){let t=yield this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=yield t.json()}catch(s){let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let o=e.modelTopology,n=e.weightsManifest;if(o==null&&n==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return du(e,s=>this.loadWeights(s))})}loadWeights(t){return M(this,null,function*(){let e=Array.isArray(this.path)?this.path[1]:this.path,[o,n]=Dz(e),s=this.weightPathPrefix||o,i=th(t),a=[],l=[];for(let c of t)for(let p of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(p)):a.push(s+p+n);this.weightUrlConverter&&a.push(...yield Promise.all(l));let u=yield vb(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,hu(u)]})}};Cp.URL_SCHEME_REGEX=/^https?:\/\//;function Dz(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),o=r.substring(0,t),n=e>t?r.substring(e):"";return[o+"/",n]}function Nh(r){return r.match(Cp.URL_SCHEME_REGEX)!=null}var mS=(r,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(o=>Nh(o)):e=Nh(r),e)return Th(r,t)}return null};Yt.registerSaveRouter(mS);Yt.registerLoadRouter(mS);function Th(r,t){return new Cp(r,t)}function fS(r,t){return Th(r,t)}var Ip=class{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}},vh=class{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}},Eb=class{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}};function hS(r,t,e,o){let n=arguments;return new Eb(Ab(...n))}function Ab(r,t,e,o){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new Ip(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ip({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ip({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:o}))}function dS(r){return new vh(r)}function gS(r){return new vh(r)}function Rz(r,t){let e=r.shape.length,o=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(o<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${o}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[o-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[o-1]} vs. ${e}`);if(Bt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let n=t.shape,s=n[n.length-1],i=1;for(let p=0;p<n.length-1;++p)i*=n[p];let a=r.shape,l=n.slice();l.pop();let u=1;for(let p=s;p<e;++p)u*=a[p],l.push(a[p]);let c=[...Wo(r.shape).map(p=>p/u),1].slice(0,s);return[l,i,u,c]}var Pe={};Jr(Pe,{assertParamsValid:()=>_z,computeFlatOffset:()=>Mz,computeOutShape:()=>Lz,getNormalizedAxes:()=>Pz,isSliceContinous:()=>zz,maskToAxes:()=>Oz,parseSliceParams:()=>Db,sliceInfo:()=>Bz,startForAxis:()=>NS,startIndicesWithElidedDims:()=>CS,stopForAxis:()=>TS,stopIndicesWithElidedDims:()=>IS,stridesForAxis:()=>SS,stridesWithElidedDims:()=>yS});var $b=-2,Fz=-1;function _z(r,t,e){let o=r.shape.length;k(o===t.length,()=>`Error in slice${o}D: Length of begin ${t} must match the rank of the array (${o}).`),k(o===e.length,()=>`Error in slice${o}D: Length of size ${e} must match the rank of the array (${o}).`);for(let n=0;n<o;++n)k(t[n]+e[n]<=r.shape[n],()=>`Error in slice${o}D: begin[${n}] + size[${n}] (${t[n]+e[n]}) would overflow input.shape[${n}] (${r.shape[n]})`)}function Oz(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function Lz(r,t,e){let o=[];for(let n=0;n<r.length;n++)o[n]=Math.ceil((t[n]-r[n])/e[n]);return o}function yS(r,t,e,o){let n=[...r];for(let s=n.length;s<o.length;s++)n.push(1);for(let s=0;s<e;s++)s===0?n[t]=1:(n.splice(t,0,1),n.pop());return n}function bS(r,t,e){return e<=r?e:e-(t-1)}function wS(r,t){let e=[];for(let o=0;o<r;o++)e.push(t+o);return e}function Pz(r,t,e,o,n,s,i,a,l){let u=r.length,c=new Array(u),p=new Array(u),m=new Array(u);if(t.length&&e>0){let f=t[0],h=e+1;c=CS(i,f,h,o,r),p=IS(a,f,h,n,r),m=yS(s,f,h,r)}else for(let f=0;f<u;f++)c[f]=NS(i,o,s,r,f,l),p[f]=TS(a,n,s,r,f,l),m[f]=SS(s,f,l);return{begin:c,end:p,strides:m}}function CS(r,t,e,o,n){let s=[...n],i=wS(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let l=bS(t,e,a),u=o[l];r&1<<l&&(u=0),s[a]=u}return s}function IS(r,t,e,o,n){let s=[...n],i=wS(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let l=bS(t,e,a),u=o[l];r&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[a]=u}for(let a=0;a<s.length;a++){let l=n[a];s[a]<0&&(s[a]+=l),s[a]=xl(0,s[a],n[a])}return s}function SS(r,t,e){let o=r[t];return(e&1<<t||o==null)&&(o=1),o}function NS(r,t,e,o,n,s){let i=t[n],a=e[n]||1;(r&1<<n||s&1<<n||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=o[n];return i<0&&(i+=l),i=xl(0,i,l-1),i}function TS(r,t,e,o,n,s){let i=t[n],a=e[n]||1;(r&1<<n||s&1<<n||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=o[n];return i<0&&(i+=l),a>0?i=xl(0,i,l):i=xl(-1,i,l-1),i}function zz(r,t,e){let o=e.length;for(let n=0;n<e.length;n++)if(e[n]>1){o=n;break}for(let n=o+1;n<e.length;n++)if(t[n]>0||e[n]!==r[n])return!1;return!0}function Mz(r,t){let e=r.length>0?r[r.length-1]:1;for(let o=0;o<r.length-1;o++)e+=r[o]*t[o];return e}function Db(r,t,e){let o,n=r.shape.length;typeof t=="number"?o=[t,...new Array(n-1).fill(0)]:t.length<n?o=t.concat(new Array(n-t.length).fill(0)):o=t.slice(),o.forEach(i=>{k(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(n).fill(-1):typeof e=="number"?s=[e,...new Array(n-1).fill(-1)]:e.length<n?s=e.concat(new Array(n-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(k(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-o[a])),[o,s]}function Bz(r,t,e,o,n,s,i,a,l){let u;if(o==null?(u=new Array(t.length),u.fill(1)):u=o,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:n,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let C=0;C<p.dims;C++)c&&(1<<C&a)!==0&&p.numAddAxisAfterEllipsis++,1<<C&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let m={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Vz(p,m);let f=!0,h=!0,d=!0,g=[],x=[];for(let C=0;C<r.length;++C){if(m.strides[C]===0)throw Error(`strides[${C}] must be non-zero`);let w=!!(m.shrinkAxisMask&1<<C),I=r[C];if(I===-1){g.push(w?1:-1);continue}let E=[m.beginMask&1<<C,m.endMask&1<<C],A=[m.strides[C]>0?0:-1,m.strides[C]>0?I:I-1];if(w&&m.strides[C]<=0)throw Error("only stride 1 allowed on non-range indexing.");d=d&&m.strides[C]===1;let $=!!(m.beginMask&1<<C&&m.endMask&1<<C);if(m.beginValid&&m.endValid){if(w){let V=m.begin[C]<0?I+m.begin[C]:m.begin[C];if(m.begin[C]=V,m.end[C]=m.begin[C]+1,V<0||V>=I)throw Error(`slice index ${m.begin[C]} of dimension ${C} out of bounds.`)}else m.begin[C]=xS(m.begin[C],0,m.strides[C],I,E,A),m.end[C]=xS(m.end[C],1,m.strides[C],I,E,A);let B=m.strides[C]===1&&m.begin[C]===0&&m.end[C]===I;f=f&&B,h=h&&(C===0&&m.strides[C]===1||B)}else f=f&&m.strides[C]===1&&$,h=h&&(C===0&&m.strides[C]===1||$);let _,L=!1;if(m.beginValid&&m.endValid?(_=m.end[C]-m.begin[C],L=!0):w?(_=1,L=!0):$&&I>=0&&(m.strides[C]<0?_=-I:_=I,L=!0),L){let B;_===0||_<0!=m.strides[C]<0?B=0:B=Math.trunc(_/m.strides[C])+(_%m.strides[C]!==0?1:0),g.push(B)}else g.push(-1)}for(let C=0;C<m.finalShapeGatherIndices.length;++C){let w=m.finalShapeGatherIndices[C];w>=0?x.push(g[w]):w===$b&&x.push(1)}return{finalShapeSparse:x.filter((C,w)=>m.finalShapeGatherIndices[w]!==$b),finalShape:x,isIdentity:f,sliceDim0:h,isSimpleSlice:d,begin:m.begin,end:m.end,strides:m.strides}}function Vz(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let o=0;o<r.dims;o++)if(1<<o&r.ellipsisMask){let n=Math.min(t.dims-(r.dims-o)+1+r.numAddAxisAfterEllipsis,t.dims);for(;e<n;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=o}else if(1<<o&r.newAxisMask)t.finalShapeGatherIndices.push($b),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[e]=r.begin[o]),r.end!=null&&(t.end[e]=r.end[o]),t.strides[e]=r.strides[o],r.beginMask&1<<o&&(t.beginMask|=1<<e),r.endMask&1<<o&&(t.endMask|=1<<e),r.shrinkAxisMask&1<<o?(t.finalShapeGatherIndices.push(Fz),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(o)),t.inputShapeGatherIndicesSparse[e]=o,e++}}function xS(r,t,e,o,n,s){if(n[t])return e>0?s[t]:s[t+1&1];{let i=r<0?o+r:r;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var kh=class{static sgd(t){return new Vi(t)}static momentum(t,e,o=!1){return new Pu(t,e,o)}static rmsprop(t,e=.9,o=0,n=null,s=!1){return new zu(t,e,o,n,s)}static adam(t=.001,e=.9,o=.999,n=null){return new Ou(t,e,o,n)}static adadelta(t=.001,e=.95,o=null){return new Fu(t,e,o)}static adamax(t=.002,e=.9,o=.999,n=null,s=0){return new Lu(t,e,o,n,s)}static adagrad(t,e=.1){return new _u(t,e)}};var Ua=kh;var Gz=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function Sp(){return new Promise(r=>Gz(()=>r()))}var S={};Jr(S,{ERF_A1:()=>o3,ERF_A2:()=>n3,ERF_A3:()=>s3,ERF_A4:()=>i3,ERF_A5:()=>a3,ERF_P:()=>r3,PARALLELIZE_THRESHOLD:()=>Eh,RowPartitionType:()=>rn,SELU_SCALE:()=>Fb,SELU_SCALEALPHA:()=>Rb,applyActivation:()=>Va,assertAndGetBroadcastShape:()=>Nt,assertAxesAreInnerMostDims:()=>tL,assertParamsConsistent:()=>Wz,assignToTypedArray:()=>f3,axesAreInnerMostDims:()=>Zy,calculateShapes:()=>KP,checkEinsumDimSizes:()=>b3,checkPadOnDimRoundingMode:()=>Zt,combineLocations:()=>aI,combineRaggedTensorToTensorShapes:()=>Hz,complexWithEvenIndex:()=>c3,complexWithOddIndex:()=>p3,computeConv2DInfo:()=>ka,computeConv3DInfo:()=>JC,computeDefaultPad:()=>zy,computeDilation2DInfo:()=>sO,computeOptimalWindowSize:()=>Xz,computeOutAndReduceShapes:()=>Jy,computeOutShape:()=>Uz,computePool2DInfo:()=>Py,computePool3DInfo:()=>iO,convertConv2DDataFormat:()=>QC,decodeEinsumEquation:()=>x3,eitherStridesOrDilationsAreOne:()=>Ue,expandShapeToKeepDim:()=>Qo,exponent:()=>d3,exponents:()=>h3,fromStringArrayToUint8:()=>B3,fromUint8ToStringArray:()=>M3,getAxesPermutation:()=>Qy,getBroadcastDims:()=>nI,getComplexWithIndex:()=>m3,getEinsumComputePath:()=>w3,getEinsumPermutation:()=>y3,getFusedBiasGradient:()=>Ba,getFusedDyActivation:()=>Ma,getImageCenter:()=>Yz,getInnerMostAxes:()=>eL,getPermuted:()=>Jz,getRaggedRank:()=>qz,getReductionAxes:()=>Ht,getReshaped:()=>Zz,getReshapedPermuted:()=>Qz,getRowPartitionTypesHelper:()=>Kz,getSliceBeginCoords:()=>t3,getSliceSize:()=>e3,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>N3,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>T3,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>v3,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>A3,getSparseReshapeInputOutputMismatchErrorMessage:()=>D3,getSparseReshapeInputOutputMultipleErrorMessage:()=>$3,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>k3,getSparseReshapeNegativeOutputDimErrorMessage:()=>E3,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>O3,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>R3,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>F3,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>_3,getUndoAxesPermutation:()=>sp,isIdentityPermutation:()=>C3,log:()=>t_,mergeRealAndImagArrays:()=>l3,prepareAndValidate:()=>Rz,prepareSplitSize:()=>S3,segment_util:()=>Ob,shouldFuse:()=>Ga,slice_util:()=>Pe,splitRealAndImagArrays:()=>u3,stridesOrDilationsArePositive:()=>Jo,tupleValuesAreOne:()=>Ur,upcastType:()=>Te,validateDefaultValueShape:()=>jz,validateInput:()=>HP,validateUpdateShape:()=>PI,warn:()=>jo});function Wz(r,t){let e=r[0].length;r.forEach((n,s)=>{k(n.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),k(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let o=r[0];r.forEach((n,s)=>{for(let i=0;i<e;i++)k(i===t||n[i]===o[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${n}) does not match the shape of the rest (${o}) along the non-concatenated axis ${s}.`)})}function Uz(r,t){let e=r[0].slice();for(let o=1;o<r.length;o++)e[t]+=r[o][t];return e}var rn;(function(r){r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS"})(rn||(rn={}));function Hz(r,t,e){let o=new Array;if(e==null&&t==null)return o;if(t==null)for(;o.length<r+e.length;)o.push(-1);else o=t.slice();if(e==null)return o;if(r+e.length!==o.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${r+e.length}, but shape.rank = ${o.length}`);for(let n=1;n<e.length;++n){let s=e[n],i=o[o.length-e.length+n],a=o[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${n+r}] = ${s} but shape[${n+r}] = ${a}`)}else o[i]=s}return o}function Kz(r){let t={FIRST_DIM_SIZE:rn.FIRST_DIM_SIZE,VALUE_ROWIDS:rn.VALUE_ROWIDS,ROW_LENGTHS:rn.ROW_LENGTHS,ROW_SPLITS:rn.ROW_SPLITS,ROW_LIMITS:rn.ROW_LIMITS,ROW_STARTS:rn.ROW_STARTS},e=[];for(let o of r)if(o in t)e.push(t[o]);else break;return e}function qz(r){return r.length===0?0:r[0]===rn.FIRST_DIM_SIZE?r.length-1:r.length}function jz(r,t){if(r==null||t==null)return;let e=r.length,o=t.length;if(e>=o)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${o})`);for(let n=0;n<Math.min(e,o-1);++n){let s=r[n],i=t[n+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${n-r.length}] = ${s} but ragged tensor input.flatValues.shape[${n-r.length}] = ${i}`)}}var Eh=30;function Xz(r){return r<=Eh?r:Il(r,Math.floor(Math.sqrt(r)))}function Yz(r,t,e){let o=e*(typeof r=="number"?r:r[0]),n=t*(typeof r=="number"?r:r[1]);return[o,n]}function Zz(r,t,e,o=!0){let n=[];if(o)n=n.concat(t.slice(0)),n.push(r[0]/e),n=n.concat(r.slice(1));else{n=n.concat(r[0]);let s=t.length;for(let i=0;i<s;++i)n=n.concat([r[i+1]/t[i],t[i]]);n=n.concat(r.slice(s+1))}return n}function Jz(r,t,e=!0){let o=[];if(e){o.push(t);for(let n=t+1;n<r;++n)n<=2*t?(o.push(n),o.push(n-(t+1))):o.push(n)}else{let n=[],s=[];for(let i=1;i<r;++i)i>=t*2+1||i%2===1?s.push(i):n.push(i);o.push(...n),o.push(0),o.push(...s)}return o}function Qz(r,t,e,o=!0){let n=[];o?n.push(r[0]/e):n.push(r[0]*e);for(let s=1;s<r.length;++s)s<=t.length?o?n.push(t[s-1]*r[s]):n.push(r[s]/t[s-1]):n.push(r[s]);return n}function t3(r,t){let e=[0];for(let o=0;o<t;++o)e.push(r[o][0]);return e}function e3(r,t,e){let o=r.slice(0,1);for(let n=0;n<e;++n)o.push(r[n+1]-t[n][0]-t[n][1]);return o}var Rb=1.7580993408473768,Fb=1.0507009873554805;var r3=.3275911,o3=.254829592,n3=-.284496736,s3=1.421413741,i3=-1.453152027,a3=1.061405429;function l3(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let o=0;o<e.length;o+=2)e[o]=r[o/2],e[o+1]=t[o/2];return e}function u3(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let o=0;o<r.length;o+=2)t[o/2]=r[o],e[o/2]=r[o+1];return{real:t,imag:e}}function c3(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),o=new Float32Array(t);for(let n=0;n<r.length;n+=4)e[Math.floor(n/4)]=r[n],o[Math.floor(n/4)]=r[n+1];return{real:e,imag:o}}function p3(r){let t=Math.floor(r.length/4),e=new Float32Array(t),o=new Float32Array(t);for(let n=2;n<r.length;n+=4)e[Math.floor(n/4)]=r[n],o[Math.floor(n/4)]=r[n+1];return{real:e,imag:o}}function m3(r,t){let e=r[t*2],o=r[t*2+1];return{real:e,imag:o}}function f3(r,t,e,o){r[o*2]=t,r[o*2+1]=e}function h3(r,t){let e=new Float32Array(r/2),o=new Float32Array(r/2);for(let n=0;n<Math.ceil(r/2);n++){let s=(t?2:-2)*Math.PI*(n/r);e[n]=Math.cos(s),o[n]=Math.sin(s)}return{real:e,imag:o}}function d3(r,t,e){let o=(e?2:-2)*Math.PI*(r/t),n=Math.cos(o),s=Math.sin(o);return{real:n,imag:s}}var _b="->",g3=/->/g,vS=",",kS="...";function x3(r,t){r=r.replace(/\s/g,"");let e=(r.length-r.replace(g3,"").length)/_b.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${_b}").`);let[o,n]=r.split(_b);k(o.indexOf(kS)===-1,()=>`The ellipsis notation ("${kS}") is not supported yet.`);let s=o.split(vS),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let m=0;m<n.length;++m){let f=n[m];if(!s.some(h=>h.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let m=0;m<o.length;++m){let f=o[m];a.indexOf(f)===-1&&f!==vS&&a.push(f)}let l=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);l[m]=[];for(let f=0;f<s[m].length;++f)l[m].push(a.indexOf(s[m][f]))}let u=a.length,c=n.length,p=[];for(let m=c;m<u;++m)p.push(m);return{allDims:a,summedDims:p,idDims:l}}function y3(r,t){let e=new Array(r);e.fill(-1);for(let n=0;n<t.length;++n)e[t[n]]=n;let o=[];for(let n=0;n<r;++n)e[n]===-1&&o.push(n);return e=e.filter(n=>n!==-1),{permutationIndices:e,expandDims:o}}function b3(r,t,e){let o=new Array(r);for(let n=0;n<e.length;++n){let s=e[n].shape;for(let i=0;i<t[n].length;++i)o[t[n][i]]===void 0?o[t[n][i]]=s[i]:k(o[t[n][i]]===s[i],()=>`Expected dimension ${o[t[n][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function w3(r,t){let e=r,o=[],n=0;r.length===0&&e.push(-1),n=r.length+1;for(let i=0;i<n;++i)o.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],l=I3(t,a);for(let u of l)s.indexOf(u)===-1&&(o[i].push(u),s.push(u))}return{path:e,steps:o}}function C3(r){return r.every((t,e)=>t===e)}function I3(r,t){let e=[];for(let o=0;o<r.length;++o)(r[o].length===0||r[o].indexOf(t)!==-1||t===-1)&&e.push(o);return e}function S3(r,t,e=0){let o=[];if(typeof t=="number")k(r.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),o=new Array(t).fill(r.shape[e]/t);else{let n=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);k(n<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,l)=>l>0?a+l:a);t[s]=r.shape[e]-i}k(r.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),o=t}return o}function N3(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function T3(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function v3(r,t,e){return`indices(${r}, 0) is invalid: ${t} >= ${e}`}function k3(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function E3(r,t){return`size ${r} must be non-negative, not ${t}`}function A3(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function $3(r,t){let e=Bt(r),o=Bt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${o}. inputShape=${r} outputShape= ${t}`}function D3(r,t){let e=Bt(r),o=Bt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${o}. inputShape=${r} outputShape=${t}`}function R3(){return"segment ids must be >= 0"}function F3(){return"segment ids are not increasing"}function _3(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function O3(r,t,e){return`Bad: indices[${r}] == ${t} out of range [0, ${e})`}var Ob={};Jr(Ob,{collectGatherOpShapeInfo:()=>z3,computeOutShape:()=>P3,segOpComputeOptimalWindowSize:()=>L3});function L3(r,t){let e=!1,o;for(r<=Eh?(o=r,e=!0):o=Il(r,Math.floor(Math.sqrt(r)));!e;)o>t||o===r?e=!0:o=Il(r,o+1);return o}function P3(r,t,e){let o=[],n=r.length;for(let s=0;s<n;s++)s!==t?o.push(r[s]):o.push(e);return o}function z3(r,t,e,o){let n=t.shape.length,s=r.shape.length;if(o!==0&&(o<-n||o>n))throw new Error(`Expect batchDims in the range of [-${n}, ${n}], but got ${o}`);if(o<0&&(o+=n),o>s)throw new Error(`batchDims (${o}) must be less than rank(x) (
    ${s}).`);if(e<o)throw new Error(`batchDims (${o}) must be less than or equal to axis (${e}).`);for(let p=0;p<o;++p)if(r.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=r.shape[e],a=[],l=1,u=1,c=1;for(let p=0;p<o;++p)a.push(r.shape[p]),l*=r.shape[p];for(let p=o;p<e;p++)a.push(r.shape[p]),u*=r.shape[p];for(let p=o;p<n;p++)a.push(t.shape[p]);for(let p=e+1;p<s;p++)a.push(r.shape[p]),c*=r.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function M3(r){try{return r.map(t=>mu(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function B3(r){return r.map(t=>pu(t))}var tr={};Jr(tr,{nonMaxSuppressionV3Impl:()=>bh,nonMaxSuppressionV4Impl:()=>wh,nonMaxSuppressionV5Impl:()=>Ch,whereImpl:()=>LI});lS();var Ah={kernelName:Ms,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,$o(Y(e,"float32"),-1))}}};var ES={kernelName:xn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let o=At(Y(e,"float32")),n=ee(ct(xt(1),o));return zt(ot(r,n))}}}};var AS={kernelName:yn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let o=ee(ct(At(Y(e,"float32")),1));return ot(r,o)}}}};var $S={kernelName:vo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=Nt(e.shape,o.shape);return{a:()=>{let a=r,l=Ht(e.shape,n);return l.length>0&&(a=it(a,l)),F(a,e.shape)},b:()=>{let a=r,l=Ht(o.shape,n);return l.length>0&&(a=it(a,l)),F(a,o.shape)}}}};var DS={kernelName:Nl,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((o,n)=>{e[n]=()=>r.clone()}),e}};var RS={kernelName:Bs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ht(e)}}};var FS={kernelName:Vs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ht(e)}}};var _S={kernelName:bn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,ee(ct(xt(1),At(Y(e,"float32")))))}}};var OS={kernelName:wn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let o=ee(X(xt(1),At(Y(e,"float32"))));return ot(r,o)}}}};var LS={kernelName:Sn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=Nt(e.shape,o.shape);return{a:()=>{let a=X(At(e),At(o)),l=R(r,ot(o,a)),u=Ht(e.shape,n);return u.length>0&&(l=it(l,u)),F(l,e.shape)},b:()=>{let a=X(At(e),At(o)),l=zt(R(r,ot(e,a))),u=Ht(o.shape,n);return u.length>0&&(l=it(l,u)),F(l,o.shape)}}}};var PS={kernelName:Cn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,X(At(Y(e,"float32")),1))}}};var zS={kernelName:In,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,ct(xt(1),At(Y(e,"float32"))))}}};function V3(r,t,e,o,n,s){let i=N(r,"dy","avgPool3dGrad"),a=N(t,"input","avgPool3dGrad"),l=i,u=a,c=!1;a.rank===4&&(c=!0,l=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),k(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),k(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Zt("avgPool3dGrad",n,s);let p={dy:l,input:u},m={filterSize:e,strides:o,pad:n,dimRoundingMode:s},f=T.runKernel(El,p,m);return c?F(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var MS=v({avgPool3dGrad_:V3});var BS={kernelName:Ws,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{filterSize:n,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>MS(r,o,n,s,i,a)}}};function G3(r,t,e,o,n){let s=N(r,"dy","avgPoolGrad"),i=N(t,"input","avgPoolGrad");k(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,l=s,u=!1;i.rank===3&&(u=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),k(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:l,input:a},p={filterSize:e,strides:o,pad:n},m=T.runKernel(kl,c,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var VS=v({avgPoolGrad_:G3});var GS={kernelName:Gs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{filterSize:n,strides:s,pad:i}=e;return{x:()=>VS(r,o,n,s,i)}}};var WS={kernelName:Us,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[o,n]=t,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>Pt(r,n,!1,!0),b:()=>Pt(o,r,!0,!1)}:!s&&i?{a:()=>Pt(r,n,!1,!1),b:()=>Pt(r,o,!0,!1)}:s&&!i?{a:()=>Pt(n,r,!1,!0),b:()=>Pt(o,r,!1,!1)}:{a:()=>Pt(n,r,!0,!0),b:()=>Pt(r,o,!0,!0)}}};var US={kernelName:Hs,gradFunc:(r,t,e)=>{let{blockShape:o,crops:n}=e;return{x:()=>Eu(r,o,n)}}};var HS={kernelName:Y0,gradFunc:(r,t,e)=>{let o=e,n=o.inputShape,s=o.shape,i=Array.from(s);for(let l=n.length-1;l>=0;l--)if(n[l]===s[l])i[l]=1;else if(n[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${s}].`);let a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>it(r,a,!0)}}};var KS={kernelName:Uo,gradFunc:r=>({x:()=>r.clone()})};var qS={kernelName:Nn,gradFunc:r=>({x:()=>ht(r)})};var jS={kernelName:Tn,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{clipValueMin:n,clipValueMax:s}=e;return{x:()=>ne(nr(wr(o,n),io(o,s)),r,ht(r))}}};var XS={kernelName:Ks,inputsToSave:["x"],gradFunc:Ah.gradFunc};var YS={kernelName:qs,saveAllInputs:!0,gradFunc:(r,t,e)=>{let o=t.map(l=>l.shape),{axis:n}=e,s=Ee(n,t[0].shape)[0],i=o.map(l=>l[s]);return Re(r,i,s).map(l=>()=>l)}};var ZS={kernelName:js,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[o,n]=t,{dilations:s,strides:i,pad:a,dataFormat:l}=e;return k(Ur(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>Iu(o.shape,r,n,i,a,l),filter:()=>Ru(o,r,n.shape,i,a,l)}}};var JS={kernelName:Xs,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[o,n]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Dr(r,n,s,i,a,1,l),filter:()=>Ru(r,o,n.shape,s,i,a,l)}}};function W3(r,t,e,o,n){let s=r;r.rank===4&&(s=F(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let i=t;i.rank===4&&(i=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),k(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),k(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),k(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),k(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),k(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},l={strides:o,pad:n,filterShape:e};return T.runKernel(Rl,a,l)}var QS=v({conv3DBackpropFilter_:W3});var tN={kernelName:Ys,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:o,strides:n,pad:s}=e;k(Ur(o),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);let[i,a]=t;return{x:()=>ih(i.shape,r,a,n,s),filter:()=>QS(i,r,a.shape,n,s)}}};var eN={kernelName:vn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(zt(fp(Y(e,"float32"))),r)}}};var rN={kernelName:kn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(hp(Y(e,"float32")),r)}}};var oN={kernelName:Zs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{axis:n,exclusive:s,reverse:i}=e;return{x:()=>{let a=Qy([n],o.rank),l=ah(r,n,s,!i);return a!=null&&(l=vt(l,a)),l}}}};var nN={kernelName:Js,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:o,strides:n,pad:s,dimRoundingMode:i}=e,a=o==null?[1,1]:o;k(Ur(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[l,u]=t;return k(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),k(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),k(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),k(Ue(n,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${n} and dilations '${a}'.`),Zt("depthwiseConv2d",s,i),{x:()=>yh(l.shape,r,u,n,s,a,i),filter:()=>xh(l,r,u.shape,n,s,a,i)}}};var sN={kernelName:Qs,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[o,n]=t,s={x:o,filter:n,dy:r},i={x:o,filter:n,dy:r};return{x:()=>T.runKernel(Wc,s,e),filter:()=>T.runKernel(Uc,i,e)}}};var iN={kernelName:An,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,o={dy:r,y:e};return{x:()=>T.runKernel(Bl,o)}}};var aN={kernelName:$n,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,o=R(Ze(zt(At(e))),2/Math.sqrt(Math.PI));return{x:()=>R(r,o)}}};var lN={kernelName:Dn,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,e)}}};var uN={kernelName:ti,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>F(r,e.shape)}}};var cN={kernelName:Rn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,Ze(e))}}};var pN={kernelName:Fn,gradFunc:r=>({x:()=>ht(r)})};var mN={kernelName:_n,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=Nt(e.shape,o.shape);return{a:()=>{let a=ot(r,Y(o,"float32")),l=Ht(e.shape,n);return l.length>0?F(it(a,l),e.shape):a},b:()=>{let a=R(r,Y(e,"float32")),l=Ht(o.shape,n);l.length>0&&(a=F(it(a,l),o.shape));let u=At(o);return zt(ot(a,Y(u,"float32")))}}}};var fN={kernelName:ei,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:o}=e,[n,s,i,a]=t,l=a==null?xt(1):a,u=Ht(s.shape,n.shape),c=[];if(s.rank===1){for(let w=0;w<n.shape.length-1;++w)c.push(n.shape[w]);c.push(1)}let p=ct(n,s),m=R(r,l),f=cp(X(i,xt(o))),h=R(R(R(f,f),f),xt(-.5));return{x:()=>s.rank===1?F(R(R(r,Je(F(f,[1,1,1,s.shape[0]]),c)),l),n.shape):F(R(R(r,f),l),n.shape),mean:()=>{let w=R(R(f,xt(-1)),m);return s.rank===1&&(w=it(w,u)),F(w,s.shape)},variance:()=>{let w=R(R(h,p),m);return s.rank===1&&(w=it(w,u)),F(w,s.shape)},scale:()=>{let w=R(p,f),I=R(r,w);return s.rank===1&&(I=it(I,u)),F(I,s.shape)},offset:()=>{let w=r;return s.rank===1&&(w=it(w,u)),F(w,s.shape)}}}};var gN={kernelName:ri,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[o,n]=t,{axis:s}=e,i=Ee(s,o.shape)[0];return{x:()=>{let l=o.shape,u=n.size,c=l.slice(0,i),p=c.length,m=l.slice(s,l.length).slice(1),f=m.length,h=hN(0,p),d=hN(p+1,p+1+f),g=dN([c,[u],m]),x=F(r,g),b=F(n,[u]),C=dN([[p],h,d]),w=vt(x,C),I=gh(w,b,o.shape[i]),E=sp(C);return I=vt(I,E),I},indices:()=>n}}};function hN(r,t){let e=[];for(let o=r;o<t;++o)e.push(o);return e}function dN(r){let t=[];for(let e=0;e<r.length;++e)for(let o=0;o<r[e].length;++o)t.push(r[e][o]);return t}var xN={kernelName:On,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t;return{a:()=>ht(e),b:()=>ht(o)}}};var yN={kernelName:Ho,gradFunc:r=>({x:()=>Y(r,"float32")})};var bN={kernelName:Ln,gradFunc:r=>({x:()=>ht(r)})};var wN={kernelName:Pn,gradFunc:r=>({x:()=>ht(r)})};var CN={kernelName:zn,gradFunc:r=>({x:()=>ht(r)})};var IN={kernelName:oi,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{alpha:n}=e,s=xe(o,0);return{x:()=>ne(s,r,R(r,n))}}};var SN={kernelName:Bn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,X(e,1))}}};var NN={kernelName:Mn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,Y(e,"float32"))}}};var TN={kernelName:Z0,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[o]=t,{axis:n}=e;return{logits:()=>{let i=Ze(o);return ct(r,R(it(r,n,!0),i))}}}};function U3(r,t,e,o=5,n=1,s=1,i=.5){let a={x:r,y:t,dy:e},l={depthRadius:o,bias:n,alpha:s,beta:i};return T.runKernel(Kl,a,l)}var vN=v({localResponseNormalizationBackprop_:U3});var kN={kernelName:ni,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[o,n]=t,{depthRadius:s,bias:i,alpha:a,beta:l}=e;return{x:()=>vN(o,n,r,s,i,a,l)}}};function $h(r,t,e,o){return t.rank<e.rank&&(t=F(t,Qo(t.shape,o))),r.rank<e.rank&&(r=F(r,Qo(r.shape,o))),{x:()=>R(r,Y(pr(e,t),r.dtype))}}var Lb={kernelName:si,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let o=e,{reductionIndices:n}=o,s=t[0],i=t[1],a=Ee(n,s.shape),l=$h(r,i,s,a);return{x:()=>l.x()}}};var EN={kernelName:Vn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t;return{a:()=>R(r,Y(wr(e,o),"float32")),b:()=>R(r,Y(uh(e,o),"float32"))}}};function H3(r,t,e,o,n,s,i){let a=N(r,"dy","maxPool3dGrad"),l=N(t,"input","maxPool3dGrad"),u=N(e,"output","maxPool3dGrad"),c=a,p=l,m=u,f=!1;l.rank===4&&(f=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=F(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=F(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),k(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),k(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),k(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Zt("maxPool3dGrad",s,i);let h={dy:c,input:p,output:m},d={filterSize:o,strides:n,pad:s,dimRoundingMode:i},g=T.runKernel(jl,h,d);return f?F(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var AN=v({maxPool3dGrad_:H3});var $N={kernelName:ai,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[o,n]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>AN(r,o,n,s,i,a,l)}}};function K3(r,t,e,o,n,s,i){let a=N(r,"dy","maxPoolGrad"),l=N(t,"input","maxPoolGrad"),u=N(e,"output","maxPoolGrad");k(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),k(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),k(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Zt("maxPoolGrad",s,i);let c={dy:a,input:l,output:u},p={filterSize:o,strides:n,pad:s,dimRoundingMode:i};return T.runKernel(ql,c,p)}var DN=v({maxPoolGrad_:K3});var RN={kernelName:ii,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[o,n]=t,{filterSize:s,strides:i,pad:a}=e;return{x:()=>DN(r,o,n,s,i,a)}}};var FN={kernelName:li,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{axis:n}=e,s=Ee(n,o.shape),a=Jy(o.shape,s)[1],l=Bt(a);return{x:()=>{let c=o.shape.slice();s.forEach(f=>{c[f]=1});let p=F(r,c);return ot(R(p,_r(o.shape,"float32")),l)}}}};var _N={kernelName:ui,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let o=e,{axis:n}=o,[s,i]=t,a=Ee(n,s.shape),l=$h(r,i,s,a);return{x:()=>l.x()}}};var ON={kernelName:Gn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t;return{a:()=>R(r,Y(io(e,o),"float32")),b:()=>R(r,Y(xe(e,o),"float32"))}}};var LN={kernelName:ci,inputsToSave:["x"],gradFunc:(r,t,e)=>{let o=t[0],{paddings:n}=e,s=n.map(i=>i[0]);return{x:()=>Rt(r,s,o.shape)}}};var PN={kernelName:Wn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=Nt(e.shape,o.shape);return{a:()=>{let a=Ht(e.shape,n);return a.length>0?F(it(r,a),e.shape):r},b:()=>{let a=R(r,zt(gs(ot(e,o)))),l=Ht(o.shape,n);return l.length>0?F(it(a,l),o.shape):a}}}};var zN={kernelName:Un,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=Nt(e.shape,o.shape);return{a:()=>{let a=R(r,Y(o,"float32")),l=Ht(e.shape,n);return l.length>0?F(it(a,l),e.shape):a},b:()=>{let a=R(r,Y(e,"float32")),l=Ht(o.shape,n);return l.length>0?F(it(a,l),o.shape):a}}}};var MN={kernelName:pi,gradFunc:r=>({x:()=>zt(r)})};var BN={kernelName:fi,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>re(e.shape,"float32")}}};var VN={kernelName:mi,gradFunc:r=>({x:()=>ht(r)})};var GN={kernelName:hi,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:o}=e;return sr(r,o).map(s=>()=>s)}};var Pb={kernelName:di,inputsToSave:["x"],gradFunc:(r,t,e)=>{let o=t[0],{paddings:n}=e,s=n.map(i=>i[0]);return{x:()=>Rt(r,s,o.shape)}}};var WN={kernelName:Hn,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,o,n]=t,s=e,i=o,a=Nt(s.shape,i.shape);return{a:()=>{let c=Y(i,"float32"),p=R(r,R(c,so(s,ct(c,xt(1))))),m=Ht(s.shape,a);return m.length>0&&(p=it(p,m)),F(p,s.shape)},b:()=>{let c=xe(s,0),p=ne(c,mr(s),ht(s)),m=R(r,R(n,p)),f=Ht(i.shape,a);return f.length>0&&(m=it(m,f)),F(m,i.shape)}}}};var UN={kernelName:gi,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,o]=t,n=xe(e,0);return{x:()=>ne(n,r,R(r,o)),alpha:()=>{let s=ne(n,ht(r),R(r,e)),i=Ht(o.shape,r.shape);return i.length>0&&(s=it(s,i)),F(s,o.shape)}}}};function q3(r,t,e){let o=r.shape.slice();o[e]=1;let n=F(t,o),s=np(r,e,!0,!1),i=np(r,e,!0,!0),a=R(s,i);return R(n,a)}function j3(r,t,e){let o=r.shape.length,n=o-e.length,s=S.getAxesPermutation(e,o),i=r;s!=null&&(i=vt(r,s));let a=i.shape.slice(),u=a.splice(o-e.length,e.length).reduce((m,f)=>m*f,1);a.push(u);let c=i.reshape(a),p=q3(c,t,n);if(p=p.reshape(i.shape),s!=null){let m=S.getUndoAxesPermutation(s);p=vt(p,m)}return p}var HN={kernelName:xi,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{axis:n}=e,s=[];return n==null?s=o.shape.map((i,a)=>a):typeof n=="number"?s=[n]:s=n,{x:()=>j3(o,r,s)}}};var KN={kernelName:En,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=Nt(e.shape,o.shape);return{a:()=>{let a=ot(r,Y(o,"float32")),l=Ht(e.shape,n);return l.length>0?F(it(a,l),e.shape):a},b:()=>{let a=R(r,Y(e,"float32")),l=Ht(o.shape,n);l.length>0&&(a=F(it(a,l),o.shape));let u=At(o);return zt(ot(a,Y(u,"float32")))}}}};var qN={kernelName:Kn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,zt(At(e)))}}};var jN={kernelName:jn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,o=R(io(e,6),$o(e));return{x:()=>R(r,Y(o,"float32"))}}};var XN={kernelName:qn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,Y($o(e),"float32"))}}};var YN={kernelName:yi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>F(r,e.shape)}}};var ZN={kernelName:wi,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[o]=t,n={dy:r,images:o};return{images:()=>T.runKernel(eu,n,e)}}};var JN={kernelName:bi,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[o]=t,n={dy:r,images:o};return{images:()=>T.runKernel(tu,n,e)}}};var QN={kernelName:Ci,gradFunc:(r,t,e)=>{let{dims:o}=e,n=Ee(o,r.shape);return{x:()=>qr(r,n)}}};var tT={kernelName:Xn,gradFunc:r=>({x:()=>ht(r)})};var eT={kernelName:Yn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>zt(ot(r,R(so(e,1.5),2)))}}};var rT={kernelName:Ii,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>Y(ht(e),"float32"),t:()=>R(r,Y(e,r.dtype)),e:()=>R(r,Y(Tu(e),r.dtype))}}};var oT={kernelName:Zn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let o=xe(e,xt(0)),n=xt(Rb),s=xt(Fb),i=R(r,s),a=R(R(r,n),Ze(Y(e,"float32")));return ne(o,i,a)}}}};var nT={kernelName:es,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,R(e,ct(xt(1),e)))}}};var sT={kernelName:ts,gradFunc:r=>({x:()=>ht(r)})};var iT={kernelName:Jn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(Aa(Y(e,"float32")),r)}}};var aT={kernelName:Qn,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(op(Y(e,"float32")),r)}}};var lT={kernelName:Si,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{begin:n,size:s}=e,i=o.shape,[a,l]=Db(o,n,s),u=[];for(let c=0;c<r.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>_a(r,u)}}};var uT={kernelName:ki,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[o]=t,{dim:n}=e,s=!0,i=R(r,o);return{logits:()=>ct(i,R(it(i,[n],s),o))}}};var cT={kernelName:rs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,no(e))}}};var zb={kernelName:Ti,gradFunc:(r,t,e)=>{let{blockShape:o,paddings:n}=e;return{x:()=>Cu(r,o,n)}}};var Mb={kernelName:vi,gradFunc:(r,t,e)=>{let{axis:o}=e;return{x:()=>te(r,o)}}};var pT={kernelName:os,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,R(ee(Y(e,"float32")),2))}}};var mT={kernelName:ru,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,R(Y(e,"float32"),2))}}};var fT={kernelName:ns,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=xt(2);return{a:()=>R(r,R(n,ct(e,o))),b:()=>R(r,R(n,ct(o,e)))}}};var hT={kernelName:ls,gradFunc:r=>({x:()=>ht(r)})};var dT={kernelName:ss,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,o]=t,n=Nt(e.shape,o.shape);return{a:()=>{let a=r,l=Ht(e.shape,n);return l.length>0&&(a=it(a,l)),F(a,e.shape)},b:()=>{let a=r,l=Ht(o.shape,n);return l.length>0&&(a=it(a,l)),F(zt(a),o.shape)}}}};var gT={kernelName:Ni,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,n=o.shape.slice(),{axis:s}=e;Ee(s,o.shape).forEach(u=>{n[u]=1});let a=F(r,n),l=R(a,_r(o.shape,"float32"));return{x:()=>l}}};var xT={kernelName:is,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ot(r,At(Aa(e)))}}};var yT={kernelName:as,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(ct(xt(1),At(e)),r)}}};var bT={kernelName:Ko,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[o]=t,{reps:n}=e;return{x:()=>{let i=ht(o);if(o.rank===1)for(let a=0;a<n[0];++a)i=X(i,Rt(r,[a*o.shape[0]],[o.shape[0]]));else if(o.rank===2)for(let a=0;a<n[0];++a)for(let l=0;l<n[1];++l)i=X(i,Rt(r,[a*o.shape[0],l*o.shape[1]],[o.shape[0],o.shape[1]]));else if(o.rank===3)for(let a=0;a<n[0];++a)for(let l=0;l<n[1];++l)for(let u=0;u<n[2];++u)i=X(i,Rt(r,[a*o.shape[0],l*o.shape[1],u*o.shape[2]],[o.shape[0],o.shape[1],o.shape[2]]));else if(o.rank===4)for(let a=0;a<n[0];++a)for(let l=0;l<n[1];++l)for(let u=0;u<n[2];++u)for(let c=0;c<n[3];++c)i=X(i,Rt(r,[a*o.shape[0],l*o.shape[1],u*o.shape[2],c*o.shape[3]],[o.shape[0],o.shape[1],o.shape[2],o.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${o.rank} tensors yet.`);return i}}}};var wT={kernelName:qo,gradFunc:(r,t,e)=>{let o=e,{perm:n}=o,s=sp(n);return{x:()=>vt(r,s)}}};var CT={kernelName:Ei,gradFunc:(r,t,e)=>{let o=e,{axis:n}=o;return{value:()=>Fe(r,n)}}};var IT={kernelName:Ai,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>X3(r,e)}}};function X3(r,t){let e=Fr(t,ht(t)),o=$a(r,e),n=wr(t,xt(0,"int32")),s=o.rank-n.rank;for(let a=0;a<s;++a)n=Ae(n,a+1);n=nr(n,_r(o.shape,"bool"));let i=ht(o);return ne(n,o,i)}var ST={kernelName:$i,gradFunc:r=>({x:()=>ht(r)})};var Y3=[Ah,ES,AS,$S,DS,RS,FS,_S,OS,LS,PS,zS,BS,GS,WS,US,HS,KS,qS,jS,XS,YS,JS,ZS,tN,eN,rN,oN,nN,sN,KN,iN,aN,lN,uN,cN,mN,pN,fN,gN,xN,yN,bN,wN,CN,IN,SN,NN,TN,kN,Lb,Lb,EN,$N,RN,FN,_N,ON,LN,PN,zN,MN,BN,VN,GN,Pb,Pb,WN,UN,HN,qN,jN,XN,YN,ZN,JN,QN,tT,eT,rT,oT,nT,sT,iT,aT,lT,uT,cT,zb,zb,Mb,Mb,pT,fT,mT,hT,dT,gT,xT,yT,bT,wT,CT,IT,ST];for(let r of Y3)tC(r);D().prototype.abs=function(){return this.throwIfDisposed(),ve(this)};D().prototype.acos=function(){return this.throwIfDisposed(),$y(this)};D().prototype.acosh=function(){return this.throwIfDisposed(),Dy(this)};D().prototype.add=function(r){return this.throwIfDisposed(),X(this,r)};D().prototype.all=function(r,t){return this.throwIfDisposed(),Jc(this,r,t)};D().prototype.any=function(r,t){return this.throwIfDisposed(),yu(this,r,t)};D().prototype.argMax=function(r){return this.throwIfDisposed(),ps(this,r)};D().prototype.argMin=function(r){return this.throwIfDisposed(),YC(this,r)};D().prototype.asScalar=function(){return this.throwIfDisposed(),k(this.size===1,()=>"The array must have only 1 element."),F(this,[])};D().prototype.asType=function(r){return this.throwIfDisposed(),Y(this,r)};D().prototype.as1D=function(){return this.throwIfDisposed(),F(this,[this.size])};D().prototype.as2D=function(r,t){return this.throwIfDisposed(),F(this,[r,t])};D().prototype.as3D=function(r,t,e){return this.throwIfDisposed(),F(this,[r,t,e])};D().prototype.as4D=function(r,t,e,o){return this.throwIfDisposed(),F(this,[r,t,e,o])};D().prototype.as5D=function(r,t,e,o,n){return this.throwIfDisposed(),F(this,[r,t,e,o,n])};D().prototype.asin=function(){return this.throwIfDisposed(),Ry(this)};D().prototype.asinh=function(){return this.throwIfDisposed(),Fy(this)};D().prototype.atan=function(){return this.throwIfDisposed(),_y(this)};D().prototype.atan2=function(r){return this.throwIfDisposed(),ZC(this,r)};D().prototype.atanh=function(){return this.throwIfDisposed(),Oy(this)};D().prototype.avgPool=function(r,t,e,o){return this.throwIfDisposed(),Ea(this,r,t,e,o)};D().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),Cu(this,r,t)};D().prototype.batchNorm=function(r,t,e,o,n){return this.throwIfDisposed(),Pi(this,r,t,e,o,n)};D().prototype.broadcastTo=function(r){return this.throwIfDisposed(),ms(this,r)};D().prototype.cast=function(r){return this.throwIfDisposed(),Y(this,r)};D().prototype.ceil=function(){return this.throwIfDisposed(),Wy(this)};D().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),He(this,r,t)};D().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof _t&&(r=[r]),te([this,...r],t)};D().prototype.conv1d=function(r,t,e,o,n,s){return this.throwIfDisposed(),ep(this,r,t,e,o,n,s)};D().prototype.conv2dTranspose=function(r,t,e,o,n){return this.throwIfDisposed(),rp(this,r,t,e,o,n)};D().prototype.conv2d=function(r,t,e,o,n,s){return this.throwIfDisposed(),Dr(this,r,t,e,o,n,s)};D().prototype.cos=function(){return this.throwIfDisposed(),Aa(this)};D().prototype.cosh=function(){return this.throwIfDisposed(),op(this)};D().prototype.cumprod=function(r,t,e){return this.throwIfDisposed(),np(this,r,t,e)};D().prototype.cumsum=function(r,t,e){return this.throwIfDisposed(),ah(this,r,t,e)};D().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),rI(this,r,t)};D().prototype.depthwiseConv2d=function(r,t,e,o,n,s){return this.throwIfDisposed(),hs(this,r,t,e,o,n,s)};D().prototype.dilation2d=function(r,t,e,o,n){return this.throwIfDisposed(),oI(this,r,t,e,o,n)};D().prototype.divNoNan=function(r){return this.throwIfDisposed(),sI(this,r)};D().prototype.div=function(r){return this.throwIfDisposed(),ot(this,r)};D().prototype.dot=function(r){return this.throwIfDisposed(),iI(this,r)};D().prototype.elu=function(){return this.throwIfDisposed(),ds(this)};D().prototype.equal=function(r){return this.throwIfDisposed(),pr(this,r)};D().prototype.erf=function(){return this.throwIfDisposed(),Yy(this)};D().prototype.euclideanNorm=function(r,t){return this.throwIfDisposed(),uI(this,r,t)};D().prototype.exp=function(){return this.throwIfDisposed(),Ze(this)};D().prototype.expandDims=function(r){return this.throwIfDisposed(),Ae(this,r)};D().prototype.expm1=function(){return this.throwIfDisposed(),eb(this)};D().prototype.fft=function(){return this.throwIfDisposed(),xp(this)};D().prototype.flatten=function(){return this.throwIfDisposed(),F(this,[this.size])};D().prototype.floor=function(){return this.throwIfDisposed(),gs(this)};D().prototype.floorDiv=function(r){return this.throwIfDisposed(),sh(this,r)};D().prototype.gather=function(r,t){return this.throwIfDisposed(),$a(this,r,t)};D().prototype.greaterEqual=function(r){return this.throwIfDisposed(),wr(this,r)};D().prototype.greater=function(r){return this.throwIfDisposed(),xe(this,r)};D().prototype.ifft=function(){return this.throwIfDisposed(),Du(this)};D().prototype.irfft=function(){return this.throwIfDisposed(),xb(this)};D().prototype.isFinite=function(){return this.throwIfDisposed(),rb(this)};D().prototype.isInf=function(){return this.throwIfDisposed(),ob(this)};D().prototype.isNaN=function(){return this.throwIfDisposed(),nb(this)};D().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Da(this,r)};D().prototype.lessEqual=function(r){return this.throwIfDisposed(),io(this,r)};D().prototype.less=function(r){return this.throwIfDisposed(),uh(this,r)};D().prototype.localResponseNormalization=function(r,t,e,o){return this.throwIfDisposed(),cI(this,r,t,e,o)};D().prototype.logSigmoid=function(){return this.throwIfDisposed(),ib(this)};D().prototype.logSoftmax=function(r){return this.throwIfDisposed(),ap(this,r)};D().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),pI(this,r,t)};D().prototype.log=function(){return this.throwIfDisposed(),mr(this)};D().prototype.log1p=function(){return this.throwIfDisposed(),ip(this)};D().prototype.logicalAnd=function(r){return this.throwIfDisposed(),nr(this,r)};D().prototype.logicalNot=function(){return this.throwIfDisposed(),Tu(this)};D().prototype.logicalOr=function(r){return this.throwIfDisposed(),ch(this,r)};D().prototype.logicalXor=function(r){return this.throwIfDisposed(),mI(this,r)};D().prototype.matMul=function(r,t,e){return this.throwIfDisposed(),Pt(this,r,t,e)};D().prototype.maxPool=function(r,t,e,o){return this.throwIfDisposed(),Ra(this,r,t,e,o)};D().prototype.max=function(r,t){return this.throwIfDisposed(),Ke(this,r,t)};D().prototype.maximum=function(r){return this.throwIfDisposed(),Fr(this,r)};D().prototype.mean=function(r,t){return this.throwIfDisposed(),se(this,r,t)};D().prototype.min=function(r,t){return this.throwIfDisposed(),zi(this,r,t)};D().prototype.minimum=function(r){return this.throwIfDisposed(),Fa(this,r)};D().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),fI(this,r,t)};D().prototype.mod=function(r){return this.throwIfDisposed(),hI(this,r)};D().prototype.mul=function(r){return this.throwIfDisposed(),R(this,r)};D().prototype.neg=function(){return this.throwIfDisposed(),zt(this)};D().prototype.norm=function(r,t,e){return this.throwIfDisposed(),Mi(this,r,t,e)};D().prototype.notEqual=function(r){return this.throwIfDisposed(),Bi(this,r)};D().prototype.oneHot=function(r,t=1,e=0){return this.throwIfDisposed(),ku(this,r,t,e)};D().prototype.onesLike=function(){return this.throwIfDisposed(),Le(this)};D().prototype.pad=function(r,t){return this.throwIfDisposed(),_a(this,r,t)};D().prototype.pool=function(r,t,e,o,n,s){return this.throwIfDisposed(),dI(this,r,t,e,o,n,s)};D().prototype.pow=function(r){return this.throwIfDisposed(),so(this,r)};D().prototype.prelu=function(r){return this.throwIfDisposed(),Oa(this,r)};D().prototype.prod=function(r,t){return this.throwIfDisposed(),gI(this,r,t)};D().prototype.reciprocal=function(){return this.throwIfDisposed(),db(this)};D().prototype.relu=function(){return this.throwIfDisposed(),Or(this)};D().prototype.relu6=function(){return this.throwIfDisposed(),hh(this)};D().prototype.reshapeAs=function(r){return this.throwIfDisposed(),F(this,r.shape)};D().prototype.reshape=function(r){return this.throwIfDisposed(),F(this,r)};D().prototype.resizeBilinear=function(r,t,e){return this.throwIfDisposed(),Ih(this,r,t,e)};D().prototype.resizeNearestNeighbor=function(r,t,e){return this.throwIfDisposed(),Sh(this,r,t,e)};D().prototype.reverse=function(r){return this.throwIfDisposed(),qr(this,r)};D().prototype.rfft=function(){return this.throwIfDisposed(),yb(this)};D().prototype.round=function(){return this.throwIfDisposed(),up(this)};D().prototype.rsqrt=function(){return this.throwIfDisposed(),cp(this)};D().prototype.selu=function(){return this.throwIfDisposed(),pp(this)};D().prototype.separableConv2d=function(r,t,e,o,n,s){return this.throwIfDisposed(),mp(this,r,t,e,o,n,s)};D().prototype.sigmoid=function(){return this.throwIfDisposed(),no(this)};D().prototype.sign=function(){return this.throwIfDisposed(),gb(this)};D().prototype.sin=function(){return this.throwIfDisposed(),fp(this)};D().prototype.sinh=function(){return this.throwIfDisposed(),hp(this)};D().prototype.slice=function(r,t){return this.throwIfDisposed(),Rt(this,r,t)};D().prototype.softmax=function(r){return this.throwIfDisposed(),za(this,r)};D().prototype.softplus=function(){return this.throwIfDisposed(),tn(this)};D().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),Eu(this,r,t)};D().prototype.split=function(r,t){return this.throwIfDisposed(),Re(this,r,t)};D().prototype.sqrt=function(){return this.throwIfDisposed(),ee(this)};D().prototype.square=function(){return this.throwIfDisposed(),At(this)};D().prototype.squaredDifference=function(r){return this.throwIfDisposed(),FI(this,r)};D().prototype.squeeze=function(r){return this.throwIfDisposed(),Ao(this,r)};D().prototype.stack=function(r,t){this.throwIfDisposed();let e=r instanceof _t?[this,r]:[this,...r];return Fe(e,t)};D().prototype.step=function(r){return this.throwIfDisposed(),$o(this,r)};D().prototype.stridedSlice=function(r,t,e,o,n,s,i,a){return this.throwIfDisposed(),bb(this,r,t,e,o,n,s,i,a)};D().prototype.sub=function(r){return this.throwIfDisposed(),ct(this,r)};D().prototype.sum=function(r,t){return this.throwIfDisposed(),it(this,r,t)};D().prototype.tan=function(){return this.throwIfDisposed(),wb(this)};D().prototype.tanh=function(){return this.throwIfDisposed(),wu(this)};D().prototype.tile=function(r){return this.throwIfDisposed(),Je(this,r)};D().prototype.toBool=function(){return this.throwIfDisposed(),Y(this,"bool")};D().prototype.toFloat=function(){return this.throwIfDisposed(),Y(this,"float32")};D().prototype.toInt=function(){return this.throwIfDisposed(),Y(this,"int32")};D().prototype.topk=function(r,t){return this.throwIfDisposed(),_I(this,r,t)};D().prototype.transpose=function(r){return this.throwIfDisposed(),vt(this,r)};D().prototype.unique=function(r){return this.throwIfDisposed(),OI(this,r)};D().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),gh(this,r,t)};D().prototype.unstack=function(r){return this.throwIfDisposed(),sr(this,r)};D().prototype.where=function(r,t){return this.throwIfDisposed(),ne(r,this,t)};D().prototype.zerosLike=function(){return this.throwIfDisposed(),ht(this)};var Cr=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Cr.prototype)}},er=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,er.prototype)}},O=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,O.prototype)}},dt=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,dt.prototype)}},Mu=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Mu.prototype)}};var Np=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let o=this.cache.keys().next().value;this.cache.delete(o)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let o=this.cache.keys().next().value;this.cache.delete(o)}this.maxEntries=t}};function uo(r,t){if(Array.isArray(r)){let e=[];for(let o=0;o<t;o++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function jr(r,t){if(!r)throw new Mu(t)}function Vb(r,t){let e=0;for(let o of r)o===t&&e++;return e}function ze(r){return r.length===1?r[0]:r}function Kt(r){return Array.isArray(r)?r:[r]}function co(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Cs(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var lo={};function Bu(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function Bb(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>Bb(t));else{let t=Object.keys(r);for(let e of t){let o=r[e];o!=null&&typeof o=="object"&&(!Array.isArray(o)&&o.type==="ndarray"&&typeof o.value=="number"?r[e]=o.value:Bb(o))}}}function on(r,t={},e={},o="object",n=!1){if(typeof r=="string"){let s=r,i;if(s in e)i=e[s];else if(s in lo)i=lo[s];else if(i=t[s],i==null)throw new O(`Unknown ${o}: ${r}. This may be due to one of the following reasons:
1. The ${o} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${o} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=r;if(s.className==null||s.config==null)throw new O(`${o}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,l;if(i in e?[a,l]=e[i]:i in lo?[a,l]=lo.className:i in t&&([a,l]=t[i]),a==null)throw new O(`Unknown ${o}: ${i}. This may be due to one of the following reasons:
1. The ${o} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${o} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let f of Object.keys(lo))u[f]=lo[f];for(let f of Object.keys(e))u[f]=e[f];let c=s.config;c.customObjects=u;let p=Object.assign({},lo);for(let f of Object.keys(e))lo[f]=e[f];Bb(s.config);let m=l(a,s.config,e,n);return lo=Object.assign({},p),m}else{let u=Object.assign({},lo);for(let p of Object.keys(e))lo[p]=e[p];let c=new a(s.config);return lo=Object.assign({},u),c}}}function Z3(r,t){return r<t?-1:r>t?1:0}function Tp(r,t){return-1*Z3(r,t)}function po(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function NT(r){if(r==null)throw new O(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function nn(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new O(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function Dh(r,t,e=0,o=1/0){return jr(e>=0),jr(o>=e),Array.isArray(r)&&r.length>=e&&r.length<=o&&r.every(n=>typeof n===t)}function we(r,t){Array.isArray(r)?(y.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,o)=>we(e,`element ${o+1} of ${t}`))):y.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${TT(r)}.`)}function TT(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>TT(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function vT(r,t,e){let o=e!=null?e():y.now(),n;return(...i)=>{let a=e!=null?e():y.now();return a-o<t||(o=a,n=r(...i)),n}}function Rh(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var J3=0;function _h(){return J3++}var Fh={};function Gi(r=""){return r in Fh||(Fh[r]=0),Fh[r]+=1,r+Fh[r].toString()}var kT=["channelsFirst","channelsLast"],ET=["nearest","bilinear"],AT=["valid","same","causal"],$T=["max","avg"],DT=["sum","mul","concat","ave"];var Vu=new Map;function ie(r){nn(kT,"DataFormat",r)}function FT(r){nn(ET,"InterpolationFormat",r)}function fr(r){nn(AT,"PaddingMode",r)}function Gb(r){nn($T,"PoolMode",r)}var vp=[],RT="/";function Fo(r,t){vp.push(r);try{let e=t();return vp.pop(),e}catch(e){throw vp.pop(),e}}function Q3(){return vp.length===0?"":vp.join(RT)+RT}function Oh(r){if(!_T(r))throw new Error("Not a valid tensor name: '"+r+"'");return Q3()+r}function Lh(r){if(!_T(r))throw new Error("Not a valid tensor name: '"+r+"'");Vu.has(r)||Vu.set(r,0);let t=Vu.get(r);if(Vu.set(r,Vu.get(r)+1),t>0){let e=`${r}_${t}`;return Vu.set(e,1),e}else return r}var tM=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function _T(r){return!!r.match(tM)}function OT(r){return r===parseInt(r.toString(),10)}function mo(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let o=1;for(let n=t;n<e;++n)o*=r[n];return o}function Ha(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<r.length;e++){let o=r[e];o<t&&(t=o)}return t}function _o(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let o=r[e];o>t&&(t=o)}return t}function hr(r,t){if(t<r)throw new O(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let o=r;o<t;++o)e.push(o);return e}var Wb;function ke(){return Wb==null&&(Wb=XC().epsilon()),Wb}function dr(){return"channelsLast"}function ir(r,t){return Y(r,t)}function Ss(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),F(r,e)}function LT(r,t){return z(()=>{if(r.shape.length!==2)throw new O(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=Ss(r,1);return zh(e,[1,t,1])})}function PT(r){let t=[mo(r.shape)];return F(r,t)}function zT(r){if(r.rank<=1)throw new O(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],mo(r.shape,1)];return F(r,t)}function Is(r,t,e){return z(()=>{switch(r.rank){case 1:return dp(r,t,e);case 2:return dh(r,[t,0],[e,r.shape[1]]);case 3:return gp(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return $u(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Rt(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Rt(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new O(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Ub(r,t,e){return z(()=>{switch(r.rank){case 1:return dp(r,t,e);case 2:return dh(r,[0,t],[r.shape[0],e]);case 3:return gp(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return $u(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function kp(r,t,e,o){return z(()=>{switch(r.rank){case 1:return dp(r,t,e);case 2:switch(o){case 1:return Is(r,t,e);case 2:return Ub(r,t,e);default:throw new O(`The axis is not within the rank of the tensor ${o}`)}case 3:switch(o){case 1:return Is(r,t,e);case 2:return gp(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return Ub(r,t,e);default:throw new O(`The axis is not within the rank of the tensor ${o}`)}case 4:switch(o){case 1:return Is(r,t,e);case 2:return $u(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return $u(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return Ub(r,t,e);default:throw new O(`The axis is not within the rank of the tensor ${o}`)}default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Gu(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),te(r,t)}function Kb(r,t){switch(r.rank){case 1:return Uy([r,t]);case 2:return Hy([r,t],0);case 3:return Ky([r,t],0);case 4:return qy([r,t],0);default:throw new O(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function zh(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new O(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return Je(r,t)}function Wu(r,t=0,e=1,o,n){return fh(r,t,e,o,n)}function fo(r,t,e,o){if(r.rank<2||t.rank<2)throw new dt(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let n=r.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(n!==s)throw new dt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return Wa.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:o?Hb(r.rank,o,dr()):null,activation:e});{let n=r.shape.slice(),s=n.pop();r=F(r,[-1,s]);let i=t.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:t.rank},(h,d)=>d===0?t.rank-2:d<=t.rank-2?d-1:d);t=F(vt(t,c),[l,-1]);let p=[...n,...u],m=!1,f=!1;return F(Wa.matMul({a:r,b:t,transposeA:m,transposeB:f,bias:o?Hb(r.rank,o,dr()):null,activation:e}),p)}}function Mh(r,t,e){return z(()=>(Array.isArray(t)?t=$e(t,"int32"):t=Y(t,"int32"),$a(r,t,e)))}function Ka(r){return R(r,r)}function Hb(r,t,e){let o=t.shape;if(t.rank!==1&&t.rank!==r)throw new O(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return o.length===1?F(t,[1,o[0],1,1,1]):F(t,[1,o[3],o[0],o[1],o[2]]);if(e==="channelsLast")return o.length===1?F(t,[1,1,1,1,o[0]]):F(t,[1].concat(o))}else if(r===4){if(e==="channelsFirst")return o.length===1?F(t,[1,o[0],1,1]):F(t,[1,o[2],o[0],o[1]]);if(e==="channelsLast")return o.length===1?F(t,[1,1,1,o[0]]):F(t,[1].concat(o))}else if(r===3){if(e==="channelsFirst")return o.length===1?F(t,[1,o[0],1]):F(t,[1,o[1],o[0]]);if(e==="channelsLast")return o.length===1?F(t,[1,1,o[0]]):F(t,[1].concat(o))}else if(r<3)return t;throw new O(`Unsupported input rank by biasAdd: ${t.rank}`)}function gr(r,t,e){return z(()=>(e==null&&(e=dr()),ie(e),X(r,Hb(r.rank,t,e))))}function MT(r,t=1){if(t!==1)throw new dt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return ds(r)}function BT(r){return z(()=>ot(r,X(ve(r),1)))}function Bh(r,t,e,o){return z(()=>MI(r,t,e,o))}function VT(r){return z(()=>{let t=X(.5,R(.2,r));return He(t,0,1)})}function Wi(r,t,e=!1){return e?r():t()}var GT=["fanIn","fanOut","fanAvg"],WT=["normal","uniform","truncatedNormal"];function eM(r){nn(GT,"FanMode",r)}function rM(r){nn(WT,"Distribution",r)}var xr=class extends H.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Ep=class extends xr{apply(t,e){return re(t,e)}};Ep.className="Zeros";H.registerClass(Ep);var qa=class extends xr{apply(t,e){return _r(t,e)}};qa.className="Ones";H.registerClass(qa);var Ap=class extends xr{constructor(t){if(super(),typeof t!="object")throw new O(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new O(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return z(()=>R(xt(this.value),_r(t,e)))}getConfig(){return{value:this.value}}};Ap.className="Constant";H.registerClass(Ap);var $p=class extends xr{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return xs(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};$p.className="RandomUniform";H.registerClass($p);var Dp=class extends xr{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new dt(`randomNormal does not support dType ${e}.`);return Wu(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Dp.className="RandomNormal";H.registerClass(Dp);var Rp=class extends xr{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new dt(`truncatedNormal does not support dType ${e}.`);return bp(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Rp.className="TruncatedNormal";H.registerClass(Rp);var Fp=class extends xr{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return z(()=>{if(t.length!==2||t[0]!==t[1])throw new O("Identity matrix initializer can only be used for 2D square matrices.");return R(this.gain,Su(t[0]))})}getConfig(){return{gain:this.gain}}};Fp.className="Identity";H.registerClass(Fp);function oM(r,t="channelsLast"){let e,o;if(ie(t),r.length===2)e=r[0],o=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let n=mo(r,2);e=r[1]*n,o=r[0]*n}else if(t==="channelsLast"){let n=mo(r,0,r.length-2);e=r[r.length-2]*n,o=r[r.length-1]*n}}else{let n=mo(r);e=Math.sqrt(n),o=Math.sqrt(n)}return[e,o]}var ar=class extends xr{constructor(t){if(super(),t.scale<0)throw new O(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,eM(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,rM(this.distribution),this.seed=t.seed}apply(t,e){let o=oM(t),n=o[0],s=o[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,n):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(n+s)/2),this.distribution==="normal"){let a=Math.sqrt(i);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new dt(`${this.getClassName()} does not support dType ${e}.`);return bp(t,0,a,e,this.seed)}else{let a=Math.sqrt(3*i);return xs(t,-a,a,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};ar.className="VarianceScaling";H.registerClass(ar);var Uu=class extends ar{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return ar.className}};Uu.className="GlorotUniform";H.registerClass(Uu);var Hu=class extends ar{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return ar.className}};Hu.className="GlorotNormal";H.registerClass(Hu);var Ku=class extends ar{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return ar.className}};Ku.className="HeNormal";H.registerClass(Ku);var qu=class extends ar{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return ar.className}};qu.className="HeUniform";H.registerClass(qu);var ju=class extends ar{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return ar.className}};ju.className="LeCunNormal";H.registerClass(ju);var Xu=class extends ar{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return ar.className}};Xu.className="LeCunUniform";H.registerClass(Xu);var _p=class extends xr{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new dt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return z(()=>{if(t.length<2)throw new dt("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let o=t[0]>t[1]?[t[1],t[0]]:t,n=Wu(o,0,1,"float32"),s=aS.gramSchmidt(n);return t[0]>t[1]&&(s=vt(s)),R(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};_p.className="Orthogonal";H.registerClass(_p);var UT={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function HT(r,t={}){return on(r,H.SerializationMap.getMap().classNameMap,t,"initializer")}function Jt(r){return Bu(r)}function Wt(r){if(typeof r=="string"){let t=r in UT?UT[r]:r;if(t==="GlorotNormal")return new Hu;if(t==="GlorotUniform")return new Uu;if(t==="HeNormal")return new Ku;if(t==="HeUniform")return new qu;if(t==="LeCunNormal")return new ju;if(t==="LeCunUniform")return new Xu;{let e={};return e.className=t,e.config={},HT(e)}}else return r instanceof xr?r:HT(r)}function Vh(r){return Array.isArray(r)&&Array.isArray(r[0])}function Yu(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function gt(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new O(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function kt(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new O(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function Zu(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((o,n)=>o*n);return t}var qT="Variable",Op=class{constructor(t,e="float32",o=qT,n=!0,s=null){this.dtype=e==null?"float32":e,this.shape=t.shape,this.id=_h(),o=o==null?qT:o,this.originalName=Oh(o),this.name=Lh(this.originalName),this.trainable_=n,this.constraint=s,this.val=Cb(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),sM(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function sM(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function Lp(r){return r.map(t=>t.read())}function Ju(r){r.forEach(t=>{t[0].write(t[1])})}var qt=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},lr=class{constructor(t,e,o,n,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=o,this.inputs=n,this.callArgs=s,this.outputTensorIndex=a,this.id=_h(),i!=null&&(this.originalName=Oh(i),this.name=Lh(this.originalName)),this.rank=e.length}},iM=0,Ns=class{constructor(t,e){this.callArgs=e,this.id=iM++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let o of t.inboundLayers)o!=null&&o.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},aM=0,Ct=class extends H.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=aM++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let o=this.getClassName();e=co(o)+"_"+Gi(o)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let o;if(t.batchInputShape!=null)o=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),o=[s].concat(t.inputShape)}this.batchInputShape=o;let n=t.dtype;n==null&&(n=t.inputDType),n==null&&(n="float32"),this.dtype=n}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new er(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new O(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ze(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ze(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Cr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Cr(`Layer ${this.name} is not connected, no input to return.`);return ze(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Cr(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Cr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ze(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Kt(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=Kt(this.inputSpec);if(t.length!==e.length)throw new O(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let o=0;o<t.length;o++){let n=t[o],s=e[o];if(s==null)continue;let i=n.rank;if(s.ndim!=null&&i!==s.ndim)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&n.dtype!==s.dtype)throw new O(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${n.dtype}.`);if(s.axes){let a=n.shape;for(let l in s.axes){let u=Number(l),c=s.axes[l],p=u>=0?a[u]:a[a.length+u];if(c!=null&&[c,null].indexOf(p)===-1)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let l=s.shape[a],u=n.shape[a];if(l!=null&&u!=null&&l!==u)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${n.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let o=Kt(t),n=!0;for(let i of o)if(!(i instanceof lr)){n=!1;break}let s=!0;for(let i of o)if(i instanceof lr){s=!1;break}if(n===s)throw new O("Arguments to apply() must be all SymbolicTensors or all Tensors");return Fo(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of Kt(t))i.push(a.shape);this.build(ze(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,e),a=Kt(i),l=[];for(let u of a)o.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=ze(l),this.activityRegularizer!=null)throw new dt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=lM(t),a=this.computeOutputShape(i),l,u=uM(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,p)=>new lr(u,c,this,Kt(t),e,this.name,p)):l=new lr(u,a,this,Kt(t),e,this.name),this.addInboundNode(t,l,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new dt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((o,n)=>{o!=null&&t[n]!=null&&t[n]!==o&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Cr(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let o=JSON.stringify(e.outputShapes);t.indexOf(o)===-1&&t.push(o)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Cr(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new er(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Zu(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Lp(t?this.trainableWeights:this.weights)}setWeights(t){z(()=>{let e=this.weights;if(e.length!==t.length)throw new O(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let o=[],n=Lp(e);for(let s=0;s<n.length;++s){let i=n[s],a=e[s],l=t[s];if(!y.arraysEqual(i.shape,l.shape))throw new O(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);o.push([a,l])}Ju(o)})}addWeight(t,e,o,n,s,i,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new O(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),o==null&&(o="float32"),this.fastWeightInitDuringBuild&&(n=l!=null?l():Wt("zeros"));let u=n.apply(e,o),c=new Op(u,o,t,i,a);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Kt(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(o=>{if(o!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,o,n,s,i,a=null){let l=Kt(t);e=Kt(e),o=Kt(o),n=Kt(n),s=Yu(s),i=Yu(i);let u=[],c=[],p=[];for(let m of l)u.push(m.sourceLayer),c.push(m.nodeIndex),p.push(m.tensorIndex);new Ns({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:p,inputTensors:l,outputTensors:e,inputMasks:o,outputMasks:n,inputShapes:s,outputShapes:i},a);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function lM(r){r=Kt(r);let t=[];for(let e of r)t.push(e.shape);return ze(t)}function uM(r){return"float32"}function qb(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let o=t.inboundNodes[e];if(o.inboundLayers.length===0)return o.inputTensors;{let n=[];for(let s=0;s<o.inboundLayers.length;s++){let i=o.inputTensors[s],a=o.inboundLayers[s],l=o.nodeIndices[s],u=qb(i,a,l);for(let c of u)n.indexOf(c)===-1&&n.push(c)}return n}}}var sn=class extends Ct{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:Gi("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new O("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new O("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new O("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let o=t.dtype||"float32";this.batchInputShape=e,this.dtype=o,this.inputSpec=[{shape:e}];let n=new lr(this.dtype,this.batchInputShape,this,[],{},this.name);n.nodeIndex=0,n.tensorIndex=0,new Ns({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[n],outputTensors:[n],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new O(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};sn.className="InputLayer";H.registerClass(sn);function jb(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new O("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new sn({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function cM(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return Y(t,r.dtype)}catch(e){throw new O(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var ho=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof ho)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,o){if(this.id2Value[t.id]==null)this.id2Value[t.id]=cM(t,e),this.name2Id[t.name]=t.id,o!=null&&(this.id2Mask[t.id]=o);else throw new O(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof lr){if(this.id2Value[t.id]==null)throw new O(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof lr){if(this.id2Value[t.id]==null)throw new O(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&wt(this.id2Mask)}},Gh=new Np,Wh=new Np;function XT(r){Gh!=null&&Gh.setMaxEntries(r),Wh!=null&&Wh.setMaxEntries(r)}function ja(r,t,e,o){let n=e==null?!1:e.training,s=Array.isArray(r),i=s?r:[r],a=i.map(h=>h.name),l=[],u=t.names();for(let h of a)u.indexOf(h)!==-1?l.push(t.getValue(h)):l.push(null);o!=null&&(o.maxNumTensors=-1/0,o.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().sort().join(","),p=Gh.get(c),m;if(p==null){let h=pM(i,t);p=h.sorted,m=h.recipientCounts,Gh.put(c,p),Wh.put(c,m)}m={},n||Object.assign(m,Wh.get(c));let f=new ho(t);for(let h=0;h<p.length;++h){if(o!=null){let _=Zc().numTensors;_>o.maxNumTensors&&(o.maxNumTensors=_),_<o.minNumTensors&&(o.minNumTensors=_)}let d=p[h],g=d.sourceLayer;if(g instanceof sn)continue;let x=[],b=[],C=[],w=!1;for(let _ of d.inputs){let L=f.getValue(_),B=f.getMask(_);x.push(L),b.push(B),B!=null&&(w=!0),n||(m[_.name]--,m[_.name]===0&&!t.hasKey(_)&&a.indexOf(_.name)===-1&&!L.isDisposed&&_.sourceLayer.stateful!==!0&&C.push(L))}w&&(e=e||{},e.mask=b[0]);let I=Kt(g.apply(x,e)),E=null;g.supportsMasking&&(E=g.computeMask(x,b));let A=fM(d),$=Array.isArray(A)?A:[A];for(let _=0;_<$.length;++_){f.hasKey($[_])||f.add($[_],I[_],Array.isArray(E)?E[0]:E);let L=a.indexOf($[_].name);L!==-1&&(l[L]=I[_])}n||wt(C)}return f.disposeMasks(),s?l:l[0]}function pM(r,t){y.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],o={};if(r.length===1){let n=jT(r[0],t);e=n.sorted,o=n.recipientMap}else{let n=new Set;for(let s of r){let{sorted:i,recipientMap:a}=jT(s,t);for(let l of i)n.has(l.name)||(e.push(l),n.add(l.name));for(let l in a)o[l]==null&&(o[l]=new Set),a[l].forEach(u=>o[l].add(u))}}return{sorted:e,recipientCounts:mM(o)}}function mM(r){let t={};for(let e in r)t[e]=r[e].size;return t}function jT(r,t){let e=new Set,o=[],n={};for(let a of t.names())e.add(a);let s=[],i=[];for(s.push(r);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(a.inputs.length===0||l)s.pop(),o.push(a),e.add(a.name),l&&i.pop();else{i.push(s.length-1);for(let u of a.inputs)n[u.name]==null&&(n[u.name]=new Set),n[u.name].add(a.name),!e.has(u.name)&&s.push(u)}}return{sorted:o,recipientMap:n}}function fM(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let o=0;o<r.sourceLayer.inboundNodes.length;++o)for(let n of r.sourceLayer.inboundNodes[o].outputTensors)if(n.id===r.id){e=o;break}t=r.sourceLayer.getOutputAt(e)}return t}var hM=P();hM.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,XT);function Xb(r,t){return z(()=>ee(it(R(r,r),t,!0)))}var Xa=class extends H.Serializable{getConfig(){return{}}},Pp=class extends Xa{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return z(()=>{let e=Xb(t,this.axis),o=He(e,0,this.maxValue);return R(t,ot(o,X(ke(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Pp.className="MaxNorm";H.registerClass(Pp);var zp=class extends Xa{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return z(()=>ot(t,X(ke(),Xb(t,this.axis))))}getConfig(){return{axis:this.axis}}};zp.className="UnitNorm";H.registerClass(zp);var Mp=class extends Xa{apply(t){return Or(t)}};Mp.className="NonNeg";H.registerClass(Mp);var Bp=class extends Xa{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return z(()=>{let e=Xb(t,this.axis),o=X(R(this.rate,He(e,this.minValue,this.maxValue)),R(1-this.rate,e));return R(t,ot(o,X(ke(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Bp.className="MinMaxNorm";H.registerClass(Bp);var YT={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function pe(r){return Bu(r)}function ZT(r,t={}){return on(r,H.SerializationMap.getMap().classNameMap,t,"constraint")}function me(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in YT?YT[r]:r,config:{}};return ZT(e)}else return r instanceof Xa?r:ZT(r)}function Ts(r){return M(this,null,function*(){if(r==null)return;let t=[],e=[],o=[];for(let n in r){let s=r[n];if(typeof s!="number"){let i=s;t.push(i.data()),e.push(n),o.push(i)}}if(t.length>0){let n=yield Promise.all(t);for(let s=0;s<n.length;++s)r[e[s]]=n[s][0];wt(o)}})}function Uh(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var JT;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(JT||(JT={}));var xM=125,Ui=class{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return M(this,null,function*(){})}onEpochEnd(t,e){return M(this,null,function*(){})}onBatchBegin(t,e){return M(this,null,function*(){})}onBatchEnd(t,e){return M(this,null,function*(){})}onTrainBegin(t){return M(this,null,function*(){})}onTrainEnd(t){return M(this,null,function*(){})}setModel(t){}},Hh=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){return M(this,null,function*(){e==null&&(e={});for(let o of this.callbacks)yield o.onEpochBegin(t,e)})}onEpochEnd(t,e){return M(this,null,function*(){e==null&&(e={});for(let o of this.callbacks)yield o.onEpochEnd(t,e)})}onBatchBegin(t,e){return M(this,null,function*(){e==null&&(e={});for(let o of this.callbacks)yield o.onBatchBegin(t,e)})}onBatchEnd(t,e){return M(this,null,function*(){e==null&&(e={});for(let o of this.callbacks)yield o.onBatchEnd(t,e)})}onTrainBegin(t){return M(this,null,function*(){t==null&&(t={});for(let e of this.callbacks)yield e.onTrainBegin(t)})}onTrainEnd(t){return M(this,null,function*(){t==null&&(t={});for(let e of this.callbacks)yield e.onTrainEnd(t)})}},Yb=class extends Ui{constructor(){super()}onEpochBegin(t){return M(this,null,function*(){this.seen=0,this.totals={}})}onBatchEnd(t,e){return M(this,null,function*(){e==null&&(e={});let o=e.size==null?0:e.size;this.seen+=o;for(let n in e){let s=e[n];if(typeof s=="number")this.totals.hasOwnProperty(n)||(this.totals[n]=0),this.totals[n]=this.totals[n]+s*o;else{let i;n in this.totals?i=this.totals[n]:this.totals[n]=0;let a=z(()=>X(this.totals[n],R(s,o)));this.totals[n]=a,i!=null&&i.dispose()}}})}onEpochEnd(t,e){return M(this,null,function*(){if(e!=null)for(let o of this.params.metrics)this.totals[o]!=null&&(typeof this.totals[o]=="number"?e[o]=this.totals[o]/this.seen:z(()=>{let n=R(ot(1,this.seen),this.totals[o]);e[o]=n,this.totals[o].dispose(),Oe(e[o])}))})}},Kh=class extends Ui{onTrainBegin(t){return M(this,null,function*(){this.epoch=[],this.history={}})}onEpochEnd(t,e){return M(this,null,function*(){e==null&&(e={}),this.epoch.push(t);for(let o in e)this.history[o]==null&&(this.history[o]=[]),this.history[o].push(e[o])})}syncData(){return M(this,null,function*(){let t=[],e=[],o=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let l=i[a];t.push(l.data()),e.push(s),o.push(a)}}let n=yield Promise.all(t);for(let s=0;s<n.length;++s)this.history[e[s]][o[s]].dispose(),this.history[e[s]][o[s]]=n[s][0]})}},qh=class extends Ui{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Sp,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=xM),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");y.isNumber(this.yieldEvery)&&(this.maybeWait=vT(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,o){return M(this,null,function*(){let n=[];this.yield!=null&&(yield Ts(o),n.push(this.yield(t,e,o))),n.push(this.nextFrameFunc()),yield Promise.all(n)})}onEpochBegin(t,e){return M(this,null,function*(){this.currentEpoch=t,this.epochBegin!=null&&(yield Ts(e),yield this.epochBegin(t,e))})}onEpochEnd(t,e){return M(this,null,function*(){let o=[];this.epochEnd!=null&&(yield Ts(e),o.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&o.push(this.nextFrameFunc()),yield Promise.all(o)})}onBatchBegin(t,e){return M(this,null,function*(){this.batchBegin!=null&&(yield Ts(e),yield this.batchBegin(t,e))})}onBatchEnd(t,e){return M(this,null,function*(){let o=[];this.batchEnd!=null&&(yield Ts(e),o.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?o.push(this.nextFrameFunc()):y.isNumber(this.yieldEvery)&&o.push(this.maybeWait(this.currentEpoch,t,e)),yield Promise.all(o)})}onTrainBegin(t){return M(this,null,function*(){this.trainBegin!=null&&(yield Ts(t),yield this.trainBegin(t))})}onTrainEnd(t){return M(this,null,function*(){this.trainEnd!=null&&(yield Ts(t),yield this.trainEnd(t))})}};function jh(r,t){return r==null&&(r={}),r instanceof Ui?[r]:Array.isArray(r)&&r[0]instanceof Ui?r:Kt(r).map(o=>new qh(o,t))}var Ir=class{constructor(){}static registerCallbackConstructor(t,e){y.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Ir.checkForDuplicate(e),Ir.constructors[t]==null&&(Ir.constructors[t]=[]),Ir.constructors[t].push(e)}static checkForDuplicate(t){for(let e in Ir.constructors)Ir.constructors[+e].forEach(n=>{if(n===t)throw new O("Duplicate callback constructor.")})}static clear(){Ir.constructors={}}static createCallbacks(t){let e=[];for(let o in Ir.constructors){let n=+o;t>=n&&e.push(...Ir.constructors[n])}return e.map(o=>new o)}};Ir.constructors={};function Xh(r,t,e,o,n,s,i,a,l){let u=new Kh,c=[new Yb,...Ir.createCallbacks(t)];r!=null&&c.push(...r),c.push(u);let p=new Hh(c);return p.setParams({epochs:e,initialEpoch:o,samples:n,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:l}),{callbackList:p,history:u}}function Lr(r,t={},e=!1){return on(r,H.SerializationMap.getMap().classNameMap,t,"layer",e)}function Vp(r,t){return z(()=>{r.dtype!=="float32"&&(r=Y(r,"float32"));let e=it(Ka(r),t,!0),o=fs(e.shape,ke()),n=ee(Fr(e,o));return ot(r,n)})}function Ya(r,t){return z(()=>se(Ka(ct(t,r)),-1))}function Wp(r,t){return z(()=>se(ve(ct(t,r)),-1))}function Up(r,t){return z(()=>{let e=ct(r,t),o=He(ve(r),ke(),Number.MAX_VALUE),n=ve(ot(e,o));return R(100,se(n,-1))})}function yM(r,t){return z(()=>{let e=He(t,ke(),Number.MAX_VALUE),o=mr(X(1,e)),n=He(r,ke(),Number.MAX_VALUE),s=mr(X(1,n));return se(Ka(ct(o,s)),-1)})}function bM(r,t){return z(()=>{let e=Fr(0,ct(1,R(r,t)));return se(Ka(e),-1)})}function wM(r,t){return z(()=>{let e=Fr(0,ct(1,R(r,t)));return se(e,-1)})}function CM(r,t){return z(()=>{let e=it(R(r,t),-1),o=Ke(R(ct(1,r),t),-1);return Fr(0,X(1,ct(o,e)))})}function IM(r,t){return z(()=>{let e=Math.log(2),o=ct(t,r),n=ct(X(o,tn(R(-2,o))),e);return se(n,-1)})}function Za(r,t,e=!1){return z(()=>{if(e)t=za(t);else{let o=it(t,t.shape.length-1,!0);t=ot(t,o)}return t=He(t,ke(),1-ke()),zt(it(R(Y(r,"float32"),mr(t)),t.shape.length-1))})}function Qu(r,t,e=!1){return z(()=>{let o=Y(gs(PT(r)),"int32");t=He(t,ke(),1-ke());let n=t.shape,s=F(ku(o,n[n.length-1]),n);return Za(s,t,e)})}function SM(r,t){if(!y.arraysEqual(r.shape,t.shape))throw new O(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return z(()=>{let e=Or(t),o=zt(ve(t));return X(ct(e,R(t,r)),ip(Ze(o)))})}function tc(r,t){return z(()=>{let e;return e=He(t,ke(),1-ke()),e=mr(ot(e,ct(1,e))),se(SM(r,e),-1)})}function NM(r,t){return z(()=>{let e=He(r,ke(),1),o=He(t,ke(),1);return it(R(r,mr(ot(e,o))),-1)})}function TM(r,t){return z(()=>{let e=mr(X(ke(),t));return se(ct(t,R(r,e)),-1)})}function Yh(r,t){return z(()=>{let e=Vp(r,-1),o=Vp(t,-1),n=R(e,o);return zt(it(n,-1))})}var Gp={meanSquaredError:Ya,meanAbsoluteError:Wp,meanAbsolutePercentageError:Up,meanSquaredLogarithmicError:yM,squaredHinge:bM,hinge:wM,categoricalHinge:CM,logcosh:IM,categoricalCrossentropy:Za,sparseCategoricalCrossentropy:Qu,binaryCrossentropy:tc,kullbackLeiblerDivergence:NM,poisson:TM,cosineProximity:Yh};function Zh(r){if(typeof r=="string"){if(r in Gp)return Gp[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new O(t)}else return r}function Qh(r,t){return z(()=>{let e=R(.5,Le(t)),o=ir(xe(t,e),r.dtype);return se(pr(r,o),-1)})}function td(r,t){return z(()=>ir(pr(ps(r,-1),ps(t,-1)),"float32"))}function vM(r,t){return z(()=>Y(it(nr(pr(r,1),pr(t,1))),"float32"))}function kM(r,t){return z(()=>Y(it(nr(pr(r,0),pr(t,1))),"float32"))}function tv(r,t){return z(()=>{let e=vM(r,t),o=kM(r,t),n=X(e,o);return Y(ne(xe(n,0),ot(e,n),0),"float32")})}function Zb(r,t){return tc(r,t)}function Jb(r,t){return r.rank===t.rank&&(r=Ao(r,[r.rank-1])),t=ps(t,-1),t.dtype!==r.dtype&&(t=Y(t,r.dtype)),Y(pr(r,t),"float32")}var EM=Ya,AM=Ya,$M=Wp,DM=Wp,RM=Up,FM=Up,ed=Za,_M=Yh,Qb=Qu,Jh={binaryAccuracy:Qh,categoricalAccuracy:td,precision:tv,categoricalCrossentropy:ed,sparseCategoricalCrossentropy:Qb,mse:EM,MSE:AM,mae:$M,MAE:DM,mape:RM,MAPE:FM,cosine:_M};function ev(r){if(typeof r=="string"&&r in Jh)return Jh[r];if(typeof r!="string"&&r!=null)return r;throw new O(`Unknown metric ${r}`)}function Hp(r){if(jr(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(Gp))if(Gp[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(Jh))if(Jh[e]===r){t=e;break}return t!==void 0?t:r.name}}function ov(r){let t={Adagrad:()=>Ua.adagrad(.01),Adadelta:()=>Ua.adadelta(1,.95,ke()),Adam:()=>Ua.adam(.001,.9,.999,ke()),Adamax:()=>Ua.adamax(.002,.9,.999,ke(),0),RMSProp:()=>Ua.rmsprop(.001,.9,0,ke()),SGD:()=>Ua.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new O(`Unknown Optimizer ${r}`)}function ew(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!tw(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let o=JSON.stringify(r);o.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${o.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function tw(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!tw(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!tw(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function nv(r,t,e,o=console.log){let n=PM(r),s=["Layer (type)","Input Shape","Output shape","Param #"];n?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let i;if(!n){s.push("Receives inputs"),i=[];for(let c in r.nodesByDepth)i.push(...r.nodesByDepth[c])}o("_".repeat(t)),rd(s,e,o),o("=".repeat(t));let a=r.layers;for(let c=0;c<a.length;++c)n?zM(a[c],e,o):MM(a[c],e,i,o),o((c===a.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let l=LM(r),u=Zu(r.nonTrainableWeights);o(`Total params: ${l+u}`),o(`Trainable params: ${l}`),o(`Non-trainable params: ${u}`),o("_".repeat(t))}function LM(r){let t;return r.collectedTrainableWeights!=null?t=Zu(r.collectedTrainableWeights):t=Zu(r.trainableWeights),t}function PM(r){let t=!0,e=[],o=[];for(let n in r.nodesByDepth)e.push(r.nodesByDepth[n]);for(let n of e){if(n.length>1||n.length===1&&n[0].inboundLayers.length>1){t=!1;break}o.push(...n)}if(t)for(let n of r.layers){let s=!1;for(let i of n.inboundNodes)if(o.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function rd(r,t,e=console.log){let o="";for(let n=0;n<r.length;++n)n>0&&(o=o.slice(0,o.length-1)+" "),o+=r[n],o=o.slice(0,t[n]),o+=" ".repeat(t[n]-o.length);e(o)}function zM(r,t,e){let o,n;try{n=r.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch(l){n="multiple"}try{o=JSON.stringify(r.outputShape)}catch(l){o="multiple"}let s=r.name,i=r.getClassName(),a=[`${s} (${i})`,n,o,r.countParams().toString()];rd(a,t,e)}function MM(r,t,e,o){let n,s;try{s=r.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch(p){s="multiple"}try{n=JSON.stringify(r.outputShape)}catch(p){n="multiple"}let i=[];for(let p of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){let f=p.inboundLayers[m].name,h=p.nodeIndices[m],d=p.tensorIndices[m];i.push(`${f}[${h}][${d}]`)}let a=r.name,l=r.getClassName(),u=i.length===0?"":i[0],c=[`${a} (${l})`,s,n,r.countParams().toString(),u];rd(c,t,o);for(let p=1;p<i.length;++p)rd(["","","","",i[p]],t,o)}function sv(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function Kp(r,t){if(r===null)return null;if(typeof r=="string")return Cs(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],o=r.length;for(let n=0;n<o;++n){let s=r[n];sv(t,n,s)?e.push(s):e.push(Kp(s,t))}return e}else{let e={};for(let o of Object.keys(r)){let n=r[o];if(o==="name"&&typeof n=="string")e[o]=n;else{let s=Cs(o);e[s]=Kp(n,s)}}return e}}function od(r,t){if(r==null)return null;if(typeof r=="string")return co(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],o=r.length;for(let n=0;n<o;++n){let s=r[n];sv(t,n,s)?e.push(s):e.push(od(s,t))}return e}else{let e={};for(let o of Object.keys(r)){let n=r[o],s=co(o);(o==="name"||o==="className")&&typeof n=="string"?e[s]=n:e[s]=od(n,o)}return e}}var ec="4.2.0";var Pr=class extends Ct{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=Gi(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],po(this.inputs).length!==this.inputs.length)throw new O(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);po(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let C=b.sourceLayer,w=b.nodeIndex,I=b.tensorIndex;this.outputLayers.push(C),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(I)}for(let b of this.inputs){let C=b.sourceLayer,w=b.nodeIndex,I=b.tensorIndex;jr(w===0,"input layer has >1 nodes"),jr(I===0,"input layer has >1 tensors"),this.inputLayers.push(C),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let C=this.inputLayers[b];if(!(C instanceof sn))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${C.getClassName()}.`);this.inputNames.push(C.name),this.feedInputShapes.push(C.batchInputShape),this.feedInputNames.push(C.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let e={},o={},n={},s={},i={},a=[],l=(b,C,w,I,E,A)=>{(I==null||E==null||A==null)&&(I=b.sourceLayer,E=b.nodeIndex,A=b.tensorIndex);let $=I.inboundNodes[E];if(w.indexOf($)!==-1)throw new er(`The tensor ${b.name} at layer "${I.name}" is part of a cycle.`);if(C.indexOf($)!==-1)return;this.containerNodes.add(Pr.nodeKey(I,E)),I.id in i||(i[I.id]=Object.keys(i).length),w.indexOf($)===-1&&w.push($);let _=$.inboundLayers.length;for(let L=0;L<_;L++){let B=$.inputTensors[L],V=$.inboundLayers[L],G=$.nodeIndices[L],U=$.tensorIndices[L];l(B,C,w,V,G,U)}for(C.push($);w.indexOf($)>=0;)w.splice(w.indexOf($),1);a.push($)},u=[],c=[];for(let b of this.outputs)l(b,u,c);let p=a.slice().reverse();for(let b of p){o[b.id]=b,b.id in e||(e[b.id]=0);let C=e[b.id],w=n[b.outboundLayer.id]==null?0:n[b.outboundLayer.id];C=Math.max(C,w),n[b.outboundLayer.id]=C,s[b.outboundLayer.id]=b.outboundLayer,e[b.id]=C;for(let I=0;I<b.inboundLayers.length;I++){let E=b.inboundLayers[I],A=b.nodeIndices[I],$=E.inboundNodes[A],_=e[$.id]==null?0:e[$.id];e[$.id]=Math.max(C+1,_),o[$.id]=$}}let m={};for(let b in e){let C=e[b];C in m||(m[C]=[]),m[C].push(o[b])}let f={};for(let b in n){let C=n[b];C in f||(f[C]=[]),f[C].push(s[b])}let h=Object.keys(f).map(b=>parseInt(b,10)).sort(Tp);this.layers=[];for(let b of h){let C=f[b];C.sort((w,I)=>{let E=i[w.id],A=i[I.id];return E<A?-1:E>A?1:0});for(let w of C)w instanceof Pr&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=f,h=Object.keys(m).map(b=>parseInt(b,10)).sort(Tp);let d=this.inputs.slice(),g=[];for(let b of h)for(let C of m[b]){let w=C.outboundLayer;if(w!=null){for(let I of C.inputTensors)if(d.indexOf(I)===-1)throw new er(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(let I of C.outputTensors)d.push(I);g.push(w.name)}}this.nodesByDepth=m;let x=this.layers.map(b=>b.name);for(let b of x){let C=x.filter(w=>w===b).length;if(C!==1)throw new er(`The name "${b}" is used ${C} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new Ns({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(o=>o.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new O("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let o of this.layers)e.push(...o.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let o={},n=0;for(let i of this.layers)for(let a of i.weights){if(o[a.originalName]!=null)throw new O(`Duplicate weight name: ${a.originalName}`);o[a.originalName]=a,n++}let s=[];for(let i in t){let a=i;if(o[i]==null){let l=i.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(o[a]!=null)s.push([o[a],t[i]]);else if(e)throw new O(`Provided weight data has no target variable: ${i}`);delete o[a]}if(e){let i=[];for(let a in o)i.push(a);if(i.length>0)throw new O(`${i.length} of ${n} weights are not set: ${i}`)}Ju(s)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${ec}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let o=od(this.updatedConfig());return e?JSON.stringify(o):o}call(t,e){return z(()=>{t=Kt(t);let o=new ho;for(let n=0;n<this.inputs.length;++n)o.add(this.inputs[n],t[n]);return ja(this.outputs,o,e)})}computeMask(t,e){return z(()=>{t=Kt(t);let o;return e==null?o=uo(null,t.length):o=Kt(e),this.runInternalGraph(t,o)[1]})}computeOutputShape(t){let e=Yu(t);if(e.length!==this.inputLayers.length)throw new O(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let o={};for(let a=0;a<e.length;a++){let l=this.inputLayers[a],u=e[a],c=l.name+"_0_0";o[c]=u}let n=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Tp);if(n.length>1)for(let a of n){let l=this.nodesByDepth[a];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(d=>d.id).indexOf(c.id)!==-1)continue;let p=[];for(let d=0;d<u.inboundLayers.length;d++){let g=u.inboundLayers[d],x=u.nodeIndices[d],b=u.tensorIndices[d],C=`${g.name}_${x}_${b}`,w=o[C];p.push(w)}let m=c.computeOutputShape(ze(p)),f=Yu(m),h=c.inboundNodes.indexOf(u);for(let d=0;d<f.length;d++){let g=`${c.name}_${h}_${d}`;o[g]=f[d]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${l.name}_${u}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let l=i[a];jr(l in o),s.push(o[l])}return ze(s)}runInternalGraph(t,e){e==null&&(e=uo(null,t.length));let o={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=t[l],p=e[l];o[u.id]=[c,p]}let n=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Tp);for(let l of n){let u=this.nodesByDepth[l];for(let c of u){let p=c.outboundLayer,m=c.inputTensors,f=c.outputTensors,h=new Array;for(let d of m)d.id in o&&h.push(o[d.id]);if(h.length===m.length){let d={},g,x,b,C;if(c.callArgs!=null&&(d=c.callArgs),h.length===1){let[w,I]=h[0];d.mask==null&&(d.mask=I),b=Kt(p.call(w,d)),C=Kt(p.computeMask(w,I)),g=[w],x=[I]}else g=h.map(w=>w[0]),x=h.map(w=>w[1]),d.mask==null&&(d.mask=x),b=Kt(p.call(g,d)),C=Kt(p.computeMask(g,x));if(p.activityRegularizer)throw new dt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<f.length;++w){let I=f[w],E=b[w],A=C[w];o[I.id]=[E,A]}}}}let s=[],i=[],a=[];for(let l of this.outputs){jr(l.id in o,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=o[l.id];a.push(u.shape),s.push(u),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let e={},o;for(let n of this.layers){o=n instanceof Pr?1:0;for(let s=0;s<n.inboundNodes.length;s++){let i=Pr.nodeKey(n,s);this.containerNodes.has(i)&&(e[i]=o,o+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new O(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new O("Provide either a layer name or layer index");for(let o of this.layers)if(o.name===t)return o;throw new O(`No such layer: ${t}`)}calculateLosses(){return z(()=>{let t=[];for(let e of this.layers)for(let o=0;o<e.inboundNodes.length;++o){let n=Pr.nodeKey(e,o);this.containerNodes.has(n)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),o=[];for(let i of this.layers){let a=i.getClassName(),l=i.getConfig(),u=[];for(let p=0;p<i.inboundNodes.length;p++){let m=i.inboundNodes[p],f=Pr.nodeKey(i,p),h={};if(this.containerNodes.has(f)){if(m.callArgs)try{JSON.stringify(m.callArgs),h=m.callArgs}catch(d){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(m.inboundLayers.length>0){let d=[];for(let g=0;g<m.inboundLayers.length;g++){let x=m.inboundLayers[g],b=m.nodeIndices[g],C=m.tensorIndices[g],w=Pr.nodeKey(x,b),I=e[w];I==null&&(I=0),d.push([x.name,I,C,h])}u.push(d)}}}let c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,o.push(c)}t.layers=o;let n=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Pr.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];n.push([a.name,c,p])}t.inputLayers=n;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Pr.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,e,o={},n=!1){let s={},i={};function a(g,x){g.name in i?i[g.name].push(x):i[g.name]=[x]}function l(g,x){let b=[],C;for(let w of x){let I=w[0],E=w[1],A=w[2];if(C=w[3]==null?{}:w[3],!(I in s)){a(g,x);return}let $=s[I];if($.inboundNodes.length<=E){a(g,x);return}let _=$.inboundNodes[E];b.push(_.outputTensors[A])}b.length>0&&g.apply(ze(b),C)}function u(g){let x=g.name,b=Lr(g,e.customObjects!=null?e.customObjects:{});b.setFastWeightInitDuringBuild(n),s[x]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new O(`Corrupted configuration, expected array for nodeData: ${w}`);a(b,w)})}let c=e.name,p=e.layers;for(let g of p)u(g);for(;!NT(i);)for(let g of p){let x=s[g.name];if(x.name in i){let b=i[x.name];delete i[x.name];for(let C of b)l(x,C)}}let m=[],f=[],h=e.inputLayers;for(let g of h){let x=g[0],b=g[1],C=g[2];jr(x in s);let I=s[x].inboundNodes[b].outputTensors;m.push(I[C])}let d=e.outputLayers;for(let g of d){let x=g[0],b=g[1],C=g[2];jr(x in s);let I=s[x].inboundNodes[b].outputTensors;f.push(I[C])}return new t({inputs:m,outputs:f,name:c})}get stateful(){if(this._stateful)throw new O("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){z(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function BM(r,t,e){let o=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>null);if(o===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==o)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${o} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let n=[];return t.forEach(s=>{s in r?n.push(r[s]):n.push(null)}),n}else throw new Error(`The model has multiple (${o}) outputs, so ${e} must be either an array with ${o} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function nd(r,t){return BM(r,t,"classWeight")}function sd(r,t,e,o){return M(this,null,function*(){if(t!=null||o!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let n=z(()=>{if(r.shape.length===1)return $r(r);if(r.shape.length===2){if(r.shape[1]>1)return ps(r,1);if(r.shape[1]===1)return F(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield n.data());wt(n);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),$e(i,"float32")}else return null})}function iv(r,t){return R(r,t)}var VM=32;function uv(r,t){let e,o,n=t;e=n.xs,o=n.ys,y.assert(e!=null&&o!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=av("input",r.inputNames,e),i=av("output",r.outputNames,o),a=s[0].shape[0];y.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),y.assert(i.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let l=0;l<s.length;l++)y.assert(s[l].shape[0]===a,()=>`Batch size mismatch: input ${r.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);for(let l=0;l<i.length;l++)y.assert(i[l].shape[0]===a,()=>`Batch size mismatch: output ${r.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);return{xs:s,ys:i}}function av(r,t,e){if(e instanceof _t)return[e];if(Array.isArray(e))return y.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let o=[];for(let n of t){if(e[n]==null)throw new O(`The feature data generated by the dataset lacks the required ${r} key '${n}'.`);o.push(e[n])}return o}}function GM(r){if(r.length===3)throw new dt("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}function cv(r,t,e){return M(this,null,function*(){let o=e.batchesPerEpoch!=null;if(y.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),y.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),y.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),y.assert(!o||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),y.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let n=e.validationData!=null,s,i;if(n)if(lv(e.validationData))y.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=GM(e.validationData);s=g.xs,i=g.ys}let a=r.makeTrainFunction(),l=r.getDedupedMetricsNames(),u;n?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();let c=jh(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:f}=Xh(c,p,e.epochs,null,null,WM(t,e),null,n,u);m.setModel(r),r.history=f,yield m.onTrainBegin(),r.stopTraining_=!1;let h=e.initialEpoch==null?0:e.initialEpoch,d=yield t.iterator();for(;h<e.epochs;){let g={};yield m.onEpochBegin(h);let x=0,b=0;for(o||(d=yield t.iterator());!o||x<e.batchesPerEpoch;){let C=yield d.next();if(o&&C.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(C.value!=null){let{xs:w,ys:I}=uv(r,C.value),E={};E.batch=b,E.size=w[0].shape[0],yield m.onBatchBegin(b,E);let A=[];if(e.classWeight!=null){let L=nd(e.classWeight,r.outputNames);for(let B=0;B<L.length;++B)A.push(yield sd(I[B],null,L[B]))}let $=w.concat(I).concat(A),_=a($);wt($);for(let L=0;L<l.length;++L){let B=l[L],V=_[L];E[B]=V,Oe(V)}yield m.onBatchEnd(b,E),Uh(E),b++,x++}if(o?x>=e.batchesPerEpoch:C.done){if(n){let w;lv(e.validationData)?w=Kt(yield r.evaluateDataset(e.validationData,{batches:e.validationBatches})):w=Kt(r.evaluate(s,i,{batchSize:e.validationBatchSize==null?VM:e.validationBatchSize,verbose:0}));for(let I=0;I<r.metricsNames.length;++I)g[`val_${r.metricsNames[I]}`]=w[I]}break}if(r.stopTraining_)break}if(yield m.onEpochEnd(h,g),h++,r.stopTraining_)break}return yield m.onTrainEnd(),yield r.history.syncData(),r.history}finally{r.isTraining=!1}})}function WM(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function lv(r){return typeof r.iterator=="function"}function UM(r){return typeof r.next=="function"}function pv(r,t,e){return M(this,null,function*(){e=e||{};let o=e.batches!=null,n=r.testFunction,s=[];if(e.verbose>0)throw new dt("Verbose mode is not implemented yet.");y.assert(!o||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=UM(t)?t:yield t.iterator(),a=0,l=0;for(;!o||l<e.batches;){let u=yield i.next();if(s=z(()=>{if(u.value){let{xs:c,ys:p}=uv(r,u.value),m=c.concat(p),f=z(()=>n(m));if(wt(m),l===0)for(let d=0;d<f.length;++d)s.push(xt(0));let h=m[0].shape[0];for(let d=0;d<f.length;++d){let g=f[d],x=s[d];s[d]=z(()=>X(s[d],R(h,g))),l>0&&wt(x)}wt(f),a+=h,++l}return s}),u.done){o&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let c=s[u];s[u]=ot(s[u],a),wt(c)}return ze(s)})}function id(r){y.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function rc(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(o=>Is(o,t,e-t)):Is(r,t,e-t)}function ad(r,t){return z(()=>r==null?null:Array.isArray(r)?r.map(e=>ad(e,t)):Mh(r,t.dtype==="int32"?t:Y(t,"int32")))}function ld(r,t){let e=[],o=0,n=null;for(;o<r;)n=o+t,n>=r&&(n=r),e.push([o,n]),o=n;return e}function rw(r){let t=[];r instanceof _t&&(r=[r]);for(let e=0;e<r.length;++e){let o=r[e];if(o.rank===1)t.push(Ss(o,1));else{if(o.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(o)}}return t}function go(r,t){if(r==null)return;let e=[];if(t instanceof _t)e.push(t.id);else if(Array.isArray(t))t.forEach(n=>e.push(n.id));else if(t!=null)for(let n in t){let s=t[n];e.push(s.id)}let o=[];if(r instanceof _t)e.indexOf(r.id)===-1&&o.push(r);else if(Array.isArray(r))r.forEach(n=>{e.indexOf(n.id)===-1&&o.push(n)});else if(r!=null)for(let n in r){let s=r[n];e.indexOf(s.id)===-1&&o.push(s)}o.forEach(n=>{n.isDisposed||n.dispose()})}function HM(r){return r instanceof _t}function ow(r){return Array.isArray(r)}function mv(r){return!HM(r)&&!ow(r)}function fv(r,t,e,o=!0,n=""){if(t==null||t.length===0){if(r!=null){let i=!1;if(ow(r)&&r.length>0)i=!0;else if(mv(r)){for(let a in r)if(r.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new O(`Error when checking model ${n} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(i=>null);let s;if(mv(r)){r=r,s=[];for(let i of t){if(r[i]==null)throw new O(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(r[i])}}else if(ow(r)){if(r=r,r.length!==t.length)throw new O(`Error when checking model ${n}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,t.length>1)throw new O(`The model ${n} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=rw(s),e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new O(`Error when checking ${n}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(l===0&&!o)continue;let u=a.shape[l],c=e[i][l];if(c!=null&&c>=0&&u!==c)throw new O(`${n} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${n} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function KM(r,t,e){let o=po(r.map(s=>s.shape[0]));o.sort();let n=po(t.map(s=>s.shape[0]));if(n.sort(),o.length>1)throw new O(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(n.length>1)throw new O(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(o.length>0&&n.length>0&&!y.arraysEqual(o,n))throw new O(`Input Tensors should have the same number of samples as target Tensors. Found ${o[0]} input sample(s) and ${n[0]} target sample(s).`)}function qM(r,t,e){let o=[Ya,tc,Za];for(let n=0;n<r.length;++n){let s=r[n],i=t[n],a=e[n];if(i!=null){if(i===Za&&s.shape[s.shape.length-1]===1)throw new O(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(o.indexOf(i)!==-1){let l=s.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){let p=l[c],m=u[c];if(m!=null&&p!==m)throw new O(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function hv(r,t,e,o=!0,n=""){let s;if(Array.isArray(r)){if(r.length!==t.length)throw new O(`Error when checking model ${n}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(t.length>1)throw new O(`The model expects ${t.length} ${n} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new O(`Error when checking ${n}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(l===0&&!o)continue;let u=a.shape[l],c=e[i][l];if(c!=null&&c!==u)throw new O(`Error when checking ${n}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function jM(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(o=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(o=>e);{let o=[];for(let n of t){let s=e.hasOwnProperty(n)?e[n]:[];Array.isArray(s)||(s=[s]),o.push(s)}return o}}var XM="layers-model",xo=class extends Pr{constructor(t){super(t),this.isTraining=!1}summary(t,e,o=console.log){if(!this.built)throw new O("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");nv(this,t,e,o)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=ov(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Qe))throw new O("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new O(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),e.push(Zh(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new O(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>Zh(a))}else{let i=Zh(t.loss);this.outputs.forEach(a=>{e.push(i)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let a=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}let o=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Fo("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(o.indexOf(i)!==-1)continue;let a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let n=jM(t.metrics,this.outputNames),s=(i,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,i])};Fo("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(o.indexOf(i)!==-1)continue;let a=n[i];(u=>{let c="",p,m,f;for(let h of u){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===tc?["accuracy","acc"].indexOf(h)!==-1?m=Qh:["crossentropy","ce"].indexOf(h)!==-1&&(m=Zb):this.lossFunctions[i]===Qu?["accuracy","acc"].indexOf(h)!==-1?m=Jb:["crossentropy","ce"].indexOf(h)!==-1&&(m=Qb):["accuracy","acc"].indexOf(h)!==-1?m=td:["crossentropy","ce"].indexOf(h)!==-1&&(m=ed);let x;["accuracy","acc"].indexOf(h)!==-1?x="acc":["crossentropy","ce"].indexOf(h)!==-1&&(x="ce"),f=m,p=c+x}else f=ev(h),p=c+Hp(h);let d;Fo(p,()=>{d=f}),s(i,p,d)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,o={}){let n=o.batchSize==null?32:o.batchSize;id(n);let s=!0,i=this.standardizeUserDataXY(t,e,s,n);try{let a=i[0].concat(i[1]);this.makeTestFunction();let l=this.testFunction,u=this.testLoop(l,a,n,o.verbose,o.steps);return ze(u)}finally{go(i[0],t),go(i[1],e)}}evaluateDataset(t,e){return M(this,null,function*(){return this.makeTestFunction(),pv(this,t,e)})}checkNumSamples(t,e,o,n="steps"){let s;if(o!=null){if(s=null,e!=null)throw new O(`If ${n} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new O(`Either the input data should have a defined shape, or ${n} shoud be specified.`);return s}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new O("`outputs` is an empty Array, which is not allowed.");let o=Array.isArray(e),n=o?e:[e],s=this.retrieveSymbolicTensors(n),i=new ho;if(t instanceof _t&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new O(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],t[l])}else for(let l of this.inputs){let u=t[l.name];if(u==null)throw new O(`No value is provided for the model's input ${l.name}`);i.add(l,u)}let a=ja(s,i);return o?a:a[0]}retrieveSymbolicTensors(t){let e=uo(null,t.length),o=t.length;for(let n of this.layers){let s=Array.isArray(n.output)?n.output:[n.output],i=s.map(a=>a.name);for(let a=0;a<t.length;++a){let l=i.indexOf(t[a]);if(l!==-1&&(e[a]=s[l],o--),o===0)break}if(o===0)break}if(o>0){let n=[];throw e.forEach((s,i)=>{s==null&&n.push(t[i])}),new O(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,o=!1){return z(()=>{let n=this.checkNumSamples(t);if(o)throw new dt("Verbose predictLoop() is not implemented yet.");let s=ld(n,e),i=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)z(()=>{let u=s[a][0],c=s[a][1],p=rc(t,u,c),m=[];if(Array.isArray(p))for(let h=0;h<p.length;++h)m.push({key:this.inputs[h],value:p[h]});else m.push({key:this.inputs[0],value:p});let f=new ho(m);return ja(this.outputs,f)}).forEach((u,c)=>i[c].push(u));return ze(i.map(a=>te(a,0)))})}predict(t,e={}){let o=rw(t);hv(o,this.inputNames,this.feedInputShapes,!1);try{let n=e.batchSize==null?32:e.batchSize;return id(n),this.predictLoop(o,n)}finally{go(o,t)}}predictOnBatch(t){hv(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,o=!0,n){if(this.optimizer_==null)throw new er("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let i=0;i<this.feedOutputShapes.length;++i){let a=this.feedOutputShapes[i];this.feedLossFns[i]===Qu?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(t=fv(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=fv(e,this.feedOutputNames,s,!1,"target"),KM(t,e,null),qM(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&n!=null&&n>0&&t[0].shape[0]%n!==0)throw new O(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}standardizeUserData(t,e,o,n,s=!0,i){return M(this,null,function*(){let[a,l]=this.standardizeUserDataXY(t,e,s,i);if(o!=null)throw new Error("sample weight is not supported yet.");let u=null;if(n!=null){let c=nd(n,this.outputNames);u=[];for(let p=0;p<c.length;++p)u.push(yield sd(l[p],null,c[p]))}return[a,l,u]})}testLoop(t,e,o,n=0,s){return z(()=>{let i=this.checkNumSamples(e,o,s,"steps"),a=[];if(n>0)throw new dt("Verbose mode is not implemented yet.");if(s!=null)throw new dt("steps mode in testLoop() is not implemented yet");{let l=ld(i,o),u=$e(hr(0,i));for(let c=0;c<l.length;++c){let p=l[c][0],m=l[c][1],f=Is(u,p,m-p),h=ad(e,f),d=t(h);if(c===0)for(let g=0;g<d.length;++g)a.push(xt(0));for(let g=0;g<d.length;++g){let x=d[g];a[g]=X(a[g],R(m-p,x))}}for(let c=0;c<a.length;++c)a[c]=ot(a[c],i)}return a})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let o=0;o<t.length;++o){let n=t[o],s=n;if(Vb(t,n)>1){let i=Vb(t.slice(0,o),n);s+=`_${i}`}e.push(s)}return e}makeTrainFunction(){return t=>{let e=[],o=t.slice(0,this.inputs.length),n=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{let p=[];for(let d=0;d<this.inputs.length;++d)p.push({key:this.inputs[d],value:o[d]});let m=new ho(p),f=ja(this.outputs,m,{training:!0}),h;for(let d=0;d<this.lossFunctions.length;++d){let g=this.lossFunctions[d],x=g(n[d],f[d]);s[d]!=null&&(x=iv(x,s[d]));let b=se(x);e.push(b),d===0?h=x:h=X(h,x)}for(let d=0;d<this.metricsTensors.length;++d){let g;if(this.outputs.length>1&&d<this.outputs.length)g=e[d];else{let x=this.metricsTensors[d][0],b=this.metricsTensors[d][1];g=se(x(n[b],f[b]))}Oe(g),i.push(g)}return h=se(h),this.calculateLosses().forEach(d=>{h=X(h,d)}),h},l=this.collectedTrainableWeights.map(p=>p.read()),u=!0;return[this.optimizer_.minimize(a,u,l)].concat(i)}}makeTestFunction(){this.testFunction=t=>z(()=>{let e=[],o,n=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:n[u]});let a=new ho(i),l=ja(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){let c=this.lossFunctions[u],p=se(c(s[u],l[u]));u===0?o=p:o=X(o,p),e.push(o)}for(let u=0;u<this.metricsTensors.length;++u){let c=this.metricsTensors[u][0],p=this.metricsTensors[u][1],m=se(c(s[p],l[p]));e.push(m)}return e})}fit(n,s){return M(this,arguments,function*(t,e,o={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,a,l,u,c,p,m,f,h;try{let d=o.batchSize==null?32:o.batchSize;id(d);let g=!1,x=yield this.standardizeUserData(t,e,o.sampleWeight,o.classWeight,g,d);i=x[0],a=x[1],h=x[2];let b=!1,C;if(o.validationData!=null&&o.validationData.length>0){if(b=!0,o.validationData.length===2)c=o.validationData[0],p=o.validationData[1];else throw o.validationData.length===3?new dt("validationData including sample weights is not supported yet."):new O(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${o.validationData} is invalid.`);let B=!0,V=yield this.standardizeUserData(c,p,null,null,B,d);m=V[0],f=V[1],C=m.concat(f)}else if(o.validationSplit!=null&&o.validationSplit>0&&o.validationSplit<1){b=!0;let B=Math.floor(i[0].shape[0]*(1-o.validationSplit)),V=i[0].shape[0];m=rc(i,B,V),l=i,i=rc(i,0,B),f=rc(a,B,V),u=a,a=rc(a,0,B),C=m.concat(f)}else o.validationSteps!=null&&(b=!0);let w=i.concat(a).concat(h);this.checkTrainableWeightsConsistency();let I=this.makeTrainFunction(),E=this.getDedupedMetricsNames(),A,$;b?(this.makeTestFunction(),A=this.testFunction,$=E.slice().concat(E.map(B=>"val_"+B))):(A=null,C=[],$=E.slice());let _=jh(o.callbacks,o.yieldEvery);return yield this.fitLoop(I,w,E,d,o.epochs,o.verbose,_,A,C,o.shuffle,$,o.initialEpoch,null,null)}finally{this.isTraining=!1,go(i,t),go(a,e),go(l,t),go(u,e),go(m,c),go(f,p),h!=null&&wt(h)}})}fitLoop(t,e,o,n,s,i,a,l,u,c,p,m,f,h){return M(this,null,function*(){n==null&&(n=32),s==null&&(s=1),c==null&&(c=!0),m==null&&(m=0);let d=!1;if(l!=null&&u!=null&&(d=!0),h!=null&&(d=!0,f==null))throw new O("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(e,n,f,"steps_per_epoch"),x;g!=null&&(x=hr(0,g)),i==null&&(i=1);let{callbackList:b,history:C}=Xh(a,i,s,m,g,f,n,d,p);b.setModel(this),this.history=C,yield b.onTrainBegin(),this.stopTraining_=!1;for(let w=m;w<s;++w){yield b.onEpochBegin(w);let I={};if(f!=null)throw new dt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new dt("batch shuffling is not implemneted yet");c&&y.shuffle(x);let E=$e(x),A=ld(g,n);for(let $=0;$<A.length;++$){let _={};if(yield b.onBatchBegin($,_),z(()=>{let L=A[$][0],B=A[$][1],V=Is(E,L,B-L);_.batch=$,_.size=B-L;let G=ad(e,V),U=t(G);for(let W=0;W<o.length;++W){let q=o[W],Z=U[W];_[q]=Z,Oe(Z)}if($===A.length-1&&d){let W=this.testLoop(l,u,n);for(let q=0;q<o.length;++q){let Z=o[q],K=W[q];Oe(K),I["val_"+Z]=K}}}),yield b.onBatchEnd($,_),Uh(_),this.stopTraining_)break}E.dispose()}if(yield b.onEpochEnd(w,I),this.stopTraining_)break}return yield b.onTrainEnd(),yield this.history.syncData(),this.history})}fitDataset(t,e){return M(this,null,function*(){return cv(this,t,e)})}trainOnBatch(t,e){return M(this,null,function*(){let o=yield this.standardizeUserData(t,e),n=o[0],s=o[1],a=this.makeTrainFunction()(n.concat(s)),l=[];for(let u of a){let c=yield u.data();l.push(c[0])}return wt(a),go(o[0],t),go(o[1],e),ze(l)})}getNamedWeights(t){let e=[],o=t!=null&&t.trainableOnly,n=o?this.trainableWeights:this.weights,s=this.getWeights(o);for(let i=0;i<n.length;++i)o&&!n[i].trainable||e.push({name:n[i].originalName,tensor:s[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=Zc().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-Zc().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=co(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>co(e))}else{let e=Object.keys(this.loss);t={};let o=this.loss;for(let n of e)if(typeof o[n]=="string")t[n]=co(o[n]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[co(Hp(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>co(Hp(t)));{let t={};for(let e in this.metrics)t[e]=co(Hp(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=Kp(t.optimizer_config),o=Lr(e),n;if(typeof t.loss=="string")n=Cs(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(i=>Cs(i));else if(t.loss!=null){n={};for(let i in t.loss)n[i]=Cs(t.loss[i])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(i=>Cs(i));else if(t.metrics!=null){s={};for(let i in t.metrics)s[i]=Cs(t.metrics[i])}this.compile({loss:n,metrics:s,optimizer:o})}save(t,e){return M(this,null,function*(){if(typeof t=="string"){let u=ws.getSaveHandlers(t);if(u.length===0)throw new O(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new O(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new O("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let o=yield ws.encodeWeights(this.getNamedWeights(e)),n=!1,s=null,a={modelTopology:this.toJSON(s,n),format:XM,generatedBy:`TensorFlow.js tfjs-layers v${ec}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let u="optimizer",{data:c,specs:p}=yield ws.encodeWeights(yield this.optimizer.getWeights(),u);o.specs.push(...p),o.data=ws.concatenateArrayBuffers([o.data,c])}return this.userDefinedMetadata!=null&&(ew(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=o.data,a.weightSpecs=o.specs,t.save(a)})}setUserDefinedMetadata(t){ew(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};xo.className="Model";H.registerClass(xo);var ud=class extends xo{};ud.className="Functional";H.registerClass(ud);var Oo=class extends xo{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Gi("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(o=>o<0))throw new O(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Oo||t instanceof xo,o;if(e){if(o=t,o.outputs.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(o.inputs.length!==1)throw new O("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new O("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let n=jb({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(n)}if(e)this.outputs=o.outputs,this.inputs=o.inputs;else{if(t.inboundNodes.length!==1)throw new O(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=qb(this.outputs[0])}this.inboundNodes=[],new Ns({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:uo(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(n=>n.shape),outputShapes:this.outputs[0].shape})}else{let n=t.apply(this.outputs[0]);if(Array.isArray(n))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[n],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(kt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new xo({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,o=console.log){this.built||this.build(),super.summary(t,e,o)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,o={}){if(!this.built)throw new er("The model needs to be compiled before being used.");return this.model.evaluate(t,e,o)}evaluateDataset(t,e){return M(this,null,function*(){if(!this.built)throw new er("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)})}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}fit(n,s){return M(this,arguments,function*(t,e,o={}){if(!this.built)throw new er("The model needs to be compiled before being used.");return this.model.fit(t,e,o)})}fitDataset(t,e){return M(this,null,function*(){if(!this.built)throw new er("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)})}trainOnBatch(t,e){return M(this,null,function*(){return this.model.trainOnBatch(t,e)})}static fromConfig(t,e,o={},n=!1){let s,i={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new O("Legacy serialization format not supported yet.");s=e}else y.assert(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,i=e;let a=new t(i);if(!(a instanceof Oo))throw new dt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let l of s){let c=Lr(l,void 0,n);n&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new O("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new O("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let o={};o.className=e.getClassName(),o.config=e.getConfig(),t.push(o)}return{name:this.name,layers:t}}};Oo.className="Sequential";H.registerClass(Oo);var ur=class extends H.Serializable{getConfig(){return{}}},cd=class extends ur{apply(t,e=1){return MT(t,e)}};cd.className="elu";H.registerClass(cd);var pd=class extends ur{apply(t){return pp(t)}};pd.className="selu";H.registerClass(pd);var md=class extends ur{apply(t){return Or(t)}};md.className="relu";H.registerClass(md);var fd=class extends ur{apply(t){return z(()=>Fa(6,Or(t)))}};fd.className="relu6";H.registerClass(fd);var hd=class extends ur{apply(t){return t}};hd.className="linear";H.registerClass(hd);var dd=class extends ur{apply(t){return no(t)}};dd.className="sigmoid";H.registerClass(dd);var gd=class extends ur{apply(t){return VT(t)}};gd.className="hardSigmoid";H.registerClass(gd);var xd=class extends ur{apply(t){return tn(t)}};xd.className="softplus";H.registerClass(xd);var yd=class extends ur{apply(t){return BT(t)}};yd.className="softsign";H.registerClass(yd);var bd=class extends ur{apply(t){return wu(t)}};bd.className="tanh";H.registerClass(bd);var oc=class extends ur{apply(t,e=-1){return za(t,e)}};oc.className="softmax";H.registerClass(oc);var wd=class extends ur{apply(t,e=-1){return ap(t,e)}};wd.className="logSoftmax";H.registerClass(wd);var Cd=class extends ur{apply(t,e=1){return z(()=>R(no(R(t,e)),t))}};Cd.className="swish";H.registerClass(Cd);var Id=class extends ur{apply(t){return z(()=>R(t,wu(tn(t))))}};Id.className="mish";H.registerClass(Id);function Lo(r){return r.getClassName()}function nw(r,t={}){return on(r,H.SerializationMap.getMap().classNameMap,t,"activation")}function Po(r){if(r==null){let t={};return t.className="linear",t.config={},nw(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},nw(t)}else return r instanceof ur?r:nw(r)}function ZM(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var Sd=class extends H.Serializable{},qp=class extends Sd{constructor(t){super(),ZM(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return z(()=>{let e=re([1]);return this.hasL1&&(e=X(e,it(R(this.l1,ve(t))))),this.hasL2&&(e=X(e,it(R(this.l2,Ka(t))))),F(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};qp.className="L1L2";H.registerClass(qp);var dv={l1l2:"L1L2"};function Gt(r){return Bu(r)}function gv(r,t={}){return on(r,H.SerializationMap.getMap().classNameMap,t,"regularizer")}function jt(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in dv?dv[r]:r,config:{}};return gv(e)}else return r instanceof Sd?r:gv(r)}var jp=class extends Ct{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=gt(t);let o=Or(t);return this.maxValue!=null&&(o=He(o,0,this.maxValue)),o}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};jp.className="ReLU";H.registerClass(jp);var Xp=class extends Ct{constructor(t){super(t==null?{}:t),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let o=gt(t);return Da(o,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};Xp.className="LeakyReLU";H.registerClass(Xp);var Yp=class extends Ct{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Wt(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=jt(t.alphaRegularizer),this.alphaConstraint=me(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new O(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=kt(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let n of this.sharedAxes)e[n-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let o={};if(this.sharedAxes!=null)for(let n=1;n<t.length;++n)o[n]=t[n];this.inputSpec=[new qt({ndim:t.length,axes:o})],this.built=!0}call(t,e){return t=gt(t),Oa(t,this.alpha.read())}getConfig(){let t={alphaInitializer:Jt(this.alphaInitializer),alphaRegularizer:Gt(this.alphaRegularizer),alphaConstraint:pe(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};Yp.className="PReLU";H.registerClass(Yp);var Zp=class extends Ct{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new dt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let o=gt(t);return ds(o)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};Zp.className="ELU";H.registerClass(Zp);var Jp=class extends Ct{constructor(t){super(t==null?{}:t),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let o=gt(t);return R(o,Y(xe(o,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};Jp.className="ThresholdedReLU";H.registerClass(Jp);var Qp=class extends Ct{constructor(t){super(t==null?{}:t),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new oc().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let o=gt(t);return this.softmax(o,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};Qp.className="Softmax";H.registerClass(Qp);function Hi(r,t,e){if(typeof r=="number")return uo(r,t);if(r.length!==t)throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let o=0;o<t;++o){let n=r[o];if(!OT(n))throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${n}`)}return r}function Sr(r,t,e,o,n=1){if(r==null)return r;let s=t+(t-1)*(n-1),i;return e==="same"?i=r:i=r-s+1,Math.floor((i+o-1)/o)}function zo(r,t,e,o){if(r==null)return null;if(o==="valid")r=r*t+_o([e-t,0]);else if(o==="same")r=r*t;else throw new O(`Unsupport padding mode: ${o}.`);return r}function sm(r,t){return z(()=>(ie(t),t==="channelsFirst"?vt(r,[0,2,3,1]):r))}function sw(r,t){return z(()=>(ie(t),t==="channelsFirst"?vt(r,[0,2,3,4,1]):r))}function QM(r,t,e,o=1,n="valid",s,i=1){return z(()=>{if(s==null&&(s=dr()),ie(s),r.shape.length!==3)throw new O(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new O(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new O(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(r=vt(r,[0,2,1])),n==="causal")throw new dt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=ep(r,t,o,n==="same"?"same":"valid","NWC",i);return e!=null&&(a=gr(a,e)),a})}function xv(r,t,e,o=[1,1],n="valid",s,i,a=null){return z(()=>{if(s==null&&(s=dr()),ie(s),r.rank!==3&&r.rank!==4)throw new O(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new O(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let l=sm(r,s);if(n==="causal")throw new dt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Wa.conv2d({x:l,filter:t,strides:o,pad:n==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(l=vt(l,[0,3,1,2])),l})}function tB(r,t,e,o=[1,1,1],n="valid",s,i){return z(()=>{if(s==null&&(s=dr()),ie(s),r.rank!==4&&r.rank!==5)throw new O(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new O(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let a=sw(r,s);if(n==="causal")throw new dt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=jy(a,t,o,n==="same"?"same":"valid","NDHWC",i),e!=null&&(a=gr(a,e)),s==="channelsFirst"&&(a=vt(a,[0,4,1,2,3])),a})}var Ja=class extends Ct{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Ja.verifyArgs(e),this.rank=t,we(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new dt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Hi(e.kernelSize,t,"kernelSize"),this.strides=Hi(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,fr(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ie(this.dataFormat),this.activation=Po(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=me(e.biasConstraint),this.biasRegularizer=jt(e.biasRegularizer),this.activityRegularizer=jt(e.activityRegularizer),this.dilationRate=Hi(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new O(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new O(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new O(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(jr("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!Dh(t.kernelSize,"number",1,3))throw new O(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Lo(this.activation),useBias:this.useBias,biasInitializer:Jt(this.biasInitializer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),biasConstraint:pe(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},Ki=class extends Ja{constructor(t,e){super(t,e),this.kernel=null,Ki.verifyArgs(e),this.filters=e.filters,we(this.filters,"filters"),this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=me(e.kernelConstraint),this.kernelRegularizer=jt(e.kernelRegularizer)}build(t){t=kt(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new O(`The channel dimension of the input should be defined. Found ${t[e]}`);let o=t[e],n=this.kernelSize.concat([o,this.filters]);this.kernel=this.addWeight("kernel",n,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:o}}],this.built=!0}call(t,e){return z(()=>{t=gt(t);let o,n=this.bias==null?null:this.bias.read(),s=Rh(this.activation.getClassName());if(s!=null&&this.rank===2)o=xv(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)o=QM(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)o=xv(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)o=tB(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new dt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(o=this.activation.apply(o))}return o})}computeOutputShape(t){t=kt(t);let e=[],o=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<o.length;++s){let i=Sr(o[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let n=[t[0]];return this.dataFormat==="channelsLast"?(n=n.concat(e),n.push(this.filters)):(n.push(this.filters),n=n.concat(e)),n}getConfig(){let t={filters:this.filters,kernelInitializer:Jt(this.kernelInitializer),kernelRegularizer:Gt(this.kernelRegularizer),kernelConstraint:pe(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new O(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},qi=class extends Ki{constructor(t){super(2,t),qi.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Dh(t.kernelSize,"number",1,2))throw new O(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};qi.className="Conv2D";H.registerClass(qi);var ji=class extends Ki{constructor(t){super(3,t),ji.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new O(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};ji.className="Conv3D";H.registerClass(ji);var tm=class extends qi{constructor(t){if(super(t),this.inputSpec=[new qt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=kt(t),t.length!==4)throw new O("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let o=t[e],n=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new qt({ndim:4,axes:{[e]:o}})],this.built=!0}call(t,e){return z(()=>{let o=gt(t);if(o.shape.length!==4)throw new O(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let n=o.shape,s=n[0],i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);let l=n[i],u=n[a],c=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],f=this.strides[1],h=zo(l,m,c,this.padding),d=zo(u,f,p,this.padding),g=[s,h,d,this.filters];this.dataFormat!=="channelsLast"&&(o=vt(o,[0,2,3,1]));let x=rp(o,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=vt(x,[0,3,1,2])),this.bias!=null&&(x=gr(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(t){t=kt(t);let e=t.slice(),o,n,s;this.dataFormat==="channelsFirst"?(o=1,n=2,s=3):(o=3,n=1,s=2);let i=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return e[o]=this.filters,e[n]=zo(e[n],l,i,this.padding),e[s]=zo(e[s],u,a,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};tm.className="Conv2DTranspose";H.registerClass(tm);var em=class extends ji{constructor(t){if(super(t),this.inputSpec=[new qt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=kt(t),t.length!==5)throw new O("Input should have rank 5; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let o=t[e],n=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new qt({ndim:5,axes:{[e]:o}})],this.built=!0}call(t,e){return z(()=>{let o=gt(t);if(o.shape.length!==5)throw new O(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let n=o.shape,s=n[0],i,a,l;this.dataFormat==="channelsFirst"?(l=2,i=3,a=4):(l=1,i=2,a=3);let u=n[l],c=n[i],p=n[a],m=this.kernelSize[0],f=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],g=this.strides[1],x=this.strides[2],b=zo(u,d,m,this.padding),C=zo(c,g,f,this.padding),w=zo(p,x,h,this.padding),I=[s,b,C,w,this.filters];this.dataFormat!=="channelsLast"&&(o=vt(o,[0,2,3,4,1]));let E=Xy(o,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=vt(E,[0,4,1,2,3])),this.bias!==null&&(E=gr(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(t){t=kt(t);let e=t.slice(),o,n,s,i;this.dataFormat==="channelsFirst"?(o=1,n=2,s=3,i=4):(o=4,n=1,s=2,i=3);let a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],p=this.strides[1],m=this.strides[2];return e[o]=this.filters,e[n]=zo(e[n],c,a,this.padding),e[s]=zo(e[s],p,l,this.padding),e[i]=zo(e[i],m,u,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};em.className="Conv3DTranspose";H.registerClass(em);var Nd=class extends Ki{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new O("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new O("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new O(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Wt(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=jt(e.depthwiseRegularizer),this.depthwiseConstraint=me(e.depthwiseConstraint),this.pointwiseInitializer=Wt(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=jt(e.pointwiseRegularizer),this.pointwiseConstraint=me(e.pointwiseConstraint)}build(t){if(t=kt(t),t.length<this.rank+2)throw new O(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new O(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let o=t[e],n=this.kernelSize.concat([o,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(o*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",n,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new qt({ndim:this.rank+2,axes:{[e]:o}})],this.built=!0}call(t,e){return z(()=>{t=gt(t);let o;if(this.rank===1)throw new dt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=vt(t,[0,2,3,1])),o=mp(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(o=gr(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),this.dataFormat==="channelsFirst"&&(o=vt(o,[0,3,1,2])),o})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Jt(this.depthwiseInitializer),t.pointwiseInitializer=Jt(this.pointwiseInitializer),t.depthwiseRegularizer=Gt(this.depthwiseRegularizer),t.pointwiseRegularizer=Gt(this.pointwiseRegularizer),t.depthwiseConstraint=pe(this.depthwiseConstraint),t.pointwiseConstraint=pe(this.pointwiseConstraint),t}};Nd.className="SeparableConv";var rm=class extends Nd{constructor(t){super(2,t)}};rm.className="SeparableConv2D";H.registerClass(rm);var Qa=class extends Ki{constructor(t){super(1,t),Qa.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Dh(t.kernelSize,"number",1,1))throw new O(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};Qa.className="Conv1D";H.registerClass(Qa);var om=class extends Ct{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return z(()=>{if(t=gt(t),this.dataFormat==="channelsLast"){let o=kp(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return kp(o,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let o=kp(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return kp(o,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};om.className="Cropping2D";H.registerClass(om);var nm=class extends Ct{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ie(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,FT(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],o=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,o]}else{let e=t[1]==null?null:this.size[0]*t[1],o=t[2]==null?null:this.size[1]*t[2];return[t[0],e,o,t[3]]}}call(t,e){return z(()=>{let o=gt(t),n=o.shape;if(this.dataFormat==="channelsFirst"){o=vt(o,[0,2,3,1]);let s=this.size[0]*n[2],i=this.size[1]*n[3],a=this.interpolation==="nearest"?Do.resizeNearestNeighbor(o,[s,i]):Do.resizeBilinear(o,[s,i]);return vt(a,[0,3,1,2])}else{let s=this.size[0]*n[1],i=this.size[1]*n[2];return this.interpolation==="nearest"?Do.resizeNearestNeighbor(o,[s,i]):Do.resizeBilinear(o,[s,i])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}};nm.className="UpSampling2D";H.registerClass(nm);function eB(r,t,e=[1,1],o="valid",n,s){return z(()=>{n==null&&(n=dr()),ie(n);let i=sm(r,n);if(r.rank!==4)throw new O(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new O(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=hs(i,t,e,o==="same"?"same":"valid","NHWC",s),n==="channelsFirst"&&(i=vt(i,[0,3,1,2])),i})}var im=class extends Ja{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Wt(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=me(t.depthwiseConstraint),this.depthwiseRegularizer=jt(t.depthwiseRegularizer)}build(t){if(t=kt(t),t.length<4)throw new O(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new O(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let o=t[e],n=[this.kernelSize[0],this.kernelSize[1],o,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",n,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[o*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return z(()=>{t=gt(t);let o=eB(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(o=gr(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),o})}computeOutputShape(t){t=kt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],o=this.dataFormat==="channelsFirst"?t[3]:t[2],n=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=Sr(e,this.kernelSize[0],this.padding,this.strides[0]),i=Sr(o,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],n,s,i]:[t[0],s,i,n]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Jt(this.depthwiseInitializer),t.depthwiseRegularizer=Gt(this.depthwiseRegularizer),t.depthwiseConstraint=pe(this.depthwiseRegularizer),t}};im.className="DepthwiseConv2D";H.registerClass(im);function iw(r,t,e,o){if(Array.isArray(r)){if(t!=null||e!=null)throw new O("When inputs is an array, neither initialState or constants should be provided");o!=null&&(e=r.slice(r.length-o,r.length),r=r.slice(0,r.length-o)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function n(s){return s==null||Array.isArray(s)?s:[s]}return t=n(t),e=n(e),{inputs:r,initialState:t,constants:e}}function aw(r,t,e,o=!1,n,s,i=!1,a=!1){return z(()=>{let l=t.shape.length;if(l<3)throw new O(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(hr(2,l));if(t=vt(t,u),s!=null)throw new dt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),n!=null&&(n=Y(Y(n,"bool"),"float32"),n.rank===l-1&&(n=Ae(n,-1)),n=vt(n,u)),o&&(t=qr(t,0),n!=null&&(n=qr(n,0)));let c=[],p,m=e,f=t.shape[0],h=sr(t),d;n!=null&&(d=sr(n));for(let x=0;x<f;++x){let b=h[x],C=z(()=>r(b,m));if(n==null)p=C[0],m=C[1];else{let w=z(()=>{let I=d[x],E=ct(Le(I),I),A=X(R(C[0],I),R(m[0],E)),$=m.map((_,L)=>X(R(C[1][L],I),R(_,E)));return{output:A,newStates:$}});p=w.output,m=w.newStates}a&&c.push(p)}let g;return a&&(g=Fe(c,1)),[p,g,m]})}var Xr=class extends Ct{constructor(t){super(t);let e;if(t.cell==null)throw new O("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new ic({cells:t.cell}):e=t.cell,e.stateSize==null)throw new O("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new qt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return hr(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Vh(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let o=e[0],n;if(this.returnSequences?n=[t[0],t[1],o]:n=[t[0],o],this.returnState){let s=[];for(let i of e)s.push([t[0],i]);return[n].concat(s)}else return n}computeMask(t,e){return z(()=>{Array.isArray(e)&&(e=e[0]);let o=this.returnSequences?e:null;if(this.returnState){let n=this.states.map(s=>null);return[o].concat(n)}else return o})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let o=0;o<t;++o)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new dt("Constants support is not implemented in RNN yet.");Vh(t)&&(t=t[0]),t=t;let o=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new qt({shape:[o,null,...n]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!y.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new O(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new qt({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){z(()=>{if(!this.stateful)throw new Cr("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape[0];if(o==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(n=>re([o,n])):this.states_=[re([o,this.cell.stateSize])];else if(t==null)wt(this.states_),this.keptStates!=null&&(wt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(n=>re([o,n])):this.states_[0]=re([o,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):wt(this.states_);for(let n=0;n<this.states_.length;++n){let s=t[n],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[n]:this.cell.stateSize,a=[o,i];if(!y.arraysEqual(s.shape,a))throw new O(`State ${n} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[n]=s}}this.states_=this.states_.map(n=>Oe(n.clone()))})}apply(t,e){let o=e==null?null:e.initialState,n=e==null?null:e.constants;e==null&&(e={});let s=iw(t,o,n,this.numConstants);t=s.inputs,o=s.initialState,n=s.constants;let i=[],a=[];if(o!=null){e.initialState=o,i=i.concat(o),this.stateSpec=[];for(let u of o)this.stateSpec.push(new qt({shape:u.shape}));a=a.concat(this.stateSpec)}if(n!=null&&(e.constants=n,i=i.concat(n),this.numConstants=n.length),i[0]instanceof lr){let u=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(u,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return z(()=>{let o=e==null?null:e.mask,n=e==null?null:e.training,s=e==null?null:e.initialState;t=gt(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new O(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:n},u=aw((h,d)=>{let g=this.cell.call([h].concat(d),a);return[g[0],g.slice(1)]},t,s,this.goBackwards,o,null,this.unroll,this.returnSequences),c=u[0],p=u[1],m=u[2];this.stateful&&this.resetStates(m,n);let f=this.returnSequences?p:c;return this.returnState?[f].concat(m):f})}getInitialState(t){return z(()=>{let e=re(t.shape);return e=it(e,[1,2]),e=Ss(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>o>1?zh(e,[1,o]):e):this.cell.stateSize>1?[zh(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let o=this.cell.getConfig();return this.getClassName()===Xr.className&&(e.cell={className:this.cell.getClassName(),config:o}),Object.assign(Object.assign(Object.assign({},o),t),e)}static fromConfig(t,e,o={}){let n=e.cell,s=Lr(n,o);return new t(Object.assign(e,{cell:s}))}};Xr.className="RNN";H.registerClass(Xr);var Xi=class extends Ct{},nc=class extends Xi{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,we(this.units,"units"),this.activation=Po(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Wt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=jt(t.kernelRegularizer),this.recurrentRegularizer=jt(t.recurrentRegularizer),this.biasRegularizer=jt(t.biasRegularizer),this.kernelConstraint=me(t.kernelConstraint),this.recurrentConstraint=me(t.recurrentConstraint),this.biasConstraint=me(t.biasConstraint),this.dropout=Ha([1,_o([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Ha([1,_o([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=kt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return z(()=>{if(t=t,t.length!==2)throw new O(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let o=t[1];t=t[0];let n=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vs({ones:()=>Le(t),rate:this.dropout,training:n,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vs({ones:()=>Le(o),rate:this.recurrentDropout,training:n,dropoutFunc:this.dropoutFunc}));let s,i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?s=fo(R(t,i),this.kernel.read()):s=fo(t,this.kernel.read()),this.bias!=null&&(s=gr(s,this.bias.read())),a!=null&&(o=R(o,a));let l=X(s,fo(o,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Lo(this.activation),useBias:this.useBias,kernelInitializer:Jt(this.kernelInitializer),recurrentInitializer:Jt(this.recurrentInitializer),biasInitializer:Jt(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),recurrentConstraint:pe(this.recurrentConstraint),biasConstraint:pe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}};nc.className="SimpleRNNCell";H.registerClass(nc);var am=class extends Xr{constructor(t){t.cell=new nc(t),super(t)}call(t,e){return z(()=>{this.cell.dropoutMask!=null&&(wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=e==null?null:e.mask,n=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:o,training:n,initialState:s})})}static fromConfig(t,e){return new t(e)}};am.className="SimpleRNN";H.registerClass(am);var sc=class extends Xi{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new O("GRUCell does not support reset_after parameter set to true.");this.units=t.units,we(this.units,"units"),this.activation=Po(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Po(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Wt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=jt(t.kernelRegularizer),this.recurrentRegularizer=jt(t.recurrentRegularizer),this.biasRegularizer=jt(t.biasRegularizer),this.kernelConstraint=me(t.kernelConstraint),this.recurrentConstraint=me(t.recurrentConstraint),this.biasConstraint=me(t.biasConstraint),this.dropout=Ha([1,_o([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Ha([1,_o([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=kt(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return z(()=>{if(t=t,t.length!==2)throw new O(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let o=e.training==null?!1:e.training,n=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vs({ones:()=>Le(t),rate:this.dropout,training:o,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vs({ones:()=>Le(n),rate:this.recurrentDropout,training:o,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,a,l,u;0<this.dropout&&this.dropout<1&&(t=R(t,s[0]));let c=fo(t,this.kernel.read());this.useBias&&(c=gr(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(n=R(n,i[0]));let p=this.recurrentKernel.read(),[m,f]=Re(p,[2*this.units,this.units],p.rank-1),h=fo(n,m),[d,g,x]=Re(c,3,c.rank-1),[b,C]=Re(h,2,h.rank-1);a=this.recurrentActivation.apply(X(d,b)),l=this.recurrentActivation.apply(X(g,C));let w=fo(R(l,n),f);u=this.activation.apply(X(x,w));let I=X(R(a,n),R(X(1,zt(a)),u));return[I,I]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Lo(this.activation),recurrentActivation:Lo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Jt(this.kernelInitializer),recurrentInitializer:Jt(this.recurrentInitializer),biasInitializer:Jt(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),recurrentConstraint:pe(this.recurrentConstraint),biasConstraint:pe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}};sc.className="GRUCell";H.registerClass(sc);var lm=class extends Xr{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new sc(t),super(t)}call(t,e){return z(()=>{this.cell.dropoutMask!=null&&(wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=e==null?null:e.mask,n=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:o,training:n,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};lm.className="GRU";H.registerClass(lm);var Yi=class extends Xi{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,we(this.units,"units"),this.activation=Po(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Po(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Wt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=jt(t.kernelRegularizer),this.recurrentRegularizer=jt(t.recurrentRegularizer),this.biasRegularizer=jt(t.biasRegularizer),this.kernelConstraint=me(t.kernelConstraint),this.recurrentConstraint=me(t.recurrentConstraint),this.biasConstraint=me(t.biasConstraint),this.dropout=Ha([1,_o([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Ha([1,_o([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=kt(t);let o=t[t.length-1];this.kernel=this.addWeight("kernel",[o,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let n;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,i=this.units;n=new(e=class extends xr{apply(l,u){let c=s.apply([i]),p=new qa().apply([i]),m=s.apply([i*2]);return Kb(Kb(c,p),m)}},e.className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return z(()=>{let o=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new O(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=t[1],s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vs({ones:()=>Le(t),rate:this.dropout,training:o,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vs({ones:()=>Le(n),rate:this.recurrentDropout,training:o,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,l,u,c,p;0<this.dropout&&this.dropout<1&&(t=R(t,i[0]));let m=fo(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(n=R(n,a[0])),m=X(m,fo(n,this.recurrentKernel.read())),this.useBias&&(m=gr(m,this.bias.read()));let[f,h,d,g]=Re(m,4,m.rank-1);l=this.recurrentActivation.apply(f),u=this.recurrentActivation.apply(h),c=X(R(u,s),R(l,this.activation.apply(d))),p=this.recurrentActivation.apply(g);let x=R(p,this.activation.apply(c));return[x,x,c]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:Lo(this.activation),recurrentActivation:Lo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Jt(this.kernelInitializer),recurrentInitializer:Jt(this.recurrentInitializer),biasInitializer:Jt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Gt(this.kernelRegularizer),recurrentRegularizer:Gt(this.recurrentRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),recurrentConstraint:pe(this.recurrentConstraint),biasConstraint:pe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}};Yi.className="LSTMCell";H.registerClass(Yi);var um=class extends Xr{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Yi(t),super(t)}call(t,e){return z(()=>{this.cell.dropoutMask!=null&&(wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=e==null?null:e.mask,n=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:o,training:n,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};um.className="LSTM";H.registerClass(um);var ic=class extends Xi{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return z(()=>{t=t;let o=t.slice(1),n=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?n.push(o.splice(0,a.stateSize.length)):n.push(o.splice(0,1));n.reverse();let s=[],i;for(let a=0;a<this.cells.length;++a){let l=this.cells[a];o=n[a],a===0?i=[t[0]].concat(o):i=[i[0]].concat(o),i=l.call(i,e),s.push(i.slice(1))}o=[];for(let a of s.slice().reverse())o.push(...a);return[i[0]].concat(o)})}build(t){Vh(t)&&(t=t[0]),t=t;let e;this.cells.forEach((o,n)=>{Fo(`RNNCell_${n}`,()=>{o.build(t),Array.isArray(o.stateSize)?e=o.stateSize[0]:e=o.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=s=>({className:s.getClassName(),config:s.getConfig()}),n={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),n)}static fromConfig(t,e,o={}){let n=[];for(let s of e.cells)n.push(Lr(s,o));return new t({cells:n})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let o of this.cells)e.push(...o.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return Lp(t)}setWeights(t){let e=[];for(let o of this.cells){let n=o.weights.length,s=t.splice(n);for(let i=0;i<o.weights.length;++i)e.push([o.weights[i],s[i]])}Ju(e)}};ic.className="StackedRNNCells";H.registerClass(ic);function vs(r){let{ones:t,rate:e,training:o=!1,count:n=1,dropoutFunc:s}=r,i=()=>s!=null?s(t(),e):Bh(t(),e),a=()=>Wi(i,t,o);return!n||n<=1?Oe(a().clone()):Array(n).fill(void 0).map(a).map(u=>Oe(u.clone()))}var rB=function(r,t){var e={};for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&t.indexOf(o)<0&&(e[o]=r[o]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var n=0,o=Object.getOwnPropertySymbols(r);n<o.length;n++)t.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(r,o[n])&&(e[o[n]]=r[o[n]]);return e};var Td=class extends Xr{constructor(t){if(t.unroll)throw new dt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new dt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new qt({ndim:5})]}call(t,e){return z(()=>{if(this.cell.dropoutMask!=null&&(wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new O("ConvRNN2D cell does not support constants");let o=e==null?null:e.mask,n=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:o,training:n,initialState:s})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return z(()=>{let{stateSize:e}=this.cell,o=t.shape,n=this.computeSingleOutputShape(o),s=[n[0],...n.slice(2)],i=re(s);return Array.isArray(e)?Array(e.length).fill(i):[i]})}resetStates(t,e=!1){z(()=>{if(!this.stateful)throw new Cr("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape,n=this.computeSingleOutputShape(o),s=[n[0],...n.slice(2)];if(o[0]==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>re(s)):this.states_=[re(s)];else if(t==null)wt(this.states_),this.keptStates!=null&&(wt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>re(s)):this.states_[0]=re(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):wt(this.states_);for(let a=0;a<this.states_.length;++a){let l=t[a],u=s;if(!y.arraysEqual(l.shape,u))throw new O(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Oe(a.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:o,kernelSize:n,padding:s,strides:i,dilationRate:a}=this.cell,l=e==="channelsFirst",u=t[l?3:2],c=t[l?4:3],p=Sr(u,n[0],s,i[0],a[0]),m=Sr(c,n[1],s,i[1],a[1]);return[...t.slice(0,2),...l?[o,p,m]:[p,m,o]]}};Td.className="ConvRNN2D";var ac=class extends Yi{constructor(t){let{filters:e,kernelSize:o,strides:n,padding:s,dataFormat:i,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,we(this.filters,"filters"),this.kernelSize=Hi(o,2,"kernelSize"),this.kernelSize.forEach(l=>we(l,"kernelSize")),this.strides=Hi(n||1,2,"strides"),this.strides.forEach(l=>we(l,"strides")),this.padding=s||"valid",fr(this.padding),this.dataFormat=i||"channelsLast",ie(this.dataFormat),this.dilationRate=Hi(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>we(l,"dilationRate"))}build(t){var e;t=kt(t);let o=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[o]==null)throw new O(`The channel dimension of the input should be defined. Found ${t[o]}`);let n=t[o],s=4,i=this.kernelSize.concat([n,this.filters*s]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){let u=this.biasInitializer,c=this.filters;l=new(e=class extends xr{apply(m,f){let h=u.apply([c]),d=_r([c]),g=u.apply([c*2]);return Gu([h,d,g])}},e.className="CustomInit",e)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return z(()=>{if(t.length!==3)throw new O(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=e.training||!1,n=t[0],s=t[1],i=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=vs({ones:()=>Le(n),rate:this.dropout,training:o,count:a,dropoutFunc:this.dropoutFunc}));let l=this.dropoutMask,u=(tt,et,nt)=>!et||!et[nt]?tt:R(et[nt],tt),c=u(n,l,0),p=u(n,l,1),m=u(n,l,2),f=u(n,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=vs({ones:()=>Le(s),rate:this.recurrentDropout,training:o,count:a,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,d=u(s,h,0),g=u(s,h,1),x=u(s,h,2),b=u(s,h,3),C=3,[w,I,E,A]=Re(this.kernel.read(),a,C),[$,_,L,B]=this.useBias?Re(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,w,$,this.padding),p=this.inputConv(p,I,_,this.padding),m=this.inputConv(m,E,L,this.padding),f=this.inputConv(f,A,B,this.padding);let[V,G,U,W]=Re(this.recurrentKernel.read(),a,C);d=this.recurrentConv(d,V),g=this.recurrentConv(g,G),x=this.recurrentConv(x,U),b=this.recurrentConv(b,W);let q=this.recurrentActivation.apply(X(c,d)),Z=this.recurrentActivation.apply(X(p,g)),K=X(R(Z,i),R(q,this.activation.apply(X(m,x)))),J=R(this.recurrentActivation.apply(X(f,b)),this.activation.apply(K));return[J,J,K]})}getConfig(){let t=super.getConfig(),{units:e}=t,o=rB(t,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},o),n)}inputConv(t,e,o,n){let s=Dr(t,e,this.strides,n||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return o?gr(s,o,this.dataFormat):s}recurrentConv(t,e){return Dr(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};ac.className="ConvLSTM2DCell";H.registerClass(ac);var cm=class extends Td{constructor(t){let e=new ac(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}};cm.className="ConvLSTM2D";H.registerClass(cm);var lc=class extends Ct{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,o=[];for(let n=0;n<this.noiseShape.length;++n)o.push(this.noiseShape[n]==null?e[n]:this.noiseShape[n]);return o}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t);if(0<this.rate&&this.rate<1){let n=e.training==null?!1:e.training,s=this.getNoiseShape(o);return Wi(()=>Bh(o,this.rate,s,this.seed),()=>o,n)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};lc.className="Dropout";H.registerClass(lc);var pm=class extends lc{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};pm.className="SpatialDropout1D";H.registerClass(pm);var mm=class extends Ct{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,we(this.units,"units"),this.activation=Po(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Wt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Wt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=me(t.kernelConstraint),this.biasConstraint=me(t.biasConstraint),this.kernelRegularizer=jt(t.kernelRegularizer),this.biasRegularizer=jt(t.biasRegularizer),this.activityRegularizer=jt(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=kt(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=kt(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t),n=Rh(this.activation.getClassName()),s;return n!=null?s=fo(o,this.kernel.read(),n,this.bias?this.bias.read():null):(s=fo(o,this.kernel.read()),this.bias!=null&&(s=gr(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let t={units:this.units,activation:Lo(this.activation),useBias:this.useBias,kernelInitializer:Jt(this.kernelInitializer),biasInitializer:Jt(this.biasInitializer),kernelRegularizer:Gt(this.kernelRegularizer),biasRegularizer:Gt(this.biasRegularizer),activityRegularizer:Gt(this.activityRegularizer),kernelConstraint:pe(this.kernelConstraint),biasConstraint:pe(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};mm.className="Dense";H.registerClass(mm);var fm=class extends Ct{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=kt(t);for(let e of t.slice(1))if(e==null)throw new O(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],mo(t,1)]}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t);if(this.dataFormat==="channelsFirst"&&o.rank>1){let n=[0];for(let s=2;s<o.rank;++s)n.push(s);n.push(1),o=vt(o,n)}return zT(o)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}};fm.className="Flatten";H.registerClass(fm);var hm=class extends Ct{constructor(t){super(t),this.supportsMasking=!0,this.activation=Po(t.activation)}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t);return this.activation.apply(o)})}getConfig(){let t={activation:Lo(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};hm.className="Activation";H.registerClass(hm);var dm=class extends Ct{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return z(()=>(t=gt(t),LT(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};dm.className="RepeatVector";H.registerClass(dm);var gm=class extends Ct{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let o="Total size of new array must be unchanged.",n=e.slice(),s=1,i=null;for(let l=0;l<n.length;++l){let u=n[l];if(this.isUnknown(u))if(i===null)i=l;else throw new O("Can only specifiy one unknown dimension.");else s*=u}let a=mo(t);if(i!==null){if(s===0||a%s!==0)throw new O(o);n[i]=a/s}else if(a!==s)throw new O(o);return n}computeOutputShape(t){let e=!1;for(let o=0;o<t.length;++o)if(this.isUnknown(t[o])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t),n=o.shape,s=n.slice(0,1).concat(this.fixUnknownDimension(n.slice(1),this.targetShape));return F(o,s)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};gm.className="Reshape";H.registerClass(gm);var xm=class extends Ct{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=hr(1,t.dims.length+1);if(!y.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new qt({ndim:this.dims.length+1})]}computeOutputShape(t){t=kt(t);let e=t.slice();return this.dims.forEach((o,n)=>{e[n+1]=t[o]}),e}call(t,e){return vt(gt(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};xm.className="Permute";H.registerClass(xm);var ym=class extends Ct{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let o=gt(t),n=-1;return yu(Bi(o,this.maskValue),n)}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t),n=-1,s=!0,i=yu(Bi(o,this.maskValue),n,s);return R(o,Y(i,o.dtype))})}};ym.className="Masking";H.registerClass(ym);var bm=class extends Ct{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Kt(t.inputLength))}this.inputDim=t.inputDim,we(this.inputDim,"inputDim"),this.outputDim=t.outputDim,we(this.outputDim,"outputDim"),this.embeddingsInitializer=Wt(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=jt(t.embeddingsRegularizer),this.activityRegularizer=jt(t.activityRegularizer),this.embeddingsConstraint=me(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return z(()=>this.maskZero?(t=gt(t),Bi(t,ht(t))):null)}computeOutputShape(t){if(t=kt(t),this.inputLength==null)return[...t,this.outputDim];let e=Kt(this.inputLength);if(e.length!==t.length-1)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let o=0;for(let n=0;n<e.length;++n){let s=e[n],i=t[n+1];if(s!=null&&i!=null&&s!==i)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(e[o]=i),o++}}return[t[0],...e,this.outputDim]}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t);o.dtype!=="int32"&&(o=ir(o,"int32"));let n=Mh(this.embeddings.read(),F(o,[o.size]));return F(n,kt(this.computeOutputShape(o.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Jt(this.embeddingsInitializer),embeddingsRegularizer:Gt(this.embeddingsRegularizer),activityRegularizer:Gt(this.activityRegularizer),embeddingsConstraint:pe(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};bm.className="Embedding";H.registerClass(bm);var ks=class extends Ct{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new dt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let o=t.slice(0,t.length-e.length);for(let n=0;n<e.length;++n){let s=t[t.length-e.length+n],i=e[n];if(s==null||i==null||s<0||i<0)o.push(null);else if(s===1)o.push(i);else if(i===1)o.push(s);else{if(s!==i)throw new O("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));o.push(s)}}return o}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[kt(t)]),t=t,t.length<2)throw new O(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=po(e),e.length>1)throw new O(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let o=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);o=this.computeElementwiseOpOutputShape(o,i)}let n=t.map(s=>s.length);t.indexOf(null)===-1&&po(n).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return z(()=>{if(t=t,this.reshapeRequired){let o=[],n=t.map(s=>s.rank);if(n.indexOf(null)===-1){let s=_o(n);for(let i of t){let a=i.rank;for(let l=0;l<s-a;++l)i=Ss(i,1);o.push(i)}return this.mergeFunction(o)}else{let s=!1;for(let l of t){let u=l.rank;if(u==null){let c=l.shape,p=c[0],m=c.slice(1).concat([p]),f=F(l,[p].concat(mo(c.slice(1))));f=vt(f,[1,0]),f=F(f,m),o.push(f),s=!0}else if(u>1){let c=hr(1,u).concat([0]);o.push(vt(l,c)),s=!0}else o.push(l)}let i=this.mergeFunction(o),a=i.rank;if(s){if(a==null){let l=i.shape,u=l.length,c=l[u-1],p=[c].concat(l.slice(0,l.length-1));i=F(vt(F(i,[-1,c]),[1,0]),p)}else if(a>1){let l=[a-1].concat(hr(0,a-1));i=vt(i,l)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let n=1;n<t.length;++n){let s=t[n]==null?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let o=[];for(let n of t)n!=null&&n[0]!==null&&o.push(n[0]);return o=po(o),o.length===1?e=o.concat(e):e=[null].concat(e),e}computeMask(t,e){return z(()=>{if(e==null)return null;if(!Array.isArray(e))throw new O("`mask` should be an Array");if(!Array.isArray(t))throw new O("`inputs` should be an Array");if(e.length!==t.length)throw new O(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(n=>n==null))return null;e=e.map(n=>n==null?n:Ae(n,0));let o=e[0];for(let n=1;n<e.length-1;++n)o=nr(o,e[n]);return o})}},Cm=class extends ks{constructor(t){super(t)}mergeFunction(t){return z(()=>{let e=t[0].clone();for(let o=1;o<t.length;++o)e=X(e,t[o]);return e})}};Cm.className="Add";H.registerClass(Cm);var Im=class extends ks{constructor(t){super(t)}mergeFunction(t){return z(()=>{let e=t[0].clone();for(let o=1;o<t.length;++o)e=R(e,t[o]);return e})}};Im.className="Multiply";H.registerClass(Im);var Sm=class extends ks{constructor(t){super(t)}mergeFunction(t){return z(()=>{let e=t[0].clone();for(let o=1;o<t.length;++o)e=X(e,t[o]);return R(1/t.length,e)})}};Sm.className="Average";H.registerClass(Sm);var Nm=class extends ks{constructor(t){super(t)}mergeFunction(t){return z(()=>{let e=t[0];for(let o=1;o<t.length;++o)e=Fr(e,t[o]);return e})}};Nm.className="Maximum";H.registerClass(Nm);var Tm=class extends ks{constructor(t){super(t)}mergeFunction(t){return z(()=>{let e=t[0];for(let o=1;o<t.length;++o)e=Fa(e,t[o]);return e})}};Tm.className="Minimum";H.registerClass(Tm);var vm=class extends ks{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new O("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let n of t)if(n!=null){e=!1;break}if(e)return;let o=[];for(let n=0;n<t.length;++n){let s=t[n].slice();s.splice(this.axis,1);let i=!1;for(let a of o)if(y.arraysEqual(a,s)){i=!0;break}i||o.push(s)}if(o.length>1)throw new O("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return z(()=>Gu(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new O("A `Concatenate` layer should be called on a list of inputs.");let e=t,o=e[0].slice(),n=this.axis<0?o.length+this.axis:this.axis;for(let s of e.slice(1)){if(o[n]==null||s[n]==null){o[n]=null;break}o[n]+=s[n]}return o}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new O("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new O("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new O(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return z(()=>{let o=!0;if(e.forEach(i=>{if(i!=null){o=!1;return}}),o)return null;let n=[];for(let i=0;i<t.length;++i)e[i]==null?n.push(Y(Le(t[i]),"bool")):e[i].rank<t[i].rank?n.push(Ae(e[i],-1)):n.push(e[i]);let s=te(n,this.axis);return Jc(s,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};vm.className="Concatenate";H.registerClass(vm);function wm(r,t){for(;r<0;)r+=t;return r}function oB(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new dt("batchDot is not implemented for tensors of 4D or higher rank yet");if(y.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),y.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new dt("batchDot is not implemented for complex64-type Tensors yet.");let o=r.shape.length,n=t.shape.length;e==null&&(e=[o-1,n-2]);let s=e;return z(()=>{let i;if(o>n){i=o-n;let l=[];for(let u=0;u<i;++u)l.push(1);t=F(t,t.shape.concat(l))}else if(n>o){i=n-o;let l=[];for(let u=0;u<i;++u)l.push(1);r=F(r,r.shape.concat(l))}else i=0;let a;if(r.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=it(R(r,t),s[0]):a=it(R(vt(r,[1,0]),t),s[1]);else{let l=s[0]!==r.shape.length-1,u=s[1]===t.shape.length-1;a=Pt(r,t,l,u)}if(i>0){let l;o>n?l=o+n-3:l=o-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);a=Ao(a,u)}return a.shape.length===1&&(a=Ae(a,1)),a})}var km=class extends ks{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){y.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],o=t[1];if(e.length>3||o.length>3)throw new dt("Dot layer does not support tensors of 4D or higher rank yet.");let n=this.interpretAxes(e,o);if(e[n[0]]!==o[n[1]])throw new O(`Dimension incompatibility: ${e[n[0]]} !== ${o[n[1]]}`)}mergeFunction(t){if(t.length!==2)throw new O(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],o=t[1],n;return Array.isArray(this.axes)?n=this.axes.map((s,i)=>wm(s,t[i].shape.length)):n=[wm(this.axes,e.shape.length),wm(this.axes,o.shape.length)],this.normalize&&(e=Vp(e,n[0]),o=Vp(o,n[1])),oB(e,o,n)}interpretAxes(t,e){let o;return Array.isArray(this.axes)?o=this.axes:o=[wm(this.axes,t.length),wm(this.axes,e.length)],o}computeOutputShape(t){y.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),o=t[1].slice();if(e.length>3||o.length>3)throw new dt("Dot layer does not support tensors of 4D or higher rank yet.");let n=this.interpretAxes(e,o);e.splice(n[0],1),o.splice(n[1],1),o.splice(0,1);let s=e.concat(o);return s.length===1&&s.push(1),s}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};km.className="Dot";H.registerClass(km);var Em=class extends Ct{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t);return Wi(()=>X(Wu(o.shape,0,this.stddev),o),()=>o,e.training||!1)})}};Em.className="GaussianNoise";H.registerClass(Em);var Am=class extends Ct{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return z(()=>{this.invokeCallHook(t,e);let o=gt(t);return this.rate>0&&this.rate<1?Wi(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return R(o,Wu(o.shape,1,s))},()=>o,e.training||!1):o})}};Am.className="GaussianDropout";H.registerClass(Am);var $m=class extends Ct{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||gt(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return z(()=>{if(this.rate<1&&this.rate>0){let o=this._getNoiseShape(t);return Wi(()=>{let s=gt(t),i=1.6732632423543772,a=1.0507009873554805,l=-i*a,u=wr(xs(o),this.rate);u=ir(u,"float32");let c=qx((1-this.rate)*(1+this.rate*qx(l,2)),-.5),p=-c*l*this.rate,m=X(R(s,u),R(X(u,-1),l));return X(R(m,c),p)},()=>gt(t),e.training||!1)}return t})}};$m.className="AlphaDropout";H.registerClass($m);function Dm(r,t,e,o,n,s=.001){let i;if(r.rank===2)i=By(r,t,e,o,n,s);else if(r.rank===3)i=Vy(r,t,e,o,n,s);else if(r.rank===4)i=Gy(r,t,e,o,n,s);else throw new dt(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return i}function nB(r,t,e,o,n=.001){return z(()=>{let s=vu(r,o),i=s.mean,a=s.variance;return[Dm(r,i,a,e,t,n),i,a]})}function sB(r,t,e,o,n=.001){return z(()=>{let s=vu(r,o),i=s.mean,a=s.variance,l=[];for(let h of hr(0,r.rank))o.indexOf(h)!==-1?l.push(1):l.push(r.shape[h]);let u=F(i,l),c=F(a,l),p=t==null?null:F(t,l),m=e==null?null:F(e,l);return[Dm(r,u,c,m,p,n),i,a]})}function iB(r,t,e,o,n=.001){return y.arraysEqual(o.slice().sort(),hr(0,r.rank-1))?nB(r,t,e,o,n):sB(r,t,e,o,n)}var Rm=class extends Ct{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Wt(t.betaInitializer||"zeros"),this.gammaInitializer=Wt(t.gammaInitializer||"ones"),this.movingMeanInitializer=Wt(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Wt(t.movingVarianceInitializer||"ones"),this.betaConstraint=me(t.betaConstraint),this.gammaConstraint=me(t.gammaConstraint),this.betaRegularizer=jt(t.betaRegularizer),this.gammaRegularizer=jt(t.gammaRegularizer)}build(t){t=kt(t);let e=this.axis>=0?this.axis:this.axis+t.length,o=t[e];if(o==null)throw new O(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new qt({ndim:t.length,axes:{[e]:o}})];let n=[o];this.scale&&(this.gamma=this.addWeight("gamma",n,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",n,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",n,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",n,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return z(()=>{let o=e.training==null?!1:e.training,n=gt(t),s=n.shape,i=s.length,a=hr(0,i),l=this.axis>=0?this.axis:this.axis+i;a.splice(l,1);let u=uo(1,i);u[l]=s[l];let c=a.slice();c.sort();let p=!y.arraysEqual(c,hr(0,i).slice(0,i-1)),m=()=>{if(p){let b=F(this.movingMean.read(),u),C=F(this.movingVariance.read(),u),w=this.center?F(this.beta.read(),u):null,I=this.scale?F(this.gamma.read(),u):null;return Dm(n,b,C,w,I,this.epsilon)}else return Dm(n,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!o)return m();let[f,h,d]=iB(n,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,C,w)=>{z(()=>{let I=1-w,E=b.read(),A=R(ct(E,C),I);b.write(ct(E,A))})};return(()=>{g(this.movingMean,h,this.momentum),g(this.movingVariance,d,this.momentum)})(),f})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Jt(this.betaInitializer),gammaInitializer:Jt(this.gammaInitializer),movingMeanInitializer:Jt(this.movingMeanInitializer),movingVarianceInitializer:Jt(this.movingVarianceInitializer),betaRegularizer:Gt(this.betaRegularizer),gammaRegularizer:Gt(this.gammaRegularizer),betaConstraint:pe(this.betaConstraint),gammaConstraint:pe(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};Rm.className="BatchNormalization";H.registerClass(Rm);var Fm=class extends Ct{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Wt(t.betaInitializer||"zeros"),this.gammaInitializer=Wt(t.gammaInitializer||"ones"),this.betaRegularizer=jt(t.betaRegularizer),this.gammaRegularizer=jt(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=kt(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(let s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==po(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let o=this.axis.map(s=>t[s]),n=!0;this.scale?this.gamma=this.addWeight("gamma",o,"float32",this.gammaInitializer,this.gammaRegularizer,n):this.gamma=null,this.center?this.beta=this.addWeight("beta",o,"float32",this.betaInitializer,this.betaRegularizer,n):this.beta=null,this.built=!0}call(t,e){let o=gt(t),n=o.shape,s=n.length;return z(()=>{let{mean:a,variance:l}=vu(o,this.axis,!0),u=uo(1,s);for(let d of this.axis)u[d]=n[d];let c=d=>d!=null&&d.shape.length!==s?F(d,u):d,p=this.scale?c(this.gamma.read()):null,m=this.center?c(this.beta.read()):null,f=[],h=[];for(let d=0;d<s;++d)this.axis.indexOf(d)!==-1?(f.push(n[d]),h.push(1)):(f.push(1),h.push(n[d]));return a=Je(a,f),l=Je(l,f),p!=null&&(p=Je(p,h)),m!=null&&(m=Je(m,h)),Dm(o,a,l,m,p,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Jt(this.betaInitializer),gammaInitializer:Jt(this.gammaInitializer),betaRegularizer:Gt(this.betaRegularizer),gammaRegularizer:Gt(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};Fm.className="LayerNormalization";H.registerClass(Fm);function aB(r,t,e){return z(()=>{if(r.rank!==4)throw new O(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new O("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=dr()),e!=="channelsLast"&&e!=="channelsFirst")throw new O(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let o;return e==="channelsFirst"?o=[[0,0],[0,0],t[0],t[1]]:o=[[0,0],t[0],t[1],[0,0]],_a(r,o)})}var _m=class extends Ct{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?dr():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new O(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,o;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],o=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new O(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new O(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);o=t.padding[1]}this.padding=[e,o]}this.inputSpec=[new qt({ndim:4})]}computeOutputShape(t){t=kt(t);let e,o;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?o=t[3]+this.padding[1][0]+this.padding[1][1]:o=null,[t[0],t[1],e,o]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?o=t[2]+this.padding[1][0]+this.padding[1][1]:o=null,[t[0],e,o,t[3]])}call(t,e){return z(()=>aB(gt(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};_m.className="ZeroPadding2D";H.registerClass(_m);function Dd(r,t,e,o,n,s){return z(()=>{ie(n),Gb(s),fr(o),e==null&&(e=[1,1]),o==null&&(o="valid"),n==null&&(n=dr()),s==null&&(s="max"),r=sm(r,n);let i,a=o==="same"?"same":"valid";return s==="max"?i=Ra(r,t,e,a):i=Ea(r,t,e,a),n==="channelsFirst"&&(i=vt(i,[0,3,1,2])),i})}function yv(r,t,e,o,n,s){return z(()=>{ie(n),Gb(s),fr(o),e==null&&(e=[1,1,1]),o==null&&(o="valid"),n==null&&(n=dr()),s==null&&(s="max"),r=sw(r,n);let i,a=o==="same"?"same":"valid";return s==="max"?i=ab(r,t,e,a):i=My(r,t,e,a),n==="channelsFirst"&&(i=vt(i,[0,4,1,2,3])),i})}var vd=class extends Ct{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new O(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(we(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new O(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);we(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,fr(this.padding),this.inputSpec=[new qt({ndim:3})]}computeOutputShape(t){t=kt(t);let e=Sr(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return z(()=>{this.invokeCallHook(t,e),t=Ss(gt(t),2);let o=this.poolingFunction(gt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ao(o,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},Om=class extends vd{constructor(t){super(t)}poolingFunction(t,e,o,n,s){return ie(s),fr(n),Dd(t,e,o,n,s,"max")}};Om.className="MaxPooling1D";H.registerClass(Om);var Lm=class extends vd{constructor(t){super(t)}poolingFunction(t,e,o,n,s){return ie(s),fr(n),Dd(t,e,o,n,s,"avg")}};Lm.className="AveragePooling1D";H.registerClass(Lm);var kd=class extends Ct{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new O(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];we(this.poolSize,"poolSize"),we(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ie(this.dataFormat),fr(this.padding),this.inputSpec=[new qt({ndim:4})]}computeOutputShape(t){t=kt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],o=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=Sr(e,this.poolSize[0],this.padding,this.strides[0]),o=Sr(o,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,o]:[t[0],e,o,t[3]]}call(t,e){return z(()=>(this.invokeCallHook(t,e),this.poolingFunction(gt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Pm=class extends kd{constructor(t){super(t)}poolingFunction(t,e,o,n,s){return ie(s),fr(n),Dd(t,e,o,n,s,"max")}};Pm.className="MaxPooling2D";H.registerClass(Pm);var zm=class extends kd{constructor(t){super(t)}poolingFunction(t,e,o,n,s){return ie(s),fr(n),Dd(t,e,o,n,s,"avg")}};zm.className="AveragePooling2D";H.registerClass(zm);var Ed=class extends Ct{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new O(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];we(this.poolSize,"poolSize"),we(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ie(this.dataFormat),fr(this.padding),this.inputSpec=[new qt({ndim:5})]}computeOutputShape(t){t=kt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],o=this.dataFormat==="channelsFirst"?t[3]:t[2],n=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=Sr(e,this.poolSize[0],this.padding,this.strides[0]),o=Sr(o,this.poolSize[1],this.padding,this.strides[1]),n=Sr(n,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,o,n]:[t[0],e,o,n,t[4]]}call(t,e){return z(()=>(this.invokeCallHook(t,e),this.poolingFunction(gt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Mm=class extends Ed{constructor(t){super(t)}poolingFunction(t,e,o,n,s){return ie(s),fr(n),yv(t,e,o,n,s,"max")}};Mm.className="MaxPooling3D";H.registerClass(Mm);var Bm=class extends Ed{constructor(t){super(t)}poolingFunction(t,e,o,n,s){return ie(s),fr(n),yv(t,e,o,n,s,"avg")}};Bm.className="AveragePooling3D";H.registerClass(Bm);var Ad=class extends Ct{constructor(t){super(t),this.inputSpec=[new qt({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new dt}},Vm=class extends Ad{constructor(t){super(t||{})}call(t,e){return z(()=>{let o=gt(t);return se(o,1)})}};Vm.className="GlobalAveragePooling1D";H.registerClass(Vm);var Gm=class extends Ad{constructor(t){super(t||{})}call(t,e){return z(()=>{let o=gt(t);return Ke(o,1)})}};Gm.className="GlobalMaxPooling1D";H.registerClass(Gm);var $d=class extends Ct{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ie(this.dataFormat),this.inputSpec=[new qt({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new dt}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Wm=class extends $d{call(t,e){return z(()=>{let o=gt(t);return this.dataFormat==="channelsLast"?se(o,[1,2]):se(o,[2,3])})}};Wm.className="GlobalAveragePooling2D";H.registerClass(Wm);var Um=class extends $d{call(t,e){return z(()=>{let o=gt(t);return this.dataFormat==="channelsLast"?Ke(o,[1,2]):Ke(o,[2,3])})}};Um.className="GlobalMaxPooling2D";H.registerClass(Um);var Rd=class extends Ct{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,o={}){let n=e.layer,s=Lr(n,o);delete e.layer;let i={layer:s};return Object.assign(i,e),new t(i)}},Hm=class extends Rd{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=kt(t),t.length<3)throw new O(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=kt(t);let e=[t[0]].concat(t.slice(2)),o=this.layer.computeOutputShape(e),n=t[1];return[o[0],n].concat(o.slice(1))}call(t,e){return z(()=>(t=gt(t),aw((i,a)=>[gt(this.layer.call(i,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};Hm.className="TimeDistributed";H.registerClass(Hm);function lB(r){nn(DT,"BidirectionalMergeMode",r)}var uB="concat",Km=class extends Rd{constructor(t){super(t);let e=t.layer.getConfig(),o={};o.className=t.layer.getClassName(),o.config=e,this.forwardLayer=Lr(o),e.goBackwards=e.goBackwards!==!0;let n={};if(n.className=t.layer.getClassName(),n.config=e,this.backwardLayer=Lr(n),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?uB:t.mergeMode,lB(this.mergeMode),t.weights)throw new dt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,o=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,o)),this.backwardLayer.setWeights(t.slice(o))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let o,n,s;return this.returnState&&(s=e.slice(1)),o=e[0],o=o,this.mergeMode==="concat"?(o[o.length-1]*=2,n=[o]):this.mergeMode==null?n=[o,o.slice()]:n=[o],this.returnState?this.mergeMode==null?n.concat(s).concat(s.slice()):[o].concat(s).concat(s.slice()):ze(n)}apply(t,e){let o=e==null?null:e.initialState,n=e==null?null:e.constants;e==null&&(e={});let s=iw(t,o,n,this.numConstants);if(t=s.inputs,o=s.initialState,n=s.constants,Array.isArray(t)&&(o=t.slice(1),t=t[0]),(o==null||o.length===0)&&n==null)return super.apply(t,e);let i=[],a=[];if(o!=null){let u=o.length;if(u%2>0)throw new O("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=o,i.push(...o);let c=o.map(p=>new qt({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(n!=null)throw new dt("Support for constants in Bidirectional layers is not implemented yet.");let l=i[0]instanceof lr;for(let u of i)if(u instanceof lr!==l)throw new O("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){let u=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(u,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return z(()=>{let o=e.initialState,n,s;if(o==null)n=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{let l=o.slice(0,o.length/2),u=o.slice(o.length/2);n=this.forwardLayer.call(t,Object.assign(e,{initialState:l})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:u}))}let i;this.returnState&&(Array.isArray(n)&&(i=n.slice(1).concat(s.slice(1))),n=n[0],s=s[0]),this.returnSequences&&(s=qr(s,1));let a;return this.mergeMode==="concat"?a=Gu([n,s]):this.mergeMode==="sum"?a=X(n,s):this.mergeMode==="ave"?a=R(.5,X(n,s)):this.mergeMode==="mul"?a=R(n,s):this.mergeMode==null&&(a=[n,s]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Fo(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Fo(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let o;if(this.returnSequences?this.mergeMode==null?o=[e,e]:o=e:this.mergeMode==null?o=[null,null]:o=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(o)?o.concat(s).concat(s):[o].concat(s).concat(s)}else return o}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let o=Lr(e.layer);if(delete e.layer,e.numConstants!=null)throw new dt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let n=e;return n.layer=o,new t(n)}};Km.className="Bidirectional";H.registerClass(Km);var qm=class extends Ct{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){let t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return z(()=>(t=gt(t),t.dtype!=="float32"&&(t=ir(t,"float32")),X(R(t,this.scale),this.offset)))}};qm.className="Rescaling";H.registerClass(qm);var{resizeBilinear:cB,cropAndResize:pB}=Do,jm=class extends Ct{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,o,n,s,i,a,l){return z(()=>{let u,c=!1,p=e/i,m=o/a,f=(n+e)/i,h=(s+o)/a,d=[p,m,f,h],g=[];t.rank===3?(c=!0,u=Fe([t])):u=t;for(let I=0;I<u.shape[0];I++)g.push(d);let x=Ar(g,[g.length,4]),b=ys(0,g.length,1,"int32"),w=pB(u,x,b,[n,s],"nearest");return c?ir(gt(sr(w)),l):ir(w,l)})}upsize(t,e,o,n){return z(()=>{let s=cB(t,[e,o]);return ir(s,n)})}call(t,e){return z(()=>{let o=gt(t),n=o.dtype,s=o.shape,i=s[s.length-3],a=s[s.length-2],l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(o,l,u,this.height,this.width,i,a,n):this.upsize(t,this.height,this.width,n)})}getConfig(){let t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=kt(t);let e=t.length-3,o=t.length-2;return t[e]=this.height,t[o]=this.width,t}};jm.className="CenterCrop";H.registerClass(jm);function bv(r,t,e,o){let n=gt(r);if(n.dtype!=="int32"&&(n=ir(n,"int32")),t==="int")return n;let s=n.shape;if(n.rank===0&&(n=Ae(n,-1)),t==="oneHot"&&n.shape[n.shape.length-1]!==1&&(n=Ae(n,-1)),n.rank>2)throw new O(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${n.rank}.`);let i=["multiHot","oneHot"].includes(t),a=n,l;if(typeof o!="undefined"&&t==="count"?l=lh(a,o,e,i):l=lh(a,[],e,i),t!=="tfIdf")return l;if(o)return R(l,o);throw new O("When outputMode is 'tfIdf', weights must be provided.")}var Xm=class extends Ct{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){let t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=kt(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return z(()=>{t=gt(t),t.dtype!=="int32"&&(t=ir(t,"int32"));let o;if(typeof e.countWeights!="undefined"){if(this.outputMode!=="count")throw new O(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);o=gt(e.countWeights)}let n=Ke(t),s=zi(t),i=xe(this.numTokens,n).bufferSync().get(0),a=wr(s,0).bufferSync().get(0);if(!(i&&a))throw new O(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return bv(t,this.outputMode,this.numTokens,o)})}};Xm.className="CategoryEncoding";H.registerClass(Xm);var fB=["bilinear","nearest"],wv=new Set(fB),Ym=class extends Ct{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(wv.has(t.interpolation))this.interpolation=t.interpolation;else throw new O(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){t=kt(t);let e=t[2];return[this.height,this.width,e]}getConfig(){let t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return z(()=>{let o=[this.height,this.width];if(this.interpolation==="bilinear")return Do.resizeBilinear(t,o,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Do.resizeNearestNeighbor(t,o,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...wv]} are supported`)})}};Ym.className="Resizing";H.registerClass(Ym);var bB=P();bB.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var lw;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(lw||(lw={}));var Cv;(function(r){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(Cv||(Cv={}));var Rv=zc(lp());var Av=zc(lp());function Sv(r,t){return Nv(r,t)}function Nv(r,t,e=new Map,o=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(o.has(r))throw new Error("Circular references are not supported.");if(e.has(r))return e.get(r);let n=t(r);if(n.recurse&&n.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(n.recurse)if(uc(r)){let s=Array.isArray(r)?[]:{};o.add(r);for(let i in r){let a=r[i],l=Nv(a,t,e,o);s[i]=l}return o.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return e.set(r,n.value),n.value}function Tv(r,t=uw){return vv(r,t)}function vv(r,t,e=new Set){let o=r[0];if(e.has(o))throw new Error("Circular references are not supported.");let n=t(r);if(n.recurse&&n.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(n.recurse)if(uc(o)){let s=Array.isArray(o)?[]:{};e.add(o);for(let i in o){let a=r.map(u=>u[i]),l=vv(a,t,e);s[i]=l}return e.delete(o),s}else throw new Error(`Can't recurse into non-iterable type: ${o}`);else return n.value}function uw(r){return r===null?null:uc(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}function uc(r){let t=!1;if(P().get("IS_BROWSER"))t=r instanceof TextDecoder;else{let{StringDecoder:e}=Iv();t=r instanceof e}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof _t)&&!(r instanceof Promise)&&!t)}function kv(r){return r==null||mV(r)||Array.isArray(r)||typeof r=="object"&&r instanceof _t||y.isTypedArray(r)}function mV(r){return r===null||typeof r!="object"&&typeof r!="function"}function Ev(r){return Sv(r,fV)}function fV(r){return r instanceof _t?{value:r.clone(),recurse:!1}:uc(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var cc=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),o=this.get(e);return this.set(e,this.pop()),o}};var tl=class extends cc{constructor(){super(tl.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),o=this.length();for(let n=0;n<o;n++)e[n]=this.get(this.wrap(this.begin+n));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=o}};tl.INITIAL_CAPACITY=32;function $v(r){return new cw(r)}function Iw(r){return new pw(r)}function Dv(r,t){return new Od(r,t)}var qe=class{toArray(){return M(this,null,function*(){let t=[],e=yield this.next();for(;!e.done;)t.push(e.value),e=yield this.next();return t})}toArrayForTest(){return M(this,null,function*(){let t=this.prefetch(100),e=[],o=yield t.next();for(;!o.done;)e.push(o.value),o=yield t.next();return e})}resolveFully(){return M(this,null,function*(){let t=yield this.next();for(;!t.done;)t=yield this.next()})}resolveWhile(t){return M(this,null,function*(){let e=yield this.next(),o=t(e.value);for(;!e.done&&o;)e=yield this.next(),o=t(e.value)})}handleErrors(t){return new yw(this,t)}filter(t){return new gw(this,t)}map(t){return new xw(this,t)}mapAsync(t){return new _d(this,t)}serialMapAsync(t){return new _d(this,t).serial()}flatmap(t){return new bw(this,t)}forEachAsync(t){return M(this,null,function*(){return this.map(t).resolveFully()})}serialForEach(t){return M(this,null,function*(){return this.serialMapAsync(t).resolveWhile(e=>e===!0)})}rowMajorBatch(t,e=!0){return new dw(this,t,e)}columnMajorBatch(t,e=!0,o=uw){return this.rowMajorBatch(t,e).map(s=>Tv(s,o))}concatenate(t,e){return new Od($v([this,t]),e)}take(t){return t<0||t==null?this:new hw(this,t)}skip(t){return t<0||t==null?this:new fw(this,t)}prefetch(t){return new Ld(this,t)}shuffle(t,e){return new Cw(this,t,e)}serial(){return new mw(this)}},cw=class extends qe{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){return M(this,null,function*(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:Ev(t),done:!1}})}},pw=class extends qe{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}next(){return M(this,null,function*(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}})}},mw=class extends qe{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){return M(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return M(this,null,function*(){return this.upstream.next()})}},fw=class extends qe{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){return M(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return M(this,null,function*(){for(;this.count++<this.maxCount;){let t=yield this.upstream.next();if(t.done)return t;wt(t.value)}return this.upstream.next()})}},hw=class extends qe{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){return M(this,null,function*(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()})}},dw=class extends qe{constructor(t,e,o=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=o,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){return M(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return M(this,null,function*(){let t=[];for(;t.length<this.batchSize;){let e=yield this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}})}},gw=class extends qe{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){return M(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return M(this,null,function*(){for(;;){let t=yield this.upstream.next();if(t.done||this.predicate(t.value))return t;wt(t.value)}})}},xw=class extends qe{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}next(){return M(this,null,function*(){let t=yield this.upstream.next();if(t.done)return{value:null,done:!0};let e=ro.getTensorsInContainer(t.value),o=this.transform(t.value),n=ro.getTensorsInContainer(o);for(let s of e)ro.isTensorInList(s,n)||s.dispose();return{value:o,done:!1}})}},yw=class extends qe{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){return M(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return M(this,null,function*(){for(;;)try{return yield this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}})}},_d=class extends qe{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){return M(this,null,function*(){let t=yield this.upstream.next();if(t.done)return{value:null,done:!0};let e=ro.getTensorsInContainer(t.value),o=yield this.transform(t.value),n=ro.getTensorsInContainer(o);for(let s of e)ro.isTensorInList(s,n)||s.dispose();return{value:o,done:!1}})}},Zm=class extends qe{constructor(){super(),this.outputQueue=new tl,this.lastRead=Promise.resolve({value:null,done:!1})}next(){return M(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}serialNext(){return M(this,null,function*(){for(;this.outputQueue.length()===0;)if(!(yield this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}})}},bw=class extends Zm{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){return M(this,null,function*(){let t=yield this.upstream.next();if(t.done)return!1;let e=ro.getTensorsInContainer(t.value),o=this.transform(t.value),n=ro.getTensorsInContainer(o);this.outputQueue.pushAll(o);for(let s of e)ro.isTensorInList(s,n)||s.dispose();return!0})}},Od=class extends qe{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){return M(this,null,function*(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead})}readFromChain(t){return M(this,null,function*(){if(yield t,this.iterator==null){let o=yield this.moreIterators.next();if(o.done)return{value:null,done:!0};this.iterator=o.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=yield this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e})}},ww;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(ww||(ww={}));var Ld=class extends qe{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new cc(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},Cw=class extends Ld{constructor(t,e,o){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Av.alea(o||y.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){return M(this,null,function*(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead})}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){return M(this,null,function*(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=yield this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}})}};var el=class{constructor(){this.size=null}batch(t,e=!0){let o=this;y.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let n;return this.size===1/0||this.size==null?n=this.size:e?n=Math.ceil(this.size/t):n=Math.floor(this.size/t),Mo(()=>M(this,null,function*(){return(yield o.iterator()).columnMajorBatch(t,e,dV)}),n)}concatenate(t){let e=this,o;return this.size===1/0||t.size===1/0?o=1/0:this.size!=null&&t.size!=null?o=this.size+t.size:o=null,Mo(()=>M(this,null,function*(){return(yield e.iterator()).concatenate(yield t.iterator())}),o)}filter(t){let e=this,o;return this.size===1/0?o=1/0:o=null,Mo(()=>M(this,null,function*(){return(yield e.iterator()).filter(n=>z(()=>t(n)))}),o)}forEachAsync(t){return M(this,null,function*(){return(yield this.iterator()).forEachAsync(t)})}map(t){let e=this;return Mo(()=>M(this,null,function*(){return(yield e.iterator()).map(o=>z(()=>t(o)))}),this.size)}mapAsync(t){let e=this;return Mo(()=>M(this,null,function*(){return(yield e.iterator()).mapAsync(t)}),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Mo(()=>M(this,null,function*(){return(yield e.iterator()).prefetch(t)}),this.size)}repeat(t){let e=this,o;return this.size!=null&&t>0?o=this.size*t:t===0?o=0:this.size!=null&&(t===void 0||t<0)?o=1/0:o=null,Mo(()=>M(this,null,function*(){let n=Iw(()=>M(this,null,function*(){return{value:yield e.iterator(),done:!1}}));return Dv(n.take(t))}),o)}skip(t){let e=this,o;return this.size!=null&&t>=0&&this.size>=t?o=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?o=0:o=null,Mo(()=>M(this,null,function*(){return(yield e.iterator()).skip(t)}),o)}shuffle(t,e,o=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let n=this,s=Rv.alea(e||y.now().toString());return Mo(()=>M(this,null,function*(){let i=s.int32();return o&&(i+=s.int32()),(yield n.iterator()).shuffle(t,i.toString())}),this.size)}take(t){let e=this,o;return this.size!=null&&this.size>t?o=t:this.size!=null&&this.size<=t?o=this.size:o=null,Mo(()=>M(this,null,function*(){return(yield e.iterator()).take(t)}),o)}toArray(){return M(this,null,function*(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield this.iterator()).toArray()})}toArrayForTest(){return M(this,null,function*(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield this.iterator()).toArrayForTest()})}};el.MAX_BUFFER_SIZE=1e4;function Mo(r,t=null){return new class extends el{constructor(){super(...arguments),this.size=t}iterator(){return M(this,null,function*(){return r()})}}}function dV(r){if(r===null)return null;let t=r[0];return kv(t)?{value:gV(r),recurse:!1}:{value:null,recurse:!0}}function gV(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof _t?Fe(r):Ar(r)}var rUt=Symbol("out"),oUt=Symbol("field"),nUt=Symbol("quote"),sUt=Symbol("quoteafterquote"),iUt=Symbol("quoteinquote");function j(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&y.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var vV=tr.whereImpl,rl=class extends dn{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new na(this,oo())}nextDataId(){return rl.nextDataId++}write(t,e,o){this.firstUse&&(this.firstUse=!1,P().get("IS_NODE")&&S.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let n={id:this.nextDataId()};return this.data.set(n,{values:t,dtype:o,refCount:1}),n}makeTensorInfo(t,e,o){let n;if(e==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let s=o.map(i=>y.encodeString(i));n=this.write(s,t,e)}else n=this.write(o,t,e);return{dataId:n,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,o,n,s){this.data.set(t,{values:e,dtype:n,refCount:s})}numDataIds(){return this.data.numDataIds()}read(t){return M(this,null,function*(){return this.readSync(t)})}readSync(t){let{dtype:e,complexTensorInfos:o}=this.data.get(t);if(e==="complex64"){let n=this.readSync(o.real.dataId),s=this.readSync(o.imag.dataId);return S.mergeRealAndImagArrays(n,s)}return y.convertBackendValuesAndArrayBuffer(this.data.get(t).values,e)}bufferSync(t){let e=this.readSync(t.dataId);if(t.dtype==="string")try{let o=e.map(n=>y.decodeString(n));return ft(t.shape,t.dtype,o)}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(t.shape,t.dtype,e)}makeOutput(t,e,o){return oo().makeTensorFromTensorInfo(this.makeTensorInfo(e,o,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(t);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}time(t){return M(this,null,function*(){let e=y.now();return t(),{kernelMs:y.now()-e}})}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){j([t],"where");let e=this.readSync(t.dataId);return vV(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};rl.nextDataId=0;var Xw={};Jr(Xw,{addImpl:()=>Tw,bincountImpl:()=>fc,bincountReduceImpl:()=>Pd,castImpl:()=>Nw,ceilImpl:()=>vw,concatImpl:()=>zd,equalImpl:()=>kw,expImpl:()=>Aw,expm1Impl:()=>Dw,floorImpl:()=>Rw,gatherNdImpl:()=>Md,gatherV2Impl:()=>Bd,greaterEqualImpl:()=>_w,greaterImpl:()=>Fw,lessEqualImpl:()=>Lw,lessImpl:()=>Ow,linSpaceImpl:()=>Vd,logImpl:()=>Pw,maxImpl:()=>Gd,maximumImpl:()=>zw,minimumImpl:()=>Mw,multiplyImpl:()=>Jm,negImpl:()=>Bw,notEqualImpl:()=>Vw,prodImpl:()=>Gw,raggedGatherImpl:()=>Wd,raggedRangeImpl:()=>Ud,raggedTensorToTensorImpl:()=>Hd,rangeImpl:()=>Kd,rsqrtImpl:()=>Ww,scatterImpl:()=>Es,sigmoidImpl:()=>a1,simpleAbsImpl:()=>Sw,sliceImpl:()=>Hw,sparseFillEmptyRowsImpl:()=>qd,sparseReshapeImpl:()=>jd,sparseSegmentReductionImpl:()=>gc,sqrtImpl:()=>c1,squaredDifferenceImpl:()=>Kw,stridedSliceImpl:()=>Xd,stringNGramsImpl:()=>Yd,stringSplitImpl:()=>Zd,stringToHashBucketFastImpl:()=>Jd,subImpl:()=>jw,tileImpl:()=>Qd,topKImpl:()=>tg,transposeImpl:()=>hc,uniqueImpl:()=>eg});function Sw(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var kV=r=>{let{x:t}=r.inputs,e=r.backend;j(t,"abs");let o=new Float32Array(y.sizeFromShape(t.shape)),n=e.data.get(t.dataId).values;return o=Sw(n),e.makeOutput(o,t.shape,t.dtype)},Fv={kernelName:Ms,backendName:"cpu",kernelFunc:kV};function Ot(r){return(t,e,o,n,s)=>{let i=S.assertAndGetBroadcastShape(t,e),a=i.length,l=y.computeStrides(i),u=y.sizeFromShape(i),c=y.getTypedArrayFromDType(s,u),p=t.length,m=e.length,f=y.computeStrides(t),h=y.computeStrides(e),d=S.getBroadcastDims(t,i),g=S.getBroadcastDims(e,i);if(d.length+g.length===0)for(let x=0;x<c.length;++x)c[x]=r(o[x%o.length],n[x%n.length]);else for(let x=0;x<c.length;++x){let b=y.indexToLoc(x,a,l),C=b.slice(-p);d.forEach(A=>C[A]=0);let w=y.locToIndex(C,p,f),I=b.slice(-m);g.forEach(A=>I[A]=0);let E=y.locToIndex(I,m,h);c[x]=r(o[w],n[E])}return[c,i]}}function _e(r){let{inputs:t,backend:e}=r,{real:o,imag:n}=t,s=e.data.get(o.dataId).values,i=e.data.get(n.dataId).values,a=e.makeTensorInfo(o.shape,"complex64"),l=e.data.get(a.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(o.shape,"float32",s),imag:e.makeTensorInfo(n.shape,"float32",i)},a}var _v={kernelName:$l,backendName:"cpu",kernelFunc:_e};function pc(r,t,e="float32"){if(e==="complex64"){let n=pc(r,t,"float32"),s=pc(r,t,"float32");return _e({inputs:{real:n,imag:s},backend:r})}let o=y.makeZerosTypedArray(y.sizeFromShape(t),e);return r.makeTensorInfo(t,e,o)}function rr(r){let{inputs:t,backend:e}=r,{x:o}=t;return e.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}var Ov={kernelName:Ho,backendName:"cpu",kernelFunc:rr};function yo(r){let{inputs:t,backend:e}=r,{input:o}=t,n=e.data.get(o.dataId).complexTensorInfos.real,s=e.data.get(n.dataId).values;return e.makeTensorInfo(n.shape,n.dtype,s)}var Lv={kernelName:Ql,backendName:"cpu",kernelFunc:yo};function Nw(r,t,e,o){if(o==="int32"){let n=Int32Array.from(r);return[t,"int32",n]}if(o==="bool"){let n=y.toTypedArray([0],e),[s,i]=Ot((a,l)=>a!==l?1:0)(t,[],r,n,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${o}`)}function bo(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{dtype:s}=o;if(s==="complex64"){if(n.dtype==="complex64")return rr({inputs:{x:n},backend:e});let c=pc(e,n.shape,n.dtype),p=bo({inputs:{x:n},backend:e,attrs:{dtype:"float32"}}),m=_e({inputs:{real:p,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),m}if(n.dtype==="complex64"){let c=yo({inputs:{input:n},backend:e}),p=bo({inputs:{x:c},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(c),p}if(!y.hasEncodingLoss(n.dtype,s)){let c=rr({inputs:{x:n},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=e.data.get(n.dataId).values,[a,l,u]=Nw(i,n.shape,n.dtype,s);return e.makeTensorInfo(a,l,u)}var Pv={kernelName:Uo,backendName:"cpu",kernelFunc:bo};function Mt(r,t,e,o){return e==null?({inputs:n,backend:s})=>{let{a:i,b:a}=n,l=s;j([i,a],r);let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(u):u,m=i.dtype==="string"?S.fromUint8ToStringArray(c):c,f=o||i.dtype,[h,d]=t(i.shape,a.shape,p,m,f);return l.makeTensorInfo(d,f,h)}:({inputs:n,backend:s})=>{let{a:i,b:a}=n,l=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let u=bo({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=l.data.get(p.dataId).values,h=l.data.get(m.dataId).values,d=bo({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(d.dataId),x=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,C=l.data.get(x.dataId).values,w=l.data.get(b.dataId).values,[I,E,A]=e(i.shape,a.shape,f,h,C,w),$=l.makeTensorInfo(A,"float32",I),_=l.makeTensorInfo(A,"float32",E),L=_e({inputs:{real:$,imag:_},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(d),l.disposeIntermediateTensorInfo($),l.disposeIntermediateTensorInfo(_),L}else{let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=o||i.dtype,[m,f]=t(i.shape,a.shape,u,c,p);return l.makeTensorInfo(f,p,m)}}}function mc(r){return(t,e,o,n,s,i)=>{let a=S.assertAndGetBroadcastShape(t,e),l=y.sizeFromShape(a),u=a.length,c=y.computeStrides(a),p=y.getTypedArrayFromDType("float32",l),m=y.getTypedArrayFromDType("float32",l),f=S.getBroadcastDims(t,a),h=S.getBroadcastDims(e,a),d=S.mergeRealAndImagArrays(o,n),g=S.mergeRealAndImagArrays(s,i),x=t.length,b=y.computeStrides(t),C=e.length,w=y.computeStrides(e);if(f.length+h.length===0)for(let I=0;I<p.length;I++){let E=I%d.length,A=I%g.length,$=r(d[E*2],d[E*2+1],g[A*2],g[A*2+1]);p[I]=$.real,m[I]=$.imag}else for(let I=0;I<p.length;I++){let E=y.indexToLoc(I,u,c),A=E.slice(-x);f.forEach(V=>A[V]=0);let $=y.locToIndex(A,x,b),_=E.slice(-C);h.forEach(V=>_[V]=0);let L=y.locToIndex(_,C,w),B=r(d[$*2],d[$*2+1],g[L*2],g[L*2+1]);p[I]=B.real,m[I]=B.imag}return[p,m,a]}}var Tw=Ot((r,t)=>r+t),EV=mc((r,t,e,o)=>({real:r+e,imag:t+o})),an=Mt(vo,Tw,EV),zv={kernelName:vo,backendName:"cpu",kernelFunc:an};function fc(r,t,e,o,n){let s=y.sizeFromShape(o),i=y.makeZerosTypedArray(n,e);for(let a=0;a<r.length;a++){let l=r[a];if(l<0)throw new Error("Input x must be non-negative!");l>=n||(s>0?i[l]+=t[a]:i[l]+=1)}return i}function Pd(r,t,e,o=!1){let n=r.shape[0],s=r.shape[1],i=ft([n,e],t.dtype);for(let a=0;a<n;a++)for(let l=0;l<s;l++){let u=r.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||(o?i.set(1,a,u):t.size>0?i.set(i.get(a,u)+t.get(a,l),a,u):i.set(i.get(a,u)+1,a,u))}return i}function yr(r){return(t,e,o)=>{let n=y.getTypedArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)n[s]=r(t[s],o);return n}}function bt(r,t,e){return({inputs:o,attrs:n,backend:s})=>{let{x:i}=o;if(j(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,l=a.data.get(i.dataId).values,u=y.sizeFromShape(i.shape),c=e||i.dtype,p=y.getArrayFromDType(c,u);for(let m=0;m<u;++m)p[m]=t(l[m],n);return a.makeTensorInfo(i.shape,c,p)}}function wo(r,t,e){return({inputs:o,attrs:n,backend:s})=>{let{x:i}=o;if(j(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,l=a.data.get(i.dataId).values,u=e||i.dtype,c=t(l,u,n);return a.makeTensorInfo(i.shape,u,c)}}var vw=yr(r=>Math.ceil(r)),AV=wo(Nn,vw),Mv={kernelName:Nn,backendName:"cpu",kernelFunc:AV};function zd(r,t,e,o){let n=y.getArrayFromDType(e,y.sizeFromShape(t));if(o&&e!=="string"){let s=0;r.forEach(i=>{let a=y.sizeFromShape(i.shape);n.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=e==="string"?S.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*t[1]+s;for(let p=0;p<i.shape[1];++p)n[c+p]=a[l++]}s+=i.shape[1]})}return n}var kw=Ot((r,t)=>r===t?1:0),Ew=Mt(la,kw,null,"bool"),Bv={kernelName:la,backendName:"cpu",kernelFunc:Ew};var Aw=yr(r=>Math.exp(r)),$w=wo(Dn,Aw,"float32"),Vv={kernelName:Dn,backendName:"cpu",kernelFunc:$w};var Dw=yr(r=>Math.expm1(r)),$V=wo(Rn,Dw),Gv={kernelName:Rn,backendName:"cpu",kernelFunc:$V};var Rw=yr(r=>Math.floor(r)),DV=wo(Fn,Rw),Wv={kernelName:Fn,backendName:"cpu",kernelFunc:DV};function Md(r,t,e,o,n,s,i,a,l){let u=ft([o,s],e);for(let c=0;c<o;c++){let p=[],m=0;for(let f=0;f<n;f++){let h=r[c*n+f];m+=h*i[f],p.push(h)}if(m<0||m>=l/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)u.values[c*s+f]=t.get(...t.indexToLoc(m*s+f))}return u}function Bd(r,t,e){let o=ft(e,r.dtype);for(let n=0;n<o.size;++n){let i=o.indexToLoc(n).slice(),a=i[0],l=i[2],u=t.locToIndex([a,l]);i[2]=t.values[u];let c=r.locToIndex(i);0<=c&&c<r.values.length&&(o.values[n]=r.values[c])}return o}var Fw=Ot((r,t)=>r>t?1:0),RV=Mt(ua,Fw,null,"bool"),Uv={kernelName:ua,backendName:"cpu",kernelFunc:RV};var _w=Ot((r,t)=>r>=t?1:0),FV=Mt(On,_w,null,"bool"),Hv={kernelName:On,backendName:"cpu",kernelFunc:FV};var Ow=Ot((r,t)=>r<t?1:0),_V=Mt(ca,Ow,null,"bool"),Kv={kernelName:ca,backendName:"cpu",kernelFunc:_V};var Lw=Ot((r,t)=>r<=t?1:0),OV=Mt(pa,Lw,null,"bool"),qv={kernelName:pa,backendName:"cpu",kernelFunc:OV};function Vd(r,t,e){let o=(t-r)/(e-1),n=y.makeZerosTypedArray(e,"float32");n[0]=r;for(let s=1;s<n.length;s++)n[s]=n[s-1]+o;return n}var Pw=yr(r=>Math.log(r)),LV=wo(Mn,Pw),jv={kernelName:Mn,backendName:"cpu",kernelFunc:LV};function Gd(r,t,e,o){let n=y.getTypedArrayFromDType(o,y.sizeFromShape(e));for(let s=0;s<n.length;++s){let i=s*t,a=r[i];for(let l=0;l<t;++l){let u=r[i+l];(Number.isNaN(u)||u>a)&&(a=u)}n[s]=a}return n}var zw=Ot((r,t)=>Math.max(r,t)),PV=Mt(Vn,zw),Xv={kernelName:Vn,backendName:"cpu",kernelFunc:PV};var Mw=Ot((r,t)=>Math.min(r,t)),zV=Mt(Gn,Mw),Yv={kernelName:Gn,backendName:"cpu",kernelFunc:zV};var Jm=Ot((r,t)=>r*t),MV=mc((r,t,e,o)=>({real:r*e-t*o,imag:r*o+t*e})),ol=Mt(Un,Jm,MV),Zv={kernelName:Un,backendName:"cpu",kernelFunc:ol};function Bw(r,t,e){let o=y.createScalarValue(-1,e);return Jm([],t,o,r,e)}function BV(r){let{inputs:t,backend:e}=r,{x:o}=t;j(o,"neg");let n=e.data.get(o.dataId).values,[s,i]=Bw(n,o.shape,o.dtype);return e.makeTensorInfo(i,o.dtype,s)}var Jv={kernelName:pi,backendName:"cpu",kernelFunc:BV};var Vw=Ot((r,t)=>r!==t?1:0),VV=Mt(da,Vw,null,"bool"),Qv={kernelName:da,backendName:"cpu",kernelFunc:VV};function hc(r,t,e,o,n){let s=t.length,i=y.sizeFromShape(t),a=y.computeStrides(t),l=y.computeStrides(n),u=y.getTypedArrayFromDType(e,y.sizeFromShape(n));for(let c=0;c<i;++c){let p=y.indexToLoc(c,s,a),m=new Array(p.length);for(let h=0;h<m.length;h++)m[h]=p[o[h]];let f=y.locToIndex(m,s,l);u[f]=r[c]}return u}function fe(r){let{inputs:t,attrs:e,backend:o}=r,{x:n}=t,{perm:s}=e;j(n,"transpose");let i=n.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=n.shape[s[p]];let l=o.data.get(n.dataId).values,u=hc(l,n.shape,n.dtype,s,a);return{dataId:o.write(u,a,n.dtype),shape:a,dtype:n.dtype}}var t1={kernelName:qo,backendName:"cpu",kernelFunc:fe};function Gw(r,t,e,o){let[n,s]=S.computeOutAndReduceShapes(r,o),i=Te(t,"int32"),a=y.makeZerosTypedArray(y.sizeFromShape(n),i),l=y.sizeFromShape(s);for(let u=0;u<a.length;++u){let c=u*l,p=1;for(let m=0;m<l;++m)p*=e[c+m];a[u]=p}return{outVals:a,outShape:n,outDtype:i}}function GV(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o;j(n,"prod");let a=n.shape.length,l=y.parseAxisParam(s,n.shape),u=S.getAxesPermutation(l,a),c=l,p=n,m=[];u!=null&&(p=fe({inputs:{x:n},backend:e,attrs:{perm:u}}),m.push(p),c=S.getInnerMostAxes(c.length,a));let f=e.data.get(p.dataId).values,{outVals:h,outShape:d,outDtype:g}=Gw(p.shape,p.dtype,f,c),x=d;return i&&(x=S.expandShapeToKeepDim(d,l)),m.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(x,g,h)}var e1={kernelName:xi,backendName:"cpu",kernelFunc:GV};function WV(r,t,e){r.forEach((o,n)=>{if(o<0||o>=e){let s=y.indexToLoc(n,t.length,y.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${o} is not in [0, ${e})`)}})}function UV(r,t){for(let e=0;e<r.length;++e){let o=r[e],n=e===r.length-1?t:r[e+1].length;if(o.length===0)throw new Error("Ragged splits may not be empty");if(o[0]<0)throw new Error("Ragged splits must be non-negative");if(o[o.length-1]>n)throw new Error("Ragged splits must not point past values");for(let s=1;s<o.length;++s)if(o[s-1]>o[s])throw new Error("Ragged splits must be sorted in ascending order")}}function HV(r,t,e,o){let n=[],s=0,i=t.length-1+e.length,a=new Array(i).fill(null).map(()=>[0]);UV(e,o);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let p=1;p<l+1;++p)a[u].push(p*c)}for(let u=0;u<r.length;++u){let c=r[u],p=r[u]+1;for(let m=0;m<e.length;++m){let f=e[m],h=m+t.length-1;if(h>=0){let d=a[h],g=d[d.length-1]-f[c];for(let x=c;x<p;++x)a[h].push(f[x+1]+g)}c=f[c],p=f[p]}p!==c&&(n.push([c,p]),s+=p-c)}return{outSplits:a,valueSlices:n,numValues:s}}function KV(r){let t=[];for(let e=0;e<r.length;++e){let o=r[e].length,n=y.getArrayFromDType("int32",o);t.push(n),r[e].forEach((s,i)=>n[i]=s)}return t}function r1(r,t){let e=r.slice(0,t);for(;e.length<t;)e.push(1);for(let o=t;o<r.length;o++)e[t-1]*=r[o];return e}function qV(r,t,e,o,n,s){let i=r1(t,2)[1],a=r1(s,2)[1],l=0;for(let u of e)for(let c=u[0];c<u[1];++c){for(let p=0;p<o;++p)n[l*a+p]=r[c*i+p];++l}}function jV(r,t,e,o,n){let s=t.slice();s[0]=n;let i=y.getArrayFromDType(e,y.sizeFromShape(s)),a=r.length,l=a===0?0:a/t[0];return qV(r,t,o,l,i,s),[i,s]}function Wd(r,t,e,o,n,s,i,a){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(WV(s,i,l),o.length===0)throw new Error("params.rank must be nonzero");let u=o[0],{outSplits:c,valueSlices:p,numValues:m}=HV(s,i,r,u),f=KV(c),h=jV(e,o,n,p,m);return[f,h[0],h[1]]}var o1=2147483647;function Ud(r,t,e,o,n,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(n.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=t.length===0,l=n.length===0,u=i.length===0,c=[];a||c.push(t[0]),l||c.push(n[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let p=c.length===0?1:c[0],m=y.getArrayFromDType("int32",p+1);m[0]=0;for(let g=0;g<p;++g){let x=a?r[0]:r[g],b=l?o[0]:o[g],C=u?s[0]:s[g];if(C===0)throw new Error("Requires delta != 0");let w;if(C>0&&b<x||C<0&&b>x)w=0;else if(w=Math.ceil(Math.abs((b-x)/C)),w>o1)throw new Error(`Requires ((limit - start) / delta) <= ${o1}`);m[g+1]=m[g]+w}let f=m[p],h=y.getArrayFromDType(e,f),d=0;for(let g=0;g<p;++g){let x=m[g+1]-m[g],b=a?r[0]:r[g],C=u?s[0]:s[g];for(let w=0;w<x;++w)h[d++]=b,b+=C}return[m,h]}var Co=S.RowPartitionType,dc=class{constructor(t,e,o,n,s,i,a,l,u,c){this.shape=t,this.shapeShape=e,this.values=o,this.valuesShape=n,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=S.getRowPartitionTypesHelper(c),this.raggedRank=S.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Co.VALUE_ROWIDS:return dc.getMaxWidthValueRowID(e);case Co.ROW_SPLITS:return dc.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Co[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let e=t.length;if(e===0||e===1)return 0;let o=0;for(let n=0;n<e-1;++n){let s=t[n+1]-t[n];s>o&&(o=s)}return o}static getMaxWidthValueRowID(t){let e=t.length;if(e===0)return 0;let o=0,n=t[0],s=0;for(let i=1;i<e;++i){let a=t[i];a!==n&&(n=a,s=Math.max(i-o,s),o=i)}return Math.max(e-o,s)}tensorShapeFromTensor(t,e,o=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return s1(t,o)}calculateOutputSize(t){let e=this.valuesShape,o=this.defaultValueShape;S.validateDefaultValueShape(o,e);let n=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=S.combineRaggedTensorToTensorShapes(this.raggedRank,n,e);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,e,o){let n=Math.min(t,o),s=[],i=0;for(let a=0;a<n;++a,i+=e)s.push(i);for(let a=n;a<t;++a)s.push(-1);return y.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,o,n){let s=t.length,i=[];for(let a=0;a<s-1;++a){let l=t[a+1]-t[a],u=Math.min(n,l),c=e[a];c===-1&&(u=0);for(let p=0;p<u;++p)i.push(c),c+=o;for(let p=0;p<l-u;++p)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,o,n){let s=t.length,i=[];if(s===0)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];i.push(u);for(let c=1;c<s;++c){let p=t[c];if(p===l)u>=0&&(++a,a<n?u+=o:u=-1);else{if(a=0,l=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);u=e[p]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,o,n){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Co.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,o,n);case Co.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,o,n);default:throw new Error(`Unsupported partition type: ${Co[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let e=this.rowPartitionTypes[0];switch(e){case Co.FIRST_DIM_SIZE:return t[0];case Co.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Co.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Co[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),o=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let l=n.length-2;l>=0;--l)n[l]=n[l+1]*o[l+1];let s=s1(o,!1),i=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(n[0]*o[0]>0){let l=this.calculateFirstParentOutputIndex(e,n[0],o[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,n[u],o[u]);this.setOutput(this.raggedRank,l,i,s)}return[s,i]}setOutput(t,e,o,n){if(o.length===0)return;let s=this.values,i=o,a=n.slice();a=a.slice(t+1);let l=y.sizeFromShape(a),u=e.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let h=this.defaultValueShape;z(()=>{let d=F(c,h);c=ms(d,a).dataSync()})}let p=0,m=0,f=0;for(let h=0;h<=u;++h){let d=h<u?e[h]:-1;if(d===f){++f;continue}if(m<f){let g=s.subarray(p*l),x=i.subarray(m*l),b=(f-m)*l;n1(x,g,b)}if(h>=u){let g=o.length;d=Math.floor(g/l)}if(d>f)if(this.defaultValue.length===1)i.subarray(f*l,d*l).fill(this.defaultValue[0]),f=d;else for(;d>f;){let g=i.slice(f*l);n1(g,c,l),++f}d<0?(p=h+1,m=f):(p=h,m=f,f=m+1)}}};function n1(r,t,e){for(let o=0;o<e;o++)r[o]=t[o]}function s1(r,t){let e=[];for(let o of r){if(o<0){if(!t)throw new Error(`Dimension ${o} must be >= 0`);if(o<-1)throw new Error(`Dimension ${o} must be >= -1`);o=-1}e.push(o)}return e}function Hd(r,t,e,o,n,s,i,a,l,u){return new dc(r,t,e,o,n,s,i,a,l,u).compute()}function Kd(r,t,e,o){let n=r===t,s=r<t&&e<0,i=t<r&&e>1;if(n||s||i)return y.makeZerosTypedArray(0,o);let a=Math.abs(Math.ceil((t-r)/e)),l=y.makeZerosTypedArray(a,o);t<r&&e===1&&(e=-1),l[0]=r;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}var Ww=yr(r=>1/Math.sqrt(r)),XV=wo(Yn,Ww),i1={kernelName:Yn,backendName:"cpu",kernelFunc:XV};function Es(r,t,e,o,n,s,i,a,l,u){let c=[o/n,n],p=r.values,m=t.values;if(o===0)return ft(e,t.dtype);let f=ft(c,t.dtype);typeof l=="string"||typeof l=="number"?f.values.fill(l):typeof l=="boolean"&&f.values.fill(+l);for(let h=0;h<s;h++){let d=[],g=0;for(let x=0;x<i;x++){let b=p[h*i+x];d.push(b),g+=b*a[x]}if(g<0||g>=o/n)throw new Error(`Invalid indices: ${d} does not index into ${e}`);for(let x=0;x<n;x++)u?f.values[g*n+x]+=m[h*n+x]:f.values[g*n+x]=t.rank===0?m[0]:m[h*n+x]}return f}var a1=yr(r=>1/(1+Math.exp(-r))),Uw=bt(es,r=>1/(1+Math.exp(-r))),l1={kernelName:es,backendName:"cpu",kernelFunc:Uw};function Hw(r,t,e,o,n){let s=Pe.isSliceContinous(o,t,e),i=y.sizeFromShape(e),a=y.computeStrides(o);if(s){let p=Pe.computeFlatOffset(t,a);return n==="string"?r.slice(p,p+i):r.subarray(p,p+i)}let l=n==="string"?S.fromUint8ToStringArray(r):r,u=ft(o,n,l),c=ft(e,n);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),f=m.map((h,d)=>h+t[d]);c.set(u.get(...f),...m)}return n==="string"?S.fromStringArrayToUint8(c.values):c.values}function Io(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{begin:s,size:i}=o;j(n,"slice");let[a,l]=Pe.parseSliceParams(n,s,i);Pe.assertParamsValid(n,a,l);let u=e.data.get(n.dataId).values,c=Hw(u,a,l,n.shape,n.dtype);return e.makeTensorInfo(l,n.dtype,c)}var u1={kernelName:Si,backendName:"cpu",kernelFunc:Io};function qd(r,t,e,o,n,s,i){let a=t[0],l=s[0],u=new Array(l),c=new Array(a),p=t[1];if(l===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=y.getArrayFromDType(e,0),x=y.getArrayFromDType(n,0);return[g,[0,p],x,u,c]}let m=!0,f=0,h=new Array(l).fill(0);for(let g=0;g<a;++g){let x=r[g*p];if(x<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,x));if(x>=l)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,x,l));++h[x],m=m&&x>=f,f=x}let d=!0;for(let g=0;g<l;++g){let x=h[g]===0;u[g]=x,d=d&&!x,h[g]=Math.max(h[g],1),g>0&&(h[g]+=h[g-1])}if(d&&m){let g=r,x=o;for(let b=0;b<a;++b)c[b]=b;return[g,[a,p],x,u,c]}else{let g=h[l-1],x=y.getArrayFromDType(e,g*p),b=y.getArrayFromDType(n,g),C=new Array(l).fill(0);for(let w=0;w<a;++w){let I=r[w*p],E=C[I],A=(I===0?0:h[I-1])+E;C[I]++;for(let $=0;$<p;++$)x[A*p+$]=r[w*p+$];b[A]=o[w],c[w]=A}for(let w=0;w<l;++w)if(C[w]===0){let E=w===0?0:h[w-1];x[E*p+0]=w;for(let A=1;A<p;++A)x[E*p+A]=0;b[E]=i}return[x,[g,p],b,u,c]}}function jd(r,t,e,o,n){let s=y.sizeFromShape(o),i=t[0],a=n.length,l=[],u=1,c=-1;for(let g=0;g<a;++g){let x=n[g];if(x===-1){if(c!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,l.push(1)}else{if(x<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,x));u*=x,l.push(x)}}if(c!==-1){if(u<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/u);if(u*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(o,l));l[c]=g}if(y.sizeFromShape(l)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(o,l));let m=o.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*o[g+1]}let h=[];if(a>0){h[a-1]=1;for(let g=a-2;g>=0;--g)h[g]=h[g+1]*l[g+1]}let d=y.getArrayFromDType(e,i*a);for(let g=0;g<i;++g){let x=0;for(let b=0;b<m;++b)x+=r[g*m+b]*f[b];for(let b=0;b<a;++b)d[g*a+b]=Math.trunc(x/h[b]),x%=h[b]}return[d,[i,a],l]}function gc(r,t,e,o,n,s=!1,i=0){let a=o.length,l=[t[0],r.length/t[0]],u=l[1],p=a>0?n[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=t.slice();m[0]=p;let f=m.reduce((C,w)=>C*w,1),h=y.getArrayFromDType(e,f);if(a===0)return p>0&&h.fill(i),[h,m];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=0,g=1,x=0,b=n[d];for(;;){let C=0;if(g<a){if(C=n[g],b===C){++g;continue}if(b>=C)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>x&&h.fill(i,x*u,b*u);for(let w=d;w<g;++w){let I=o[w];if(I<0||I>=l[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w,o[w],l[0]));for(let E=0;E<u;E++)h[b*u+E]+=r[I*u+E]}if(s)for(let w=0;w<u;w++)h[b*u+w]/=g-d;if(d=g,++g,x=b+1,b=C,g>a)break}return x<p&&h.fill(i,x*u,p*u),[h,m]}var c1=yr(r=>Math.sqrt(r)),YV=bt(os,r=>Math.sqrt(r)),p1={kernelName:os,backendName:"cpu",kernelFunc:YV};var Kw=Ot((r,t)=>{let e=r-t;return e*e}),ZV=Mt(ns,Kw),m1={kernelName:ns,backendName:"cpu",kernelFunc:ZV};function Xd(r,t,e,o){let n=ft(r,t.dtype);for(let s=0;s<n.size;s++){let i=n.indexToLoc(s),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+o[l];n.set(t.get(...a),...i)}return n}var qw=class{constructor(t,e,o,n,s,i){this.separator=y.encodeString(t),this.nGramWidths=e,this.leftPad=y.encodeString(o),this.rightPad=y.encodeString(n),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let o=this.getPadWidth(e);return Math.max(0,t+2*o-e+1)}createNGrams(t,e,o,n,s,i){for(let a=0;a<s;++a){let l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(s-(a+1))),p=i-(u+c),m=e+(u>0?0:a-l),f=0;f+=u*this.leftPad.length;for(let b=0;b<p;++b)f+=t[m+b].length;f+=c*this.rightPad.length;let h=u+c+p-1;f+=h*this.separator.length,o[n+a]=new Uint8Array(f);let d=o[n+a],g=0,x=b=>b.forEach(C=>d[g++]=C);for(let b=0;b<u;++b)x(this.leftPad),x(this.separator);for(let b=0;b<p-1;++b)x(t[m+b]),x(this.separator);if(p>0){x(t[m+p-1]);for(let b=0;b<c;++b)x(this.separator),x(this.rightPad)}else{for(let b=0;b<c-1;++b)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(t,e){let o=t.length,n=e.length;if(n>0){let l=e[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<n;++u){let c=e[u]>=l;if(c=c&&e[u]<=o,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${o}]`);l=e[u]}if(l!==o)throw new Error(`Last split value must be data size. Expected ${o}, got ${l}`)}let s=n-1,i=y.getArrayFromDType("int32",n);if(o===0||n===0){let l=new Array(o);for(let u=0;u<=s;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=s;++l){let u=e[l]-e[l-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(u,p)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}let a=new Array(i[s]);for(let l=0;l<s;++l){let u=e[l],c=i[l];if(this.nGramWidths.forEach(p=>{let m=e[l+1]-e[l],f=this.getNumNGrams(m,p);this.createNGrams(t,u,a,c,f,p),c+=f}),this.preserveShort&&c===i[l]){let p=e[l+1]-e[l];if(p===0)continue;let m=p+2*this.padWidth,f=1;this.createNGrams(t,u,a,c,f,m)}}return[a,i]}};function Yd(r,t,e,o,n,s,i,a){return new qw(e,o,n,s,i,a).compute(r,t)}function JV(r,t,e,o){if(!r.length)return;if(t.length===0){for(let s=0;s<r.length;++s)o.push(r.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!e||a.length!==0)&&o.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!e||r.length!==0)&&o.push(r);return}let n=0;for(let s=0;s<r.length+1;s++)if(s===r.length||t.indexOf(r[s])!==-1){let i=r.subarray(n,s);(!e||i.length!==0)&&o.push(i),n=s+1}}function Zd(r,t,e){let o=r.length,n=[],s=0,i=0,a=new Array(o);for(let m=0;m<o;++m){let f=n.length;JV(r[m],t,e,n);let h=n.length-f;a[m]=h,s+=h,i=Math.max(i,h)}let l=y.getArrayFromDType("int32",s*2),u=new Array(s),c=[o,i],p=0;for(let m=0;m<o;++m)for(let f=0;f<a[m];++f)l[p*2]=m,l[p*2+1]=f,u[p]=n[p],++p;return[l,u,c]}function Jd(r,t){let e=y.getArrayFromDType("int32",r.length);for(let o=0;o<r.length;++o)e[o]=y.fingerPrint64(r[o]).modulo(t).getLowBitsUnsigned();return e}var jw=Ot((r,t)=>r-t),QV=mc((r,t,e,o)=>({real:r-e,imag:t-o})),Qm=Mt(ss,jw,QV),f1={kernelName:ss,backendName:"cpu",kernelFunc:Qm};function Qd(r,t){let e=new Array(r.rank);for(let n=0;n<e.length;n++)e[n]=r.shape[n]*t[n];let o=ft(e,r.dtype);for(let n=0;n<o.values.length;++n){let s=o.indexToLoc(n),i=new Array(r.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%r.shape[l];let a=r.locToIndex(i);o.values[n]=r.values[a]}return o}var tf=(r,t)=>{let e=t.value-r.value;return e===0?r.index-t.index:e};function h1(r,t,e=0,o=r.length-1){for(;o>e;){if(o-e>600){let a=o-e+1,l=t-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),m=Math.max(e,Math.floor(t-l*c/a+p)),f=Math.min(o,Math.floor(t+(a-l)*c/a+p));h1(r,t,m,f)}let n=r[t],s=e,i=o;for(y.swap(r,e,t),tf(r[o],n)>0&&y.swap(r,e,o);s<i;){for(y.swap(r,s,i),s++,i--;tf(r[s],n)<0;)s=s+1;for(;tf(r[i],n)>0;)i=i-1}tf(r[e],n)===0?y.swap(r,e,i):(i=i+1,y.swap(r,i,o)),i<=t&&(e=i+1),t<=i&&(o=i-1)}}function tg(r,t,e,o,n){let s=t[t.length-1],[i,a]=[r.length/s,s],l=y.getTypedArrayFromDType(e,i*o),u=y.getTypedArrayFromDType("int32",i*o);for(let p=0;p<i;p++){let m=p*a,f=r.subarray(m,m+a),h=new Array(f.length);f.forEach((b,C)=>h[C]={value:b,index:C}),o<h.length&&(h1(h,o),h=h.slice(0,o)),n&&h.sort(tf);let d=p*o,g=l.subarray(d,d+o),x=u.subarray(d,d+o);for(let b=0;b<o;b++)g[b]=h[b].value,x[b]=h[b].index}let c=t.slice();return c[c.length-1]=o,[ft(c,e,l),ft(c,"int32",u)]}function eg(r,t,e,o){let n=y.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let h=0;h<n;h++)s[0]*=e[h];s[1]=e[n];for(let h=n+1;h<e.length;h++)s[2]*=e[h];let i={},a=new Int32Array(e[n]),l=new Ut(s,o,r),u=[],c=s[0]===1&&s[2]===1;for(let h=0;h<e[n];h++){let d;if(c)d=r[h].toString();else{let g=[];for(let x=0;x<s[0];x++)for(let b=0;b<s[2];b++)g.push(l.get(x,h,b));d=g.join(",")}if(i[d]!==void 0)a[h]=i[d];else{let g=Object.keys(i).length;i[d]=g,a[h]=g,u.push(h)}}let p=s.slice();p[1]=Object.keys(i).length;let m=new Ut(p,o);u.forEach((h,d)=>{for(let g=0;g<s[0];g++)for(let x=0;x<s[2];x++)m.set(l.get(g,h,x),g,d,x)});let f=e.slice();return f[n]=p[1],{outputValues:m.values,outputShape:f,indices:a}}nh("cpu",()=>new rl,1);var Yw=bt(An,r=>r>=0?r:Math.exp(r)-1),d1={kernelName:An,backendName:"cpu",kernelFunc:Yw};function Zw(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{alpha:s}=o;j([n],"leakyRelu");let i=y.sizeFromShape(n.shape),a=e.data.get(n.dataId).values,l=y.getTypedArrayFromDType("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?s*a[u]:a[u];return e.makeTensorInfo(n.shape,"float32",l)}var g1={kernelName:oi,backendName:"cpu",kernelFunc:Zw};var tG=Ot((r,t)=>r<0?t*r:r);function Jw(r){let{inputs:t,backend:e}=r,{x:o,alpha:n}=t;j([o,n],"prelu");let s=e.data.get(o.dataId).values,i=e.data.get(n.dataId).values,[a,l]=tG(o.shape,n.shape,s,i,"float32");return e.makeTensorInfo(l,"float32",a)}var x1={kernelName:gi,backendName:"cpu",kernelFunc:Jw};var Qw=bt(qn,r=>Math.max(0,r)),y1={kernelName:qn,backendName:"cpu",kernelFunc:Qw};var t0=bt(jn,r=>Math.min(Math.max(0,r),6)),b1={kernelName:jn,backendName:"cpu",kernelFunc:t0};function nl(r,t,e,o,n){if(e==="linear")return rr({inputs:{x:t},backend:r});if(e==="relu")return Qw({inputs:{x:t},backend:r});if(e==="elu")return Yw({inputs:{x:t},backend:r});if(e==="relu6")return t0({inputs:{x:t},backend:r});if(e==="prelu")return Jw({inputs:{x:t,alpha:o},backend:r});if(e==="leakyrelu")return Zw({inputs:{x:t},backend:r,attrs:{alpha:n}});if(e==="sigmoid")return Uw({inputs:{x:t},backend:r});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Dt(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{shape:s}=o,i=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(s,i),l=y.sizeFromShape(a);y.assert(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${n.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(n.dataId);let u=e.data.get(n.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:n.dataId,shape:a,dtype:n.dtype}}var w1={kernelName:yi,backendName:"cpu",kernelFunc:Dt};function e0(r){let{inputs:t,backend:e,attrs:o}=r,{a:n,b:s}=t,{transposeA:i,transposeB:a}=o;j([n,s],"matMul");let l=n.shape.length,u=s.shape.length,c=i?n.shape[l-2]:n.shape[l-1],p=a?s.shape[u-1]:s.shape[u-2],m=i?n.shape[l-1]:n.shape[l-2],f=a?s.shape[u-2]:s.shape[u-1],h=n.shape.slice(0,-2),d=s.shape.slice(0,-2),g=y.sizeFromShape(h),x=y.sizeFromShape(d),C=Rr.assertAndGetBroadcastShape(n.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);y.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${n.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let w=i?[g,c,m]:[g,m,c],I=a?[x,f,p]:[x,p,f],E=Dt({inputs:{x:n},backend:e,attrs:{shape:w}}),A=Dt({inputs:{x:s},backend:e,attrs:{shape:I}}),$=i?E.shape[1]:E.shape[2],_=i?E.shape[2]:E.shape[1],L=a?A.shape[1]:A.shape[2],B=Math.max(g,x),V=e.data.get(E.dataId).values,G=e.data.get(A.dataId).values,U=y.computeStrides(E.shape),W=y.computeStrides(A.shape),[q,Z,K]=i?[U[0],1,U[1]]:[U[0],U[1],1],[J,tt,et]=a?[1,W[1],W[0]]:[W[1],1,W[0]],nt=_*L,rt=ft([B,_,L],E.dtype),lt=rt.values,st=e.blockSize;for(let pt=0;pt<B;pt++){let It=pt%g,Tt=pt%x;for(let St=0;St<_;St+=st){let Ft=Math.min(St+st,_);for(let Lt=0;Lt<L;Lt+=st){let Qt=Math.min(Lt+st,L);for(let le=0;le<$;le+=st){let Ne=Math.min(le+st,$);for(let ue=St;ue<Ft;ue++)for(let oe=Lt;oe<Qt;oe++){let Se=0;for(let ye=le;ye<Ne;ye++){let fn=V[It*q+ue*Z+ye*K],Ye=G[ye*J+oe*tt+Tt*et];Se+=fn*Ye}lt[pt*nt+(ue*L+oe)]+=Se}}}}}return e.disposeIntermediateTensorInfo(E),e.disposeIntermediateTensorInfo(A),e.makeTensorInfo(C,rt.dtype,rt.values)}var C1={kernelName:Us,backendName:"cpu",kernelFunc:e0};function eG(r){let{inputs:t,backend:e,attrs:o}=r,{a:n,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=o,m,f,h,d=[];m=e0({inputs:{a:n,b:s},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(f=an({inputs:{a:m,b:i},backend:e}),d.push(m),m=f),c&&(h=nl(e,m,c,a,p),d.push(m),m=h);for(let x of d)e.disposeIntermediateTensorInfo(x);return m}var I1={kernelName:ga,backendName:"cpu",kernelFunc:eG};var rG=bt(xn,r=>Math.acos(r)),S1={kernelName:xn,backendName:"cpu",kernelFunc:rG};var oG=bt(yn,r=>Math.acosh(r)),N1={kernelName:yn,backendName:"cpu",kernelFunc:oG};function nG(r){let{inputs:t,backend:e}=r,o=t;j(t,"addN");let n=o.map(a=>e.data.get(a.dataId).values),s=ft(o[0].shape,o[0].dtype),i=s.values;for(let a=0;a<o.length;a++){let l=n[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var T1={kernelName:Nl,backendName:"cpu",kernelFunc:nG};function sG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o;j(n,"all");let a=y.parseAxisParam(s,n.shape),l=a,u=S.getAxesPermutation(l,n.shape.length),c=n;u!=null&&(c=fe({inputs:{x:n},backend:e,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,n.shape.length)),S.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,l),f=y.sizeFromShape(m),h=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),d=e.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let b=x*f,C=d[b];for(let w=0;w<f;++w){let I=d[b+w];C=C&&I}h[x]=C}u!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,h);if(i){let x=S.expandShapeToKeepDim(p,a),b=Dt({inputs:{x:g},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(g),b}return g}var v1={kernelName:Tl,backendName:"cpu",kernelFunc:sG};function iG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o;j(n,"any");let a=y.parseAxisParam(s,n.shape),l=a,u=S.getAxesPermutation(l,n.shape.length),c=n;u!=null&&(c=fe({inputs:{x:n},backend:e,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,n.shape.length)),S.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,l),f=y.sizeFromShape(m),h=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),d=e.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let b=x*f,C=d[b];for(let w=0;w<f;++w){let I=d[b+w];C=C||I}h[x]=C}u!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,h);if(i){let x=S.expandShapeToKeepDim(p,a),b=Dt({inputs:{x:g},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(g),b}return g}var k1={kernelName:vl,backendName:"cpu",kernelFunc:iG};function aG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s}=o;j(n,"argMax");let i=y.parseAxisParam(s,n.shape),a=S.getAxesPermutation(i,n.shape.length),l=n,u=[];a!=null&&(l=fe({inputs:{x:n},backend:e,attrs:{perm:a}}),u.push(l),i=S.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,p]=S.computeOutAndReduceShapes(l.shape,i),m=y.sizeFromShape(c),f=y.makeZerosTypedArray(m,"int32"),h=y.sizeFromShape(p),d=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*h,b=d[x],C=0;for(let w=0;w<h;++w){let I=d[x+w];I>b&&(b=I,C=w)}f[g]=C}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var E1={kernelName:Bs,backendName:"cpu",kernelFunc:aG};function lG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s}=o;j(n,"argMin");let i=y.parseAxisParam(s,n.shape),a=S.getAxesPermutation(i,n.shape.length),l=n,u=[];a!=null&&(l=fe({inputs:{x:n},backend:e,attrs:{perm:a}}),u.push(l),i=S.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,p]=S.computeOutAndReduceShapes(l.shape,i),m=y.sizeFromShape(c),f=y.makeZerosTypedArray(m,"int32"),h=y.sizeFromShape(p),d=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*h,b=d[x],C=0;for(let w=0;w<h;++w){let I=d[x+w];I<b&&(b=I,C=w)}f[g]=C}return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var A1={kernelName:Vs,backendName:"cpu",kernelFunc:lG};var uG=bt(bn,r=>Math.asin(r)),$1={kernelName:bn,backendName:"cpu",kernelFunc:uG};var cG=bt(wn,r=>Math.asinh(r)),D1={kernelName:wn,backendName:"cpu",kernelFunc:cG};var pG=bt(Cn,r=>Math.atan(r)),R1={kernelName:Cn,backendName:"cpu",kernelFunc:pG};var mG=Ot((r,t)=>Math.atan2(r,t)),fG=Mt(Sn,mG),F1={kernelName:Sn,backendName:"cpu",kernelFunc:fG};var hG=bt(In,r=>Math.atanh(r)),_1={kernelName:In,backendName:"cpu",kernelFunc:hG};function xc(r,t,e,o,n,s){let i=n.strideHeight,a=n.strideWidth,l=n.dilationHeight,u=n.dilationWidth,c=n.effectiveFilterHeight,p=n.effectiveFilterWidth,m=n.padInfo.top,f=n.padInfo.left,h=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,d=ft(n.outShape,e),g=d.values,x=n.outShape[1]*n.outShape[2]*n.outShape[3],b=n.outShape[2]*n.outShape[3],C=n.outShape[3];for(let w=0;w<n.batchSize;++w){let I=w*x,E=w*o[0];for(let A=0;A<n.inChannels;++A)for(let $=0;$<n.outHeight;++$){let _=$*i-m,L=Math.max(0,_),B=Math.min(n.inHeight,c+_),V=I+$*b;for(let G=0;G<n.outWidth;++G){let U=G*a-f,W=Math.max(0,U),q=Math.min(n.inWidth,p+U),Z=h,K=0,J=0;for(let et=L;et<B;et+=l){let nt=E+et*o[1];for(let rt=W;rt<q;rt+=u){let lt=nt+rt*o[2],st=r[lt+A];s==="max"&&st>Z?Z=st:s==="avg"&&(K+=st,J++)}if(isNaN(Z))break}let tt=V+G*C+A;g[tt]=s==="avg"?K/J:Z}}}return d}function rg(r,t,e,o,n=!1,s=!1){let i=ft(o.outShape,"int32"),a=o.strideHeight,l=o.strideWidth,u=o.dilationHeight,c=o.dilationWidth,p=o.effectiveFilterHeight,m=o.effectiveFilterWidth,f=o.padInfo.top,h=o.padInfo.left,d=ft(t,e,r);for(let g=0;g<o.batchSize;++g)for(let x=0;x<o.inChannels;++x)for(let b=0;b<o.outHeight;++b){let C=b*a-f,w=C;for(;w<0;)w+=u;let I=Math.min(o.inHeight,p+C);for(let E=0;E<o.outWidth;++E){let A=E*l-h,$=A;for(;$<0;)$+=c;let _=Math.min(o.inWidth,m+A),L=Number.NEGATIVE_INFINITY,B=-1;for(let V=w;V<I;V+=u){let G=V-C;for(let U=$;U<_;U+=c){let W=U-A,q=d.get(g,V,U,x);q>L&&(L=q,n?B=s?((g*o.inHeight+V)*o.inWidth+U)*o.inChannels+x:(V*o.inWidth+U)*o.inChannels+x:B=G*m+W)}}i.set(B,g,b,E,x)}}return i}function og(r,t,e,o,n,s){let i=n.strideDepth,a=n.strideHeight,l=n.strideWidth,u=n.dilationDepth,c=n.dilationHeight,p=n.dilationWidth,m=n.effectiveFilterDepth,f=n.effectiveFilterHeight,h=n.effectiveFilterWidth,d=n.padInfo.front,g=n.padInfo.top,x=n.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=ft(n.outShape,e),w=C.values,I=n.outShape[1]*n.outShape[2]*n.outShape[3]*n.outShape[4],E=n.outShape[2]*n.outShape[3]*n.outShape[4],A=n.outShape[3]*n.outShape[4],$=n.outShape[4];for(let _=0;_<n.batchSize;++_){let L=_*I,B=_*o[0];for(let V=0;V<n.inChannels;++V)for(let G=0;G<n.outDepth;++G){let U=G*i-d,W=U;for(;W<0;)W+=u;let q=Math.min(n.inDepth,m+U),Z=L+G*E;for(let K=0;K<n.outHeight;++K){let J=K*a-g,tt=J;for(;tt<0;)tt+=c;let et=Math.min(n.inHeight,f+J),nt=Z+K*A;for(let rt=0;rt<n.outWidth;++rt){let lt=rt*l-x,st=lt;for(;st<0;)st+=p;let pt=Math.min(n.inWidth,h+lt),It=nt+rt*$,Tt=b,St=0,Ft=0;for(let Qt=W;Qt<q;Qt+=u){let le=B+Qt*o[1];for(let Ne=tt;Ne<et;Ne+=c){let ue=le+Ne*o[2];for(let oe=st;oe<pt;oe+=p){let Se=ue+oe*o[3],ye=r[Se+V];if(s==="max"&&ye>Tt?Tt=ye:s==="avg"&&(St+=ye,Ft++),isNaN(Tt))break}if(isNaN(Tt))break}if(isNaN(Tt))break}let Lt=It+V;w[Lt]=s==="avg"?St/Math.max(Ft,1):Tt}}}}return C}function O1(r,t){let e=ft(t.outShape,"int32"),o=t.strideDepth,n=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,f=t.padInfo.top,h=t.padInfo.left;for(let d=0;d<t.batchSize;++d)for(let g=0;g<t.inChannels;++g)for(let x=0;x<t.outDepth;++x){let b=x*o-m,C=b;for(;C<0;)C+=i;let w=Math.min(t.inDepth,u+b);for(let I=0;I<t.outHeight;++I){let E=I*n-f,A=E;for(;A<0;)A+=a;let $=Math.min(t.inHeight,c+E);for(let _=0;_<t.outWidth;++_){let L=_*s-h,B=L;for(;B<0;)B+=l;let V=Math.min(t.inWidth,p+L),G=Number.NEGATIVE_INFINITY,U=-1;for(let W=C;W<w;W+=i){let q=W-b;for(let Z=A;Z<$;Z+=a){let K=Z-E;for(let J=B;J<V;J+=l){let tt=J-L,et=r.get(d,W,Z,J,g);et>=G&&(G=et,U=q*c*p+K*c+tt)}}}e.set(U,d,x,I,_,g)}}}return e}function dG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t;j(n,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=o,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=S.computePool2DInfo(n.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))p=rr({inputs:{x:n},backend:e});else{let m=e.data.get(n.dataId).values,f=y.computeStrides(n.shape),h=xc(m,n.shape,n.dtype,f,c,"avg");p=e.makeTensorInfo(c.outShape,n.dtype,h.values)}return p}var L1={kernelName:Gs,backendName:"cpu",kernelFunc:dG};function gG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=o;j(n,"avgPool3d");let c=S.computePool3DInfo(n.shape,s,i,1,a,l,u),p=e.data.get(n.dataId).values,m=og(p,n.shape,n.dtype,y.computeStrides(n.shape),c,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}var P1={kernelName:Ws,backendName:"cpu",kernelFunc:gG};function xG(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=o;j([n,s],"avgPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,l,u),p=c.strideDepth,m=c.strideHeight,f=c.strideWidth,h=c.filterDepth,d=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,b=c.dilationHeight,C=c.dilationWidth,w=c.effectiveFilterDepth,I=c.effectiveFilterHeight,E=c.effectiveFilterWidth,A=w-1-c.padInfo.front,$=E-1-c.padInfo.left,_=I-1-c.padInfo.top,L=ft(s.shape,"float32"),B=1/(h*d*g),V=e.bufferSync(n);for(let G=0;G<c.batchSize;++G)for(let U=0;U<c.inChannels;++U)for(let W=0;W<c.inDepth;++W)for(let q=0;q<c.inHeight;++q)for(let Z=0;Z<c.inWidth;++Z){let K=W-A,J=q-_,tt=Z-$,et=0;for(let nt=0;nt<w;nt+=x){let rt=(K+nt)/p;if(!(rt<0||rt>=c.outDepth||Math.floor(rt)!==rt))for(let lt=0;lt<I;lt+=b){let st=(J+lt)/m;if(!(st<0||st>=c.outHeight||Math.floor(st)!==st))for(let pt=0;pt<E;pt+=C){let It=(tt+pt)/f;if(It<0||It>=c.outWidth||Math.floor(It)!==It)continue;let Tt=V.get(G,rt,st,It,U);et+=Tt}}}L.set(et*B,G,W,q,Z,U)}return e.makeTensorInfo(L.shape,L.dtype,L.values)}var z1={kernelName:El,backendName:"cpu",kernelFunc:xG};function yG(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s}=t,i=s;j([n,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=o,c=S.computePool2DInfo(i.shape,a,l,1,u),p=c.strideHeight,m=c.strideWidth,f=c.filterHeight,h=c.filterWidth,d=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,b=c.effectiveFilterWidth,C=b-1-c.padInfo.left,w=x-1-c.padInfo.top,I=ft(i.shape,"float32"),E=1/(f*h),A=e.data.get(n.dataId).values,$=ft(n.shape,"float32",A);for(let _=0;_<c.batchSize;++_)for(let L=0;L<c.inChannels;++L)for(let B=0;B<c.inHeight;++B)for(let V=0;V<c.inWidth;++V){let G=B-w,U=V-C,W=0;for(let q=0;q<x;q+=d){let Z=(G+q)/p;if(!(Z<0||Z>=c.outHeight||Math.floor(Z)!==Z))for(let K=0;K<b;K+=g){let J=(U+K)/m;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;let tt=$.get(_,Z,J,L);W+=tt}}I.set(W*E,_,B,V,L)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}var M1={kernelName:kl,backendName:"cpu",kernelFunc:yG};function bG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,scale:s,offset:i,mean:a,variance:l}=t;y.assert(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),j([n,a,l,s,i],"batchNorm");let{varianceEpsilon:u}=o;u==null&&(u=.001);let c=e.data.get(n.dataId).values,p=e.data.get(a.dataId).values,m=e.data.get(l.dataId).values,f=s?e.data.get(s.dataId).values:new Float32Array([1]),h=i?e.data.get(i.dataId).values:new Float32Array([0]),d=new Float32Array(c.length),g=h.length,x=f.length,b=m.length,C=p.length,w=0,I=0,E=0,A=0;for(let $=0;$<c.length;++$)d[$]=h[w++]+(c[$]-p[I++])*f[E++]/Math.sqrt(m[A++]+u),w>=g&&(w=0),I>=C&&(I=0),E>=x&&(E=0),A>=b&&(A=0);return e.makeTensorInfo(n.shape,n.dtype,d)}var B1={kernelName:ei,backendName:"cpu",kernelFunc:bG};function wG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{blockShape:s,crops:i}=o;j([n],"batchToSpaceND");let a=s.reduce((x,b)=>x*b),l=S.getReshaped(n.shape,s,a),u=S.getPermuted(l.length,s.length),c=S.getReshapedPermuted(n.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=Dt({inputs:{x:n},backend:e,attrs:{shape:l}}),h=fe({inputs:{x:f},backend:e,attrs:{perm:u}}),d=Dt({inputs:{x:h},backend:e,attrs:{shape:c}}),g=Io({inputs:{x:d},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),g}var V1={kernelName:Hs,backendName:"cpu",kernelFunc:wG};function CG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,weights:s}=t,{size:i}=o,a=e.data.get(n.dataId).values,l=e.data.get(s.dataId).values,u=fc(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}var G1={kernelName:Al,backendName:"cpu",kernelFunc:CG};function IG(r){let{inputs:t,backend:e}=r,{s0:o,s1:n}=t,s=e.data.get(o.dataId).values,i=e.data.get(n.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var W1={kernelName:Sf,backendName:"cpu",kernelFunc:IG};var SG=bt(Tn,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),U1={kernelName:Tn,backendName:"cpu",kernelFunc:SG};var NG=r=>{let{x:t}=r.inputs,e=r.backend,o=new Float32Array(y.sizeFromShape(t.shape)),n=e.data.get(t.dataId),s=n.complexTensorInfos.real,i=n.complexTensorInfos.imag,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++){let c=a[u],p=l[u];o[u]=Math.hypot(c,p)}return e.makeOutput(o,t.shape,"float32")},H1={kernelName:Ks,backendName:"cpu",kernelFunc:NG};function ln(r){let{inputs:t,backend:e}=r,{input:o}=t,n=e.data.get(o.dataId).complexTensorInfos.imag,s=e.data.get(n.dataId).values;return e.makeTensorInfo(n.shape,n.dtype,s)}var K1={kernelName:Hl,backendName:"cpu",kernelFunc:ln};function Zi(r){let{inputs:t,backend:e,attrs:o}=r,{axis:n}=o,s=y.parseAxisParam(n,t[0].shape)[0],i=t.map(d=>d.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(t.map(d=>d.shape),s);if(y.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(d=>y.sizeFromShape(d.shape)>0);if(l.length===1)return rr({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){let d=l.map(w=>yo({inputs:{input:w},backend:e})),g=l.map(w=>ln({inputs:{input:w},backend:e})),x=Zi({inputs:d,backend:e,attrs:{axis:s}}),b=Zi({inputs:g,backend:e,attrs:{axis:s}}),C=_e({inputs:{real:x,imag:b},backend:e});return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),g.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),C}let u=l.map(d=>{let x=[-1,y.sizeFromShape(d.shape.slice(s))];return Dt({inputs:{x:d},backend:e,attrs:{shape:x}})}),c=u.map(d=>({vals:e.data.get(d.dataId).values,shape:d.shape}));a=S.computeOutShape(u.map(d=>d.shape),1);let p=u[0].shape[0]===1,m=zd(c,a,t[0].dtype,p),f=S.computeOutShape(l.map(d=>d.shape),s),h=e.makeTensorInfo(f,t[0].dtype,m);return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}var q1={kernelName:qs,backendName:"cpu",kernelFunc:Zi};function r0(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=o;j([n,s],"conv2d");let p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(n.shape,s.shape,i,u,a,c,!1,p),f=m.filterHeight,h=m.filterWidth,d=m.dilationHeight,g=m.dilationWidth,x=m.padInfo.left,b=m.padInfo.top,C=m.dataFormat==="channelsLast",w=new Ut(m.outShape,n.dtype),I=y.computeStrides(n.shape),E=y.computeStrides(s.shape),A=I[0],$=C?I[1]:I[2],_=C?I[2]:1,L=C?1:I[1],B=w.strides[0],V=C?w.strides[1]:w.strides[2],G=C?w.strides[2]:1,U=C?1:w.strides[1],W=e.data.get(n.dataId).values,q=e.data.get(s.dataId).values,Z=w.values;for(let K=0;K<m.batchSize;++K){let J=K*A,tt=K*B;for(let et=0;et<m.outHeight;++et){let nt=tt+et*V,rt=et*m.strideHeight-b;for(let lt=0;lt<f;++lt){let st=rt+lt*d;if(st<0||st>=m.inHeight)continue;let pt=lt*E[0],It=J+st*$;for(let Tt=0;Tt<m.outWidth;++Tt){let St=nt+Tt*G,Ft=Tt*m.strideWidth-x;for(let Lt=0;Lt<h;++Lt){let Qt=Ft+Lt*g;if(Qt<0||Qt>=m.inWidth)continue;let le=pt+Lt*E[1],Ne=It+Qt*_,ue=le;for(let oe=0;oe<m.inChannels;++oe){let Se=W[Ne+oe*L];for(let ye=0;ye<m.outChannels;++ye)Z[St+ye*U]+=Se*q[ue+ye];ue+=m.outChannels}}}}}}return e.makeTensorInfo(w.shape,w.dtype,Z)}var j1={kernelName:js,backendName:"cpu",kernelFunc:r0};function TG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,dy:s}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=o;j([n,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(n.shape,c,i,1,a,u,!1,p),{strideHeight:f,strideWidth:h,filterHeight:d,filterWidth:g}=m,x=m.dataFormat==="channelsLast",b=new Ut(m.filterShape,"float32"),C=m.padInfo.left,w=m.padInfo.top,I=e.data.get(n.dataId).values,E=e.data.get(s.dataId).values,A=new Ut(n.shape,n.dtype,I),$=new Ut(s.shape,s.dtype,E);for(let _=0;_<d;++_){let L=Math.max(0,Math.ceil((w-_)/f)),B=Math.min(m.outHeight,(m.inHeight+w-_)/f);for(let V=0;V<g;++V){let G=Math.max(0,Math.ceil((C-V)/h)),U=Math.min(m.outWidth,(m.inWidth+C-V)/h);for(let W=0;W<m.inChannels;++W)for(let q=0;q<m.outChannels;++q){let Z=0;for(let K=0;K<m.batchSize;++K)for(let J=L;J<B;++J){let tt=_+J*f-w;for(let et=G;et<U;++et){let nt=V+et*h-C;x?Z+=A.get(K,tt,nt,W)*$.get(K,J,et,q):Z+=A.get(K,W,tt,nt)*$.get(K,q,J,et)}}b.set(Z,_,V,W,q)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var X1={kernelName:Dl,backendName:"cpu",kernelFunc:TG};function vG(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,filter:s}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=o;j([n,s],"conv2dBackpropInput");let p=y.computeStrides(s.shape),m=y.computeStrides(n.shape),f=S.convertConv2DDataFormat(u),h=S.computeConv2DInfo(i,s.shape,a,1,l,c,!1,f),d=new Ut(h.inShape,"float32"),g=d.values,x=e.data.get(n.dataId).values,b=e.data.get(s.dataId).values,[C,w,I]=p,{batchSize:E,filterHeight:A,filterWidth:$,inChannels:_,inHeight:L,inWidth:B,outChannels:V,outHeight:G,outWidth:U,strideHeight:W,strideWidth:q}=h;f=h.dataFormat;let Z=A-1-h.padInfo.top,K=$-1-h.padInfo.left,J=f==="channelsLast",tt=d.strides[0],et=J?d.strides[1]:d.strides[2],nt=J?d.strides[2]:1,rt=J?1:d.strides[1],lt=m[0],st=J?m[1]:m[2],pt=J?m[2]:1,It=J?1:m[1];for(let Tt=0;Tt<E;++Tt)for(let St=0;St<_;++St)for(let Ft=0;Ft<L;++Ft){let Lt=Ft-Z,Qt=Math.max(0,Math.ceil(Lt/W)),le=Math.min(G,(A+Lt)/W);for(let Ne=0;Ne<B;++Ne){let ue=Ne-K,oe=Math.max(0,Math.ceil(ue/q)),Se=Math.min(U,($+ue)/q),ye=0;for(let Ye=Qt;Ye<le;++Ye){let _s=Ye*W-Lt;for(let Br=oe;Br<Se;++Br){let oa=Br*q-ue,To=lt*Tt+st*Ye+pt*Br,hn=C*(A-1-_s)+w*($-1-oa)+I*St;for(let Os=0;Os<V;++Os){let Ls=x[To+It*Os],Ps=b[hn+Os];ye+=Ls*Ps}}}let fn=tt*Tt+et*Ft+nt*Ne+rt*St;g[fn]=ye}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}var Y1={kernelName:Xs,backendName:"cpu",kernelFunc:vG};function kG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s}=t,{strides:i,pad:a,dilations:l}=o;j([n,s],"conv3d");let u=S.computeConv3DInfo(n.shape,s.shape,i,l,a),{filterDepth:c,filterHeight:p,filterWidth:m,dilationDepth:f,dilationHeight:h,dilationWidth:d,padInfo:g}=u,x=g.front,b=g.left,C=g.top,w=new Ut(u.outShape,n.dtype),I=e.data.get(n.dataId).values,E=e.data.get(s.dataId).values,A=w.values,$=y.computeStrides(n.shape),_=y.computeStrides(s.shape);for(let L=0;L<u.batchSize;++L){let B=L*$[0],V=L*w.strides[0];for(let G=0;G<u.outDepth;++G){let U=V+G*w.strides[1],W=G*u.strideDepth-x;for(let q=0;q<c;++q){let Z=W+q*f;if(Z<0||Z>=u.inDepth)continue;let K=q*_[0],J=B+Z*$[1];for(let tt=0;tt<u.outHeight;++tt){let et=U+tt*w.strides[2],nt=tt*u.strideHeight-C;for(let rt=0;rt<p;++rt){let lt=nt+rt*h;if(lt<0||lt>=u.inHeight)continue;let st=K+rt*_[1],pt=J+lt*$[2];for(let It=0;It<u.outWidth;++It){let Tt=et+It*u.outChannels,St=It*u.strideWidth-b;for(let Ft=0;Ft<m;++Ft){let Lt=St+Ft*d;if(Lt<0||Lt>=u.inWidth)continue;let Qt=st+Ft*_[2],le=pt+Lt*u.inChannels,Ne=Qt;for(let ue=0;ue<u.inChannels;++ue){let oe=I[le+ue];for(let Se=0;Se<u.outChannels;++Se)A[Tt+Se]+=oe*E[Ne+Se];Ne+=u.outChannels}}}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}var Z1={kernelName:Ys,backendName:"cpu",kernelFunc:kG};function EG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,dy:s}=t,{strides:i,pad:a,filterShape:l}=o;j([n,s],"conv3dBackpropFilterV2");let u=y.computeStrides(n.shape),c=y.computeStrides(s.shape),p=S.computeConv3DInfo(n.shape,l,i,1,a),m=p.strideDepth,f=p.strideHeight,h=p.strideWidth,d=p.filterDepth,g=p.filterHeight,x=p.filterWidth,b=new Ut(p.filterShape,"float32"),C=b.values,[w,I,E,A]=b.strides,$=e.data.get(s.dataId).values,[_,L,B,V]=c,G=e.data.get(n.dataId).values,[U,W,q,Z]=u,K=p.padInfo.front,J=p.padInfo.left,tt=p.padInfo.top;for(let et=0;et<d;++et){let nt=Math.max(0,Math.ceil((K-et)/m)),rt=Math.min(p.outDepth,(p.inDepth+K-et)/m),lt=et*w;for(let st=0;st<g;++st){let pt=Math.max(0,Math.ceil((tt-st)/f)),It=Math.min(p.outHeight,(p.inHeight+tt-st)/f),Tt=st*I+lt;for(let St=0;St<x;++St){let Ft=Math.max(0,Math.ceil((J-St)/h)),Lt=Math.min(p.outWidth,(p.inWidth+J-St)/h),Qt=St*E+Tt;for(let le=0;le<p.inChannels;++le){let Ne=le*A+Qt;for(let ue=0;ue<p.outChannels;++ue){let oe=0;for(let Se=0;Se<p.batchSize;++Se){let ye=Se*U,fn=Se*_;for(let Ye=nt;Ye<rt;++Ye){let Br=(et+Ye*m-K)*W+ye,oa=Ye*L+fn;for(let To=pt;To<It;++To){let Os=(st+To*f-tt)*q+Br,Ls=To*B+oa;for(let Ps=Ft;Ps<Lt;++Ps){let Ux=(St+Ps*h-J)*Z+Os,Hx=Ps*V+Ls;oe+=G[Ux+le]*$[Hx+ue]}}}}C[Ne+ue]=oe}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var J1={kernelName:Rl,backendName:"cpu",kernelFunc:EG};function AG(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,filter:s}=t,{pad:i,strides:a,inputShape:l}=o;j([n],"conv3dBackpropInputV2");let u=y.computeStrides(n.shape),c=y.computeStrides(s.shape),p=S.computeConv3DInfo(l,s.shape,a,1,i),m=new Ut(p.inShape,"float32"),f=m.values,[h,d,g,x]=m.strides,b=e.data.get(n.dataId).values,[C,w,I,E]=u,A=e.data.get(s.dataId).values,[$,_,L,B]=c,{batchSize:V,filterDepth:G,filterHeight:U,filterWidth:W,inChannels:q,inDepth:Z,inHeight:K,inWidth:J,outChannels:tt,outDepth:et,outHeight:nt,outWidth:rt,strideDepth:lt,strideHeight:st,strideWidth:pt}=p,It=G-1-p.padInfo.front,Tt=U-1-p.padInfo.top,St=W-1-p.padInfo.left;for(let Ft=0;Ft<V;++Ft)for(let Lt=0;Lt<q;++Lt)for(let Qt=0;Qt<Z;++Qt){let le=Qt-It,Ne=Math.max(0,Math.ceil(le/lt)),ue=Math.min(et,(G+le)/lt);for(let oe=0;oe<K;++oe){let Se=oe-Tt,ye=Math.max(0,Math.ceil(Se/st)),fn=Math.min(nt,(U+Se)/st);for(let Ye=0;Ye<J;++Ye){let _s=Ye-St,Br=Math.max(0,Math.ceil(_s/pt)),oa=Math.min(rt,(W+_s)/pt),To=0;for(let hn=Ne;hn<ue;++hn){let Os=hn*lt-le;for(let Ls=ye;Ls<fn;++Ls){let Ps=Ls*st-Se;for(let Pc=Br;Pc<oa;++Pc){let Ux=Pc*pt-_s,Hx=C*Ft+w*hn+I*Ls+E*Pc,SF=$*(G-1-Os)+_*(U-1-Ps)+L*(W-1-Ux)+B*Lt;for(let wf=0;wf<tt;++wf){let NF=b[Hx+wf],TF=A[SF+wf];To+=NF*TF}}}}f[h*Ft+d*Qt+g*oe+x*Ye+Lt]=To}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var Q1={kernelName:Fl,backendName:"cpu",kernelFunc:AG};var $G=bt(vn,r=>Math.cos(r)),tk={kernelName:vn,backendName:"cpu",kernelFunc:$G};var DG=bt(kn,r=>Math.cosh(r)),ek={kernelName:kn,backendName:"cpu",kernelFunc:DG};function RG(r){let{inputs:t,backend:e,attrs:o}=r,{image:n,boxes:s,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=o,[c,p,m,f]=n.shape,h=s.shape[0],[d,g]=a,x=ft([h,d,g,f],"float32"),b=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,w=e.data.get(n.dataId).values,I=y.computeStrides(n.shape),E=y.computeStrides(x.shape);for(let A=0;A<h;A++){let $=A*4,_=b[$],L=b[$+1],B=b[$+2],V=b[$+3],G=C[A];if(G>=c)continue;let U=d>1?(B-_)*(p-1)/(d-1):0,W=g>1?(V-L)*(m-1)/(g-1):0;for(let q=0;q<d;q++){let Z=d>1?_*(p-1)+q*U:.5*(_+B)*(p-1);if(Z<0||Z>p-1){for(let K=0;K<g;K++)for(let J=0;J<f;J++){let tt=J+K*E[2]+q*E[1]+A*E[0];x.values[tt]=u}continue}if(l==="bilinear"){let K=Math.floor(Z),J=Math.ceil(Z),tt=Z-K;for(let et=0;et<g;et++){let nt=g>1?L*(m-1)+et*W:.5*(L+V)*(m-1);if(nt<0||nt>m-1){for(let pt=0;pt<f;pt++){let It=pt+et*E[2]+q*E[1]+A*E[0];x.values[It]=u}continue}let rt=Math.floor(nt),lt=Math.ceil(nt),st=nt-rt;for(let pt=0;pt<f;pt++){let It=pt+rt*I[2]+K*I[1]+G*I[0],Tt=w[It];It=pt+lt*I[2]+K*I[1]+G*I[0];let St=w[It];It=pt+rt*I[2]+J*I[1]+G*I[0];let Ft=w[It];It=pt+lt*I[2]+J*I[1]+G*I[0];let Lt=w[It],Qt=Tt+(St-Tt)*st,le=Ft+(Lt-Ft)*st;It=pt+et*E[2]+q*E[1]+A*E[0],x.values[It]=Qt+(le-Qt)*tt}}}else for(let K=0;K<g;++K){let J=g>1?L*(m-1)+K*W:.5*(L+V)*(m-1);if(J<0||J>m-1){for(let nt=0;nt<f;nt++){let rt=nt+K*E[2]+q*E[1]+A*E[0];x.values[rt]=u}continue}let tt=Math.round(J),et=Math.round(Z);for(let nt=0;nt<f;nt++){let rt=nt+tt*I[2]+et*I[1]+G*I[0],lt=nt+K*E[2]+q*E[1]+A*E[0];x.values[lt]=w[rt]}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var rk={kernelName:Ol,backendName:"cpu",kernelFunc:RG};function FG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,exclusive:i,reverse:a}=o;j(n,"cumprod");let l=S.getAxesPermutation([s],n.shape.length),u=n;l!=null&&(u=fe({inputs:{x:n},backend:e,attrs:{perm:l}}));let c=S.getInnerMostAxes(1,n.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=Te(u.dtype,"int32"),m=y.makeOnesTypedArray(y.sizeFromShape(u.shape),p),f=e.data.get(u.dataId).values,h=u.shape[u.shape.length-1],d=a?(x,b)=>x+h-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=h)for(let b=0;b<h;b++){let C=d(x,b);if(b===0)m[C]=i?1:f[C];else{let w=d(x,b-1);m[C]=i?f[w]*m[w]:f[C]*m[w]}}let g=e.makeTensorInfo(u.shape,p,m);if(l!=null){let x=S.getUndoAxesPermutation(l),b=fe({inputs:{x:g},backend:e,attrs:{perm:x}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(u),b}return g}var ok={kernelName:_l,backendName:"cpu",kernelFunc:FG};function _G(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,exclusive:i,reverse:a}=o;j(n,"cumsum");let l=S.getAxesPermutation([s],n.shape.length),u=n;l!=null&&(u=fe({inputs:{x:n},backend:e,attrs:{perm:l}}));let c=S.getInnerMostAxes(1,n.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=Te(u.dtype,"int32"),m=y.makeZerosTypedArray(y.sizeFromShape(u.shape),p),f=e.data.get(u.dataId).values,h=u.shape[u.shape.length-1],d=a?(x,b)=>x+h-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=h)for(let b=0;b<h;b++){let C=d(x,b);if(b===0)m[C]=i?0:f[C];else{let w=d(x,b-1);m[C]=i?f[w]+m[w]:f[C]+m[w]}}let g=e.makeTensorInfo(u.shape,p,m);if(l!=null){let x=S.getUndoAxesPermutation(l),b=fe({inputs:{x:g},backend:e,attrs:{perm:x}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(u),b}return g}var nk={kernelName:Zs,backendName:"cpu",kernelFunc:_G};function OG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,weights:s}=t,{size:i,binaryOutput:a}=o;if(n.shape.length===1){let l=e.data.get(n.dataId).values,u=e.data.get(s.dataId).values,c=fc(l,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(n.shape.length===2){let l=e.bufferSync(n),u=e.bufferSync(s),c=Pd(l,u,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n.shape.length}.`)}var sk={kernelName:Ll,backendName:"cpu",kernelFunc:OG};function LG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{blockSize:s,dataFormat:i}=o;y.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=n.shape[0],l=n.shape[1],u=n.shape[2],c=n.shape[3],p=l*s,m=u*s,f=c/(s*s),h=e.data.get(n.dataId).values,d=new Float32Array(a*p*m*f),g=0;for(let x=0;x<a;++x)for(let b=0;b<p;++b){let C=Math.floor(b/s),w=b%s;for(let I=0;I<m;++I){let E=Math.floor(I/s),A=I%s,$=(w*s+A)*f;for(let _=0;_<f;++_){let B=_+$+c*(E+u*(C+l*x));d[g++]=h[B]}}}return e.makeTensorInfo([a,p,m,f],n.dtype,d)}var ik={kernelName:Pl,backendName:"cpu",kernelFunc:LG};function o0(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=o;j([n,s],"depthwiseConv2DNative");let c=y.computeStrides(n.shape),p=y.computeStrides(s.shape),m=l;m==null&&(m=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let f=S.computeConv2DInfo(n.shape,s.shape,i,m,a,u,!0),{filterHeight:h,filterWidth:d,dilationHeight:g,dilationWidth:x,padInfo:b}=f,C=b.left,w=b.top,I=f.outChannels/f.inChannels,E=new Ut(f.outShape,n.dtype),A=e.data.get(n.dataId).values,$=e.data.get(s.dataId).values,_=E.values;for(let L=0;L<f.batchSize;++L){let B=L*c[0],V=L*E.strides[0];for(let G=0;G<f.outHeight;++G){let U=V+G*E.strides[1],W=G*f.strideHeight-w;for(let q=0;q<h;++q){let Z=W+q*g;if(Z<0||Z>=f.inHeight)continue;let K=q*p[0],J=B+Z*c[1];for(let tt=0;tt<f.outWidth;++tt){let et=U+tt*E.strides[2],nt=tt*f.strideWidth-C;for(let rt=0;rt<d;++rt){let lt=nt+rt*x;if(lt<0||lt>=f.inWidth)continue;let st=K+rt*p[1],pt=J+lt*f.inChannels,It=et,Tt=st;for(let St=0;St<f.inChannels;++St){let Ft=A[pt+St];for(let Lt=0;Lt<I;++Lt)_[It+Lt]+=Ft*$[Tt+Lt];It+=I,Tt+=I}}}}}}return e.makeTensorInfo(E.shape,E.dtype,E.values)}var ak={kernelName:Js,backendName:"cpu",kernelFunc:o0};function PG(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,dy:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=o;j([n,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(n.shape,c,i,a,l,u,!0),{strideHeight:m,strideWidth:f,filterHeight:h,filterWidth:d}=p,g=new Ut(p.filterShape,"float32"),x=p.padInfo.left,b=p.padInfo.top,C=p.outChannels/p.inChannels,w=e.data.get(n.dataId).values,I=new Ut(n.shape,n.dtype,w),E=e.data.get(s.dataId).values,A=new Ut(s.shape,s.dtype,E);for(let $=0;$<h;++$){let _=Math.max(0,Math.ceil((b-$)/m)),L=Math.min(p.outHeight,(p.inHeight+b-$)/m);for(let B=0;B<d;++B){let V=Math.max(0,Math.ceil((x-B)/f)),G=Math.min(p.outWidth,(p.inWidth+x-B)/f);for(let U=0;U<p.outChannels;++U){let W=Math.trunc(U/C),q=U%C,Z=0;for(let K=0;K<p.batchSize;++K)for(let J=_;J<L;++J){let tt=$+J*m-b;for(let et=V;et<G;++et){let nt=B+et*f-x;Z+=I.get(K,tt,nt,W)*A.get(K,J,et,U)}}g.set(Z,$,B,W,q)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var lk={kernelName:zl,backendName:"cpu",kernelFunc:PG};function zG(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,filter:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=o;j([n,s],"depthwiseConv2DNativeBackpropInput");let p=y.computeStrides(n.shape),m=y.computeStrides(s.shape),f=S.computeConv2DInfo(c,s.shape,i,a,l,u,!0),h=new Ut(f.inShape,"float32"),d=h.values,[g,x,b]=h.strides,C=e.data.get(n.dataId).values,[w,I,E]=p,A=e.data.get(s.dataId).values,[$,_,L]=m,{batchSize:B,filterHeight:V,filterWidth:G,inChannels:U,inHeight:W,inWidth:q,outChannels:Z,outHeight:K,outWidth:J,strideHeight:tt,strideWidth:et}=f,nt=V-1-f.padInfo.top,rt=G-1-f.padInfo.left,lt=Z/U;for(let st=0;st<B;++st)for(let pt=0;pt<U;++pt)for(let It=0;It<W;++It){let Tt=It-nt,St=Math.max(0,Math.ceil(Tt/tt)),Ft=Math.min(K,(V+Tt)/tt);for(let Lt=0;Lt<q;++Lt){let Qt=Lt-rt,le=Math.max(0,Math.ceil(Qt/et)),Ne=Math.min(J,(G+Qt)/et),ue=0;for(let oe=St;oe<Ft;++oe){let Se=oe*tt-Tt;for(let ye=le;ye<Ne;++ye){let fn=ye*et-Qt,Ye=w*st+I*oe+E*ye,_s=$*(V-1-Se)+_*(G-1-fn)+L*pt;for(let Br=0;Br<lt;++Br){let oa=pt*lt+Br,To=C[Ye+oa],hn=A[_s+Br];ue+=To*hn}}}d[g*st+x*It+b*Lt+pt]=ue}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var uk={kernelName:Ml,backendName:"cpu",kernelFunc:zG};function MG(r){let{inputs:t,backend:e}=r,{x:o}=t,n=y.sizeFromShape(o.shape),s=e.data.get(o.dataId).values,i=ft([n,n],o.dtype),a=i.values;for(let u=0;u<s.length;u++)a[u*n+u]=s[u];let l=[...o.shape,...o.shape];return e.makeTensorInfo(l,i.dtype,i.values)}var ck={kernelName:Nf,backendName:"cpu",kernelFunc:MG};var pk={kernelName:Qs,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:o,filter:n}=r,{strides:s,pad:i,dilations:a}=e,l=t,u=l.data.get(o.dataId).values,c=o.shape.length,p=l.data.get(n.dataId).values,m=n.shape.length,{batchSize:f,inHeight:h,inWidth:d,inChannels:g,outHeight:x,outWidth:b,padInfo:C,strideHeight:w,strideWidth:I,filterHeight:E,filterWidth:A,dilationHeight:$,dilationWidth:_,outShape:L}=S.computeDilation2DInfo(o.shape,n.shape,s,i,"NHWC",a),B=y.sizeFromShape(L),V=L.length,G=y.getArrayFromDType(o.dtype,B);for(let W=0;W<f;++W)for(let q=0;q<x;++q){let Z=q*w-C.top;for(let K=0;K<b;++K){let J=K*I-C.left;for(let tt=0;tt<g;++tt){let et=Number.MIN_SAFE_INTEGER;for(let rt=0;rt<E;++rt){let lt=Z+rt*$;if(lt>=0&&lt<h)for(let st=0;st<A;++st){let pt=J+st*_;if(pt>=0&&pt<d){let It=y.locToIndex([W,lt,pt,tt],c,y.computeStrides(o.shape)),Tt=y.locToIndex([rt,st,tt],m,y.computeStrides(n.shape)),St=u[It]+p[Tt];St>et&&(et=St)}}}let nt=y.locToIndex([W,q,K,tt],V,y.computeStrides(L));G[nt]=et}}}return{dataId:l.write(y.toTypedArray(G,o.dtype),L,o.dtype),shape:L,dtype:o.dtype}}};var mk={kernelName:Uc,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:o,filter:n,dy:s}=r,{strides:i,pad:a,dilations:l}=e,u=t,c=y.toNestedArray(o.shape,u.data.get(o.dataId).values),p=y.toNestedArray(n.shape,u.data.get(n.dataId).values),{batchSize:m,inHeight:f,inWidth:h,inChannels:d,outHeight:g,outWidth:x,padInfo:b,strideHeight:C,strideWidth:w,filterHeight:I,filterWidth:E,dilationHeight:A,dilationWidth:$,outShape:_}=S.computeDilation2DInfo(o.shape,n.shape,i,a,"NHWC",l);y.assert(s.rank===_.length,()=>`Error in ${Uc}, dy must have the same rank as output ${_.length}, but got ${s.rank}`);let L=y.toNestedArray(_,u.data.get(s.dataId).values),B=y.makeZerosNestedTypedArray(n.shape,n.dtype);for(let G=0;G<m;++G)for(let U=0;U<g;++U){let W=U*C-b.top;for(let q=0;q<x;++q){let Z=q*w-b.left;for(let K=0;K<d;++K){let J=Number.MIN_SAFE_INTEGER,tt=0,et=0;for(let nt=0;nt<I;++nt){let rt=W+nt*A;if(rt>=0&&rt<f)for(let lt=0;lt<E;++lt){let st=Z+lt*$;if(st>=0&&st<h){let pt=c[G][rt][st][K]+p[nt][lt][K];pt>J&&(J=pt,tt=nt,et=lt)}}}B[tt][et][K]+=L[G][U][q][K]}}}return{dataId:u.write(y.toTypedArray(B,o.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var fk={kernelName:Wc,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:o,filter:n,dy:s}=r,{strides:i,pad:a,dilations:l}=e,u=t,c=y.toNestedArray(o.shape,u.data.get(o.dataId).values),p=y.toNestedArray(n.shape,u.data.get(n.dataId).values),{batchSize:m,inHeight:f,inWidth:h,inChannels:d,outHeight:g,outWidth:x,padInfo:b,strideHeight:C,strideWidth:w,filterHeight:I,filterWidth:E,dilationHeight:A,dilationWidth:$,outShape:_}=S.computeDilation2DInfo(o.shape,n.shape,i,a,"NHWC",l);y.assert(s.rank===_.length,()=>`Error in ${Wc}, dy must have the same rank as output ${_.length}, but got ${s.rank}`);let L=y.toNestedArray(_,u.data.get(s.dataId).values),B=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let G=0;G<m;++G)for(let U=0;U<g;++U){let W=U*C-b.top;for(let q=0;q<x;++q){let Z=q*w-b.left;for(let K=0;K<d;++K){let J=Number.MIN_SAFE_INTEGER,tt=W<0?0:W,et=Z<0?0:Z;for(let nt=0;nt<I;++nt){let rt=W+nt*A;if(rt>=0&&rt<f)for(let lt=0;lt<E;++lt){let st=Z+lt*$;if(st>=0&&st<h){let pt=c[G][rt][st][K]+p[nt][lt][K];pt>J&&(J=pt,tt=rt,et=st)}}}B[G][tt][et][K]+=L[G][U][q][K]}}}return{dataId:u.write(y.toTypedArray(B,o.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};function As(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o;j(n,"sum");let a;n.dtype==="bool"?a=bo({inputs:{x:n},backend:e,attrs:{dtype:"int32"}}):a=rr({inputs:{x:n},backend:e});let l=a.shape.length,u=y.parseAxisParam(s,a.shape),c=S.getAxesPermutation(u,l),p=u,m=a;c!=null&&(m=fe({inputs:{x:a},backend:e,attrs:{perm:c}}),p=S.getInnerMostAxes(p.length,l)),S.assertAxesAreInnerMostDims("sum",p,m.shape.length);let[f,h]=S.computeOutAndReduceShapes(m.shape,p),d=S.upcastType(m.dtype,"int32"),g=pc(e,f,d),x=y.sizeFromShape(h),b=e.data.get(g.dataId).values,C=e.data.get(m.dataId).values;for(let w=0;w<b.length;++w){let I=w*x,E=0;for(let A=0;A<x;++A)E+=C[I+A];b[w]=E}if(i){let w=S.expandShapeToKeepDim(g.shape,u),I=g;g=Dt({inputs:{x:g},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(I)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(m),g}var hk={kernelName:Ni,backendName:"cpu",kernelFunc:As};function BG(r){let{inputs:t,backend:e,attrs:o}=r,{equation:n}=o,s=t,{allDims:i,summedDims:a,idDims:l}=S.decodeEinsumEquation(n,s.length);S.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=S.getEinsumComputePath(a,l),p=c.length,m=null,f=i.length,h=[];for(let d=0;d<p;++d){for(let g of c[d]){let{permutationIndices:x,expandDims:b}=S.getEinsumPermutation(f,l[g]),C;S.isIdentityPermutation(x)?C=s[g]:(C=fe({inputs:{x:s[g]},backend:e,attrs:{perm:x}}),h.push(C));let w=C.shape.slice();for(let I=0;I<b.length;++I)w.splice(b[I],0,1);y.arraysEqual(C.shape,w)||(C=Dt({inputs:{x:C},backend:e,attrs:{shape:w}}),h.push(C)),m===null?m=C:(m=ol({inputs:{a:C,b:m},backend:e}),h.push(m))}d<p-1&&(u[d]>=0&&(m=As({inputs:{x:m},backend:e,attrs:{axis:u[d]-(i.length-f),keepDims:!1}}),h.push(m)),f--)}for(let d of h)d!==m&&e.disposeIntermediateTensorInfo(d);return m}var dk={kernelName:Tf,backendName:"cpu",kernelFunc:BG};function VG(r){let{inputs:t,backend:e}=r,{dy:o,y:n}=t;j([o,n],"eluGrad");let s=new Float32Array(y.sizeFromShape(n.shape)),i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=1?s[l]=a[l]:s[l]=a[l]*(u+1)}return e.makeTensorInfo(n.shape,"float32",s)}var gk={kernelName:Bl,backendName:"cpu",kernelFunc:VG};var GG=S.ERF_P,WG=S.ERF_A1,UG=S.ERF_A2,HG=S.ERF_A3,KG=S.ERF_A4,qG=S.ERF_A5,jG=bt($n,r=>{let t=Math.sign(r),e=Math.abs(r),o=1/(1+GG*e);return t*(1-((((qG*o+KG)*o+HG)*o+UG)*o+WG)*o*Math.exp(-e*e))}),xk={kernelName:$n,backendName:"cpu",kernelFunc:jG};function yc(r){let{inputs:t,backend:e,attrs:o}=r,{input:n}=t,{dim:s}=o,i=n.shape.length,a=n.shape.slice(),l=s;return s<0&&(y.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Dt({inputs:{x:n},backend:e,attrs:{shape:a}})}var yk={kernelName:ti,backendName:"cpu",kernelFunc:yc};var XG=Ot((r,t)=>r/t),ef=Mt(En,XG),rf={kernelName:En,backendName:"cpu",kernelFunc:ef};function ng(r,t,e){let o=r.shape,n=o[0],s=o[1],i=e.data.get(r.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[n,s],c=y.sizeFromShape(u),p=y.getTypedArrayFromDType("float32",c),m=y.getTypedArrayFromDType("float32",c);for(let g=0;g<n;g++){let x=Io({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,s]}}),b=Io({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,s]}}),C=_e({inputs:{real:x,imag:b},backend:e}),{real:w,imag:I}=YG(C,t,e),E=S.mergeRealAndImagArrays(w,I);for(let A=0;A<s;A++){let $=S.getComplexWithIndex(E,A);p[g*s+A]=$.real,m[g*s+A]=$.imag}e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(C)}let f=e.makeTensorInfo(u,"float32",p),h=e.makeTensorInfo(u,"float32",m),d=_e({inputs:{real:f,imag:h},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),d}function YG(r,t,e){let o=y.sizeFromShape(r.shape),n=e.data.get(r.dataId),s=e.data.get(n.complexTensorInfos.real.dataId).values,i=e.data.get(n.complexTensorInfos.imag.dataId).values;if(ZG(o)){let a=n0(s,i,o,t,e),l=[r.shape[0],r.shape[1]];if(t){let u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),p=e.makeTensorInfo([],"float32",y.createScalarValue(o,"float32")),m=rr({inputs:{x:p},backend:e}),f=rf.kernelFunc({inputs:{a:u,b:p},backend:e}),h=rf.kernelFunc({inputs:{a:c,b:m},backend:e}),d=e.data.get(f.dataId).values,g=e.data.get(h.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),{real:d,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),l=JG(a,o,t);return S.splitRealAndImagArrays(l)}}function ZG(r){return(r&r-1)===0}function n0(r,t,e,o,n){if(e===1)return{real:r,imag:t};let s=S.mergeRealAndImagArrays(r,t),i=e/2,a=S.complexWithEvenIndex(s),l=a.real,u=a.imag,c=[l.length],p=n.makeTensorInfo(c,"float32",l),m=n.makeTensorInfo(c,"float32",u),f=_e({inputs:{real:p,imag:m},backend:n}),h=S.complexWithOddIndex(s),d=h.real,g=h.imag,x=[d.length],b=n.makeTensorInfo(x,"float32",d),C=n.makeTensorInfo(x,"float32",g),w=_e({inputs:{real:b,imag:C},backend:n}),I=n0(l,u,i,o,n),E=I.real,A=I.imag,$=[E.length],_=n.makeTensorInfo($,"float32",E),L=n.makeTensorInfo($,"float32",A),B=_e({inputs:{real:_,imag:L},backend:n}),V=n0(d,g,i,o,n),G=V.real,U=V.imag,W=[G.length],q=n.makeTensorInfo(W,"float32",G),Z=n.makeTensorInfo(W,"float32",U),K=_e({inputs:{real:q,imag:Z},backend:n}),J=S.exponents(e,o),tt=[J.real.length],et=n.makeTensorInfo(tt,"float32",J.real),nt=n.makeTensorInfo(tt,"float32",J.imag),rt=_e({inputs:{real:et,imag:nt},backend:n}),lt=ol({inputs:{a:rt,b:K},backend:n}),st=an({inputs:{a:B,b:lt},backend:n}),pt=Qm({inputs:{a:B,b:lt},backend:n}),It=yo({inputs:{input:st},backend:n}),Tt=yo({inputs:{input:pt},backend:n}),St=ln({inputs:{input:st},backend:n}),Ft=ln({inputs:{input:pt},backend:n}),Lt=Zi({inputs:[It,Tt],backend:n,attrs:{axis:0}}),Qt=Zi({inputs:[St,Ft],backend:n,attrs:{axis:0}}),le=n.data.get(Lt.dataId).values,Ne=n.data.get(Qt.dataId).values;return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(_),n.disposeIntermediateTensorInfo(L),n.disposeIntermediateTensorInfo(B),n.disposeIntermediateTensorInfo(q),n.disposeIntermediateTensorInfo(Z),n.disposeIntermediateTensorInfo(K),n.disposeIntermediateTensorInfo(et),n.disposeIntermediateTensorInfo(nt),n.disposeIntermediateTensorInfo(rt),n.disposeIntermediateTensorInfo(lt),n.disposeIntermediateTensorInfo(st),n.disposeIntermediateTensorInfo(pt),n.disposeIntermediateTensorInfo(It),n.disposeIntermediateTensorInfo(St),n.disposeIntermediateTensorInfo(Tt),n.disposeIntermediateTensorInfo(Ft),n.disposeIntermediateTensorInfo(Lt),n.disposeIntermediateTensorInfo(Qt),{real:le,imag:Ne}}function JG(r,t,e){let o=new Float32Array(t*2);for(let n=0;n<t;n++){let s=0,i=0;for(let a=0;a<t;a++){let l=S.exponent(n*a,t,e),u=S.getComplexWithIndex(r,a);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(s/=t,i/=t),S.assignToTypedArray(o,s,i,n)}return o}function QG(r){let{inputs:t,backend:e}=r,{input:o}=t,n=y.sizeFromShape(o.shape),s=o.shape[o.shape.length-1],i=n/s,a=Dt({inputs:{x:o},backend:e,attrs:{shape:[i,s]}}),l=ng(a,!1,e),u=Dt({inputs:{x:l},backend:e,attrs:{shape:o.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}var bk={kernelName:Vl,backendName:"cpu",kernelFunc:QG};function of(r){let{backend:t,attrs:e}=r,{shape:o,value:n,dtype:s}=e,i=s||y.inferDtype(n),a=y.getArrayFromDType(i,y.sizeFromShape(o));return tW(a,n,i),t.makeTensorInfo(o,i,a)}var wk={kernelName:Gl,backendName:"cpu",kernelFunc:of};function tW(r,t,e){r.fill(t)}var Ck={kernelName:Wl,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:o}=r,n=e,s=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(o.shape)),[i,a,l,u]=o.shape,c=n.data.get(o.dataId).values;for(let m=0;m<i;m++){let f=m*l*a*u;for(let h=0;h<a;h++){let d=h*(l*u);for(let g=0;g<l;g++){let x=g*u;for(let b=0;b<u;b++){let C=Math.round(l-g-1),w=f+d+x+b,I=c[w];if(C>=0&&C<l){let E=C*u,A=f+d+E+b;I=c[A]}s[w]=I}}}}return{dataId:n.write(s,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var eW=Ot((r,t)=>Math.floor(r/t)),rW=Mt(_n,eW,null,"int32"),Ik={kernelName:_n,backendName:"cpu",kernelFunc:rW};function oW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:h}=o,d=r0({inputs:{x:n,filter:s},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=d;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let x=Dt({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});d=an({inputs:{a:d,b:x},backend:e}),e.disposeIntermediateTensorInfo(x)}else d=an({inputs:{a:d,b:i},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){let g=d;if(c==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let x=Dt({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});d=nl(e,d,f,x,h),e.disposeIntermediateTensorInfo(x)}else d=nl(e,d,f,a,h);e.disposeIntermediateTensorInfo(g)}return d}var Sk={kernelName:xa,backendName:"cpu",kernelFunc:oW};function nW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:h}=o,d=o0({inputs:{x:n,filter:s},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=d;d=an({inputs:{a:d,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=d;d=nl(e,d,f,a,h),e.disposeIntermediateTensorInfo(g)}return d}var Nk={kernelName:ya,backendName:"cpu",kernelFunc:nW};function sW(r){let{inputs:t,backend:e}=r,{params:o,indices:n}=t,s=y.sizeFromShape(o.shape),i=n.shape,a=i[i.length-1],[l,u,c,p]=S.prepareAndValidate(o,n);if(u===0)return e.makeTensorInfo(l,o.dtype,[]);let m=e.data.get(n.dataId).values,f=e.bufferSync(o),h=Md(m,f,o.dtype,u,a,c,p,o.shape,s);return e.makeTensorInfo(l,o.dtype,h.values)}var Tk={kernelName:vf,backendName:"cpu",kernelFunc:sW};function iW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,indices:s}=t,{axis:i,batchDims:a}=o;j([n,s],"gatherV2");let l=y.parseAxisParam(i,n.shape)[0],u=e.data.get(s.dataId).values,c=n.shape[l];for(let w=0;w<u.length;++w){let I=u[w];y.assert(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let m=y.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(n,s,l,p),h=Dt({inputs:{x:n},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),d=Dt({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,m/f.batchSize]}}),g=[f.batchSize,f.outerSize,m/f.batchSize,f.sliceSize],x=e.bufferSync(d),b=e.bufferSync(h),C=Bd(b,x,g);return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.makeTensorInfo(f.outputShape,C.dtype,C.values)}var vk={kernelName:ri,backendName:"cpu",kernelFunc:iW};function aW(r){let{inputs:t,backend:e}=r,{input:o}=t,n=y.sizeFromShape(o.shape),s=o.shape[o.shape.length-1],i=n/s,a=Dt({inputs:{x:o},backend:e,attrs:{shape:[i,s]}}),l=ng(a,!0,e),u=Dt({inputs:{x:l},backend:e,attrs:{shape:o.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}var kk={kernelName:Ul,backendName:"cpu",kernelFunc:aW};var lW=bt(Ln,r=>Number.isFinite(r)?1:0,"bool"),Ek={kernelName:Ln,backendName:"cpu",kernelFunc:lW};var uW=bt(Pn,r=>Math.abs(r)===1/0?1:0,"bool"),Ak={kernelName:Pn,backendName:"cpu",kernelFunc:uW};var cW=bt(zn,r=>Number.isNaN(r)?1:0,"bool"),$k={kernelName:zn,backendName:"cpu",kernelFunc:cW};function pW(r){let{backend:t,attrs:e}=r,{start:o,stop:n,num:s}=e,i=Vd(o,n,s);return t.makeTensorInfo([i.length],"float32",i)}var Dk={kernelName:kf,backendName:"cpu",kernelFunc:pW};var mW=bt(Bn,r=>Math.log1p(r)),Rk={kernelName:Bn,backendName:"cpu",kernelFunc:mW};var fW=Ot((r,t)=>r&&t),hW=Mt(ma,fW,null,"bool"),Fk={kernelName:ma,backendName:"cpu",kernelFunc:hW};var dW=bt(fa,r=>r?0:1,"bool"),_k={kernelName:fa,backendName:"cpu",kernelFunc:dW};var gW=Ot((r,t)=>r||t),xW=Mt(ha,gW,null,"bool"),Ok={kernelName:ha,backendName:"cpu",kernelFunc:xW};function yW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{depthRadius:s,bias:i,alpha:a,beta:l}=o;j(n,"LRN");let u=n.shape[3],c=u-1,p=e.data.get(n.dataId).values,m=y.sizeFromShape(n.shape),f=new Float32Array(m);function h(d){let g=d%u,x=d-g+Math.max(0,g-s),b=d-g+Math.min(g+s,c),C=0;for(;x<=b;x++){let w=p[x];C+=w*w}return C}for(let d=0;d<m;d++){let g=h(d),x=p[d]*Math.pow(i+a*g,-l);f[d]=x}return e.makeTensorInfo(n.shape,n.dtype,f)}var Lk={kernelName:ni,backendName:"cpu",kernelFunc:yW};function bW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,y:s,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=o;j(i,"LRNGrad");let p=y.sizeFromShape(i.shape),m=i.shape[3],f=e.data.get(i.dataId).values,h=e.data.get(n.dataId).values,d=e.data.get(s.dataId).values,g=new Float32Array(p),x=p;for(let b=0;b<x;b++){let C=b%m,w=b-C+Math.max(0,C-a),I=b-C+Math.min(m,C+a+1),E=0;for(let A=w;A<I;A++)E+=Math.pow(h[A],2);E=u*E+l;for(let A=w;A<I;A++){let $=-2*u*c*h[A]*d[b]/E;b===A&&($+=Math.pow(E,-c)),$*=f[b],g[A]+=$}}return e.makeTensorInfo(i.shape,n.dtype,g)}var Pk={kernelName:Kl,backendName:"cpu",kernelFunc:bW};function s0(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{reductionIndices:s,keepDims:i}=o,a=e,l=n.shape,u=l.length,c=y.parseAxisParam(s,l),p=c,m=S.getAxesPermutation(p,u),f=a.data.get(n.dataId).values;if(m!=null){let w=new Array(u);for(let I=0;I<w.length;I++)w[I]=l[m[I]];f=hc(f,l,n.dtype,m,w),p=S.getInnerMostAxes(p.length,u),l=w}j(n,"max"),S.assertAxesAreInnerMostDims("max",p,u);let[h,d]=S.computeOutAndReduceShapes(l,p),g=y.sizeFromShape(d),x=Gd(f,g,h,n.dtype),b=a.write(x,h,n.dtype),C=h;return i&&(C=S.expandShapeToKeepDim(h,c)),{dataId:b,shape:C,dtype:n.dtype}}var zk={kernelName:si,backendName:"cpu",kernelFunc:s0};function wW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t;j(n,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=o,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=S.computePool2DInfo(n.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))p=rr({inputs:{x:n},backend:e});else{let m=e.data.get(n.dataId).values,f=y.computeStrides(n.shape),h=xc(m,n.shape,n.dtype,f,c,"max");p=e.makeTensorInfo(c.outShape,n.dtype,h.values)}return p}var Mk={kernelName:ii,backendName:"cpu",kernelFunc:wW};function CW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=o;j(n,"maxPool3d");let c=S.computePool3DInfo(n.shape,s,i,1,a,l,u),p=e.data.get(n.dataId).values,m=og(p,n.shape,n.dtype,y.computeStrides(n.shape),c,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}var Bk={kernelName:ai,backendName:"cpu",kernelFunc:CW};function IW(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=o;j([n,s],"maxPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,l,u),p=e.bufferSync(s),m=O1(p,c),f=c.strideDepth,h=c.strideHeight,d=c.strideWidth,g=c.dilationDepth,x=c.dilationHeight,b=c.dilationWidth,C=c.effectiveFilterDepth,w=c.effectiveFilterHeight,I=c.effectiveFilterWidth,E=C-1-c.padInfo.front,A=I-1-c.padInfo.left,$=w-1-c.padInfo.top,_=ft(s.shape,"float32"),L=e.bufferSync(n);for(let B=0;B<c.batchSize;++B)for(let V=0;V<c.inChannels;++V)for(let G=0;G<c.inDepth;++G)for(let U=0;U<c.inHeight;++U)for(let W=0;W<c.inWidth;++W){let q=G-E,Z=U-$,K=W-A,J=0;for(let tt=0;tt<C;tt+=g){let et=(q+tt)/f;if(!(et<0||et>=c.outDepth||Math.floor(et)!==et))for(let nt=0;nt<w;nt+=x){let rt=(Z+nt)/h;if(!(rt<0||rt>=c.outHeight||Math.floor(rt)!==rt))for(let lt=0;lt<I;lt+=b){let st=(K+lt)/d;if(st<0||st>=c.outWidth||Math.floor(st)!==st)continue;let pt=C*w*I-1-m.get(B,et,rt,st,V),It=tt*w*I+nt*I+lt,Tt=pt===It?1:0;if(Tt===0)continue;let St=L.get(B,et,rt,st,V);J+=St*Tt}}}_.set(J,B,G,U,W,V)}return e.makeTensorInfo(_.shape,_.dtype,_.values)}var Vk={kernelName:jl,backendName:"cpu",kernelFunc:IW};function SW(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s,output:i}=t,a=s;j([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=o,m=S.computePool2DInfo(a.shape,l,u,1,c,p),f=e.data.get(a.dataId).values,h=ft(m.outShape,a.dtype,rg(f,a.shape,a.dtype,m).values),d=m.strideHeight,g=m.strideWidth,x=m.dilationHeight,b=m.dilationWidth,C=m.effectiveFilterHeight,w=m.effectiveFilterWidth,I=w-1-m.padInfo.left,E=C-1-m.padInfo.top,A=ft(a.shape,"float32"),$=e.data.get(n.dataId).values,_=ft(n.shape,"float32",$);for(let L=0;L<m.batchSize;++L)for(let B=0;B<m.inChannels;++B)for(let V=0;V<m.inHeight;++V)for(let G=0;G<m.inWidth;++G){let U=V-E,W=G-I,q=0;for(let Z=0;Z<C;Z+=x){let K=(U+Z)/d;if(!(K<0||K>=m.outHeight||Math.floor(K)!==K))for(let J=0;J<w;J+=b){let tt=(W+J)/g;if(tt<0||tt>=m.outWidth||Math.floor(tt)!==tt)continue;let et=C*w-1-h.get(L,K,tt,B),nt=Z*w+J,rt=et===nt?1:0;if(rt===0)continue;let lt=_.get(L,K,tt,B);q+=lt*rt}}A.set(q,L,V,G,B)}return e.makeTensorInfo(A.shape,A.dtype,A.values)}var Gk={kernelName:ql,backendName:"cpu",kernelFunc:SW};function Wk(r,t,e,o,n){let s=y.computeStrides(t),i=xc(r,t,e,s,n,"max"),a=rg(r,t,e,n,!0,o);return[i.values,a.values]}var Uk={kernelName:Ef,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:o}=r,{filterSize:n,strides:s,pad:i,includeBatchInIndex:a}=t,l=e;j(o,"MaxPoolWithArgmax");let u=l.data.get(o.dataId).values,c=S.computePool2DInfo(o.shape,n,s,[1,1],i),[p,m]=Wk(u,o.shape,o.dtype,a,c),f=l.write(p,c.outShape,o.dtype),h=l.write(m,c.outShape,o.dtype);return[{dataId:f,shape:c.outShape,dtype:o.dtype},{dataId:h,shape:c.outShape,dtype:"int32"}]}};function NW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o,a=y.parseAxisParam(s,n.shape),u=S.computeOutAndReduceShapes(n.shape,a)[1],c=y.sizeFromShape(u),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(m);let f=bo({inputs:{x:n},backend:e,attrs:{dtype:"float32"}});p.push(f);let h=ef({inputs:{a:f,b:m},backend:e});p.push(h);let d=As({inputs:{x:h},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),d}var Hk={kernelName:li,backendName:"cpu",kernelFunc:NW};function TW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o;j(n,"min");let a=y.parseAxisParam(s,n.shape),l=a,u=S.getAxesPermutation(l,n.shape.length),c=n;u!=null&&(c=fe({inputs:{x:n},backend:e,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,n.shape.length)),S.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,l),f=y.sizeFromShape(m),h=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),d=e.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let b=x*f,C=d[b];for(let w=0;w<f;++w){let I=d[b+w];(Number.isNaN(I)||I<C)&&(C=I)}h[x]=C}u!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,h);if(i){let x=S.expandShapeToKeepDim(p,a),b=Dt({inputs:{x:g},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(g),b}return g}var Kk={kernelName:ui,backendName:"cpu",kernelFunc:TW};function vW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{paddings:s,mode:i}=o;j(n,"mirrorPad");let a=s.map((C,w)=>C[0]+n.shape[w]+C[1]),l=s.map(C=>C[0]),u=s.map((C,w)=>C[0]+n.shape[w]),c=i==="reflect"?0:1,p=e.data.get(n.dataId).values,m=n.shape.length,f=y.computeStrides(n.shape),h=y.sizeFromShape(a),d=a.length,g=y.computeStrides(a),x=y.getTypedArrayFromDType(n.dtype,h);for(let C=0;C<h;C++){let w=y.indexToLoc(C,d,g);for(let E=0;E<d;E++)w[E]<l[E]?w[E]=l[E]*2-w[E]-c:w[E]>=u[E]&&(w[E]=(u[E]-1)*2-w[E]+c);w=w.map((E,A)=>E-l[A]);let I=y.locToIndex(w,m,f);x[C]=p[I]}return{dataId:e.write(x,a,n.dtype),shape:a,dtype:n.dtype}}var qk={kernelName:ci,backendName:"cpu",kernelFunc:vW};var kW=Ot((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),EW=Mt(Wn,kW),jk={kernelName:Wn,backendName:"cpu",kernelFunc:EW};var Yk=zc(lp());function i0(r){let{inputs:t,backend:e,attrs:o}=r,{logits:n}=t,{dim:s}=o,i=n.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let l=y.parseAxisParam([a],n.shape),u=s0({inputs:{x:n},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=S.expandShapeToKeepDim(u.shape,l),p=Dt({inputs:{x:u},backend:e,attrs:{shape:c}}),m=Qm({inputs:{a:n,b:p},backend:e}),f=$w({inputs:{x:m},backend:e}),h=As({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),d=Dt({inputs:{x:h},backend:e,attrs:{shape:c}}),g=ef({inputs:{a:f,b:d},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),g}var Xk={kernelName:ki,backendName:"cpu",kernelFunc:i0};function AW(r){let{inputs:t,backend:e,attrs:o}=r,{logits:n}=t,{numSamples:s,seed:i,normalized:a}=o;j(n,"multinomial");let l=a?n:i0({inputs:{logits:n},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=e.data.get(l.dataId).values,m=[u,s],f=y.makeZerosTypedArray(y.sizeFromShape(m),"int32");for(let h=0;h<u;++h){let d=h*c,g=new Float32Array(c-1);g[0]=p[d];for(let C=1;C<g.length;++C)g[C]=g[C-1]+p[d+C];let x=Yk.alea(i.toString()),b=h*s;for(let C=0;C<s;++C){let w=x();f[b+C]=g.length;for(let I=0;I<g.length;I++)if(w<g[I]){f[b+C]=I;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(m,"int32",f)}var Zk={kernelName:Af,backendName:"cpu",kernelFunc:AW};var $W=tr.nonMaxSuppressionV3Impl;function DW(r){let{inputs:t,backend:e,attrs:o}=r,{boxes:n,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=o;j(n,"NonMaxSuppression");let u=e.data.get(n.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=$W(u,c,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var Jk={kernelName:Xl,backendName:"cpu",kernelFunc:DW};var RW=tr.nonMaxSuppressionV4Impl;function FW(r){let{inputs:t,backend:e,attrs:o}=r,{boxes:n,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=o;j(n,"NonMaxSuppressionPadded");let c=e.data.get(n.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=RW(c,p,i,a,l,u);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var Qk={kernelName:Yl,backendName:"cpu",kernelFunc:FW};var _W=tr.nonMaxSuppressionV5Impl;function OW(r){let{inputs:t,backend:e,attrs:o}=r,{boxes:n,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=o;j(n,"NonMaxSuppressionWithScore");let c=e.data.get(n.dataId).values,p=e.data.get(s.dataId).values,m=i,f=a,h=l,d=u,{selectedIndices:g,selectedScores:x}=_W(c,p,m,f,h,d);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var tE={kernelName:Zl,backendName:"cpu",kernelFunc:OW};function LW(r){let{inputs:t,backend:e,attrs:o}=r,{indices:n}=t,{dtype:s,depth:i,onValue:a,offValue:l}=o;j(n,"oneHot");let u=y.sizeFromShape(n.shape),c=new Float32Array(u*i);c.fill(l);let p=e.data.get(n.dataId).values;for(let m=0;m<u;++m)p[m]>=0&&p[m]<i&&(c[m*i+p[m]]=a);return e.makeTensorInfo([...n.shape,i],s,c)}var eE={kernelName:fi,backendName:"cpu",kernelFunc:LW};function nf(r){let{inputs:t,backend:e}=r,{x:o}=t;if(o.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(o.dtype==="complex64"){let n=yo({inputs:{input:o},backend:e}),s=nf({inputs:{x:n},backend:e}),i=ln({inputs:{input:o},backend:e}),a=nf({inputs:{x:i},backend:e}),l=_e({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return of({backend:e,attrs:{shape:o.shape,value:0,dtype:o.dtype}})}var rE={kernelName:$i,backendName:"cpu",kernelFunc:nf};function oE(r){let{inputs:t,backend:e}=r,{x:o}=t;if(o.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(o.dtype==="complex64"){let n=yo({inputs:{input:o},backend:e}),s=oE({inputs:{x:n},backend:e}),i=ln({inputs:{input:o},backend:e}),a=nf({inputs:{x:i},backend:e}),l=_e({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return of({backend:e,attrs:{shape:o.shape,value:1,dtype:o.dtype}})}var nE={kernelName:mi,backendName:"cpu",kernelFunc:oE};function a0(r){let{inputs:t,backend:e,attrs:o}=r,{axis:n}=o;if(t.length===1)return yc({inputs:{input:t[0]},backend:e,attrs:{dim:n}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=t.map(c=>{let p=yc({inputs:{input:c},backend:e,attrs:{dim:n}});return a.push(p),p}),u=Zi({inputs:l,backend:e,attrs:{axis:n}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}var sE={kernelName:hi,backendName:"cpu",kernelFunc:a0};function PW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{paddings:s,constantValue:i}=o;j(n,"pad");let a=s.map((b,C)=>b[0]+n.shape[C]+b[1]),l=s.map(b=>b[0]),u=e.data.get(n.dataId).values,c=y.sizeFromShape(n.shape),p=n.shape.length,m=y.computeStrides(n.shape),f=y.sizeFromShape(a),h=a.length,d=y.computeStrides(a),g=y.getTypedArrayFromDType(n.dtype,f);i!==0&&g.fill(i);for(let b=0;b<c;b++){let w=y.indexToLoc(b,p,m).map((E,A)=>E+l[A]),I=y.locToIndex(w,h,d);g[I]=u[b]}return{dataId:e.write(g,a,n.dtype),shape:a,dtype:n.dtype}}var sg={kernelName:di,backendName:"cpu",kernelFunc:PW};var zW=Ot((r,t)=>Math.pow(r,t)),MW=Mt(Hn,zW),iE={kernelName:Hn,backendName:"cpu",kernelFunc:MW};function BW(r){let{inputs:t,backend:e,attrs:o}=r,{paramsNestedSplits:n,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=o,l=n.map(x=>e.data.get(x.dataId).values),u=n.map(x=>x.shape),c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,[m,f,h]=Wd(l,u,c,s.shape,s.dtype,p,i.shape,a),d=m.map(x=>e.makeTensorInfo([x.length],"int32",x)),g=e.makeTensorInfo(h,s.dtype,f);return d.concat([g])}var aE={kernelName:$f,backendName:"cpu",kernelFunc:BW};function VW(r){let{inputs:t,backend:e}=r,{starts:o,limits:n,deltas:s}=t,i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values,l=e.data.get(s.dataId).values,[u,c]=Ud(i,o.shape,o.dtype,a,n.shape,l,s.shape),p=e.makeTensorInfo([u.length],"int32",u),m=e.makeTensorInfo([c.length],o.dtype,c);return[p,m]}var lE={kernelName:Df,backendName:"cpu",kernelFunc:VW};function GW(r){let{inputs:t,backend:e,attrs:o}=r,{shape:n,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=o,u=e.data.get(n.dataId).values,c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,m=a.map(g=>e.data.get(g.dataId).values),f=a.map(g=>g.shape),[h,d]=Hd(u,n.shape,c,s.shape,s.dtype,p,i.shape,m,f,l);return e.makeTensorInfo(h,s.dtype,d)}var uE={kernelName:Rf,backendName:"cpu",kernelFunc:GW};function WW(r){let{backend:t,attrs:e}=r,{start:o,stop:n,dtype:s,step:i}=e,a=Kd(o,n,i,s);return t.makeTensorInfo([a.length],s,a)}var cE={kernelName:Jl,backendName:"cpu",kernelFunc:WW};var UW=bt(Kn,r=>1/r),pE={kernelName:Kn,backendName:"cpu",kernelFunc:UW};function HW(r){let{inputs:t,backend:e,attrs:o}=r,{images:n}=t,{alignCorners:s,halfPixelCenters:i,size:a}=o;j(n,"resizeBilinear");let l=y.computeStrides(n.shape),[u,c]=a,[p,m,f,h]=n.shape,d=e.data.get(n.dataId).values,g=new Float32Array(y.sizeFromShape([p,u,c,h])),x=[s&&u>1?m-1:m,s&&c>1?f-1:f],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],C=0,w=x[0]/b[0],I=x[1]/b[1];for(let E=0;E<p;E++)for(let A=0;A<u;A++){let $;i?$=w*(A+.5)-.5:$=w*A;let _=Math.max(0,Math.floor($)),L=$-_,B=Math.min(m-1,Math.ceil($)),V=E*l[0]+_*l[1],G=E*l[0]+B*l[1];for(let U=0;U<c;U++){let W;i?W=I*(U+.5)-.5:W=I*U;let q=Math.max(0,Math.floor(W)),Z=W-q,K=Math.min(f-1,Math.ceil(W)),J=V+q*l[2],tt=G+q*l[2],et=V+K*l[2],nt=G+K*l[2];for(let rt=0;rt<h;rt++){let lt=d[J+rt],st=d[tt+rt],pt=d[et+rt],It=d[nt+rt],Tt=lt+(pt-lt)*Z,St=st+(It-st)*Z,Ft=Tt+(St-Tt)*L;g[C++]=Ft}}}return e.makeTensorInfo([p,u,c,h],"float32",g)}var mE={kernelName:wi,backendName:"cpu",kernelFunc:HW};function KW(r){let{inputs:t,backend:e,attrs:o}=r,{images:n,dy:s}=t,{alignCorners:i}=o;j([s,n],"resizeBilinearGrad");let a=y.computeStrides(n.shape),[l,u,c,p]=n.shape,[,m,f]=s.shape,h=new Float32Array(l*u*c*p),d=[i&&m>1?u-1:u,i&&f>1?c-1:c],g=[i&&m>1?m-1:m,i&&f>1?f-1:f],x=d[0]/g[0],b=d[1]/g[1],C=e.data.get(s.dataId).values,w=0;for(let I=0;I<l;I++){let E=I*a[0];for(let A=0;A<m;A++){let $=A*x,_=Math.floor($),L=Math.min(Math.ceil($),u-1),B=E+_*a[1],V=E+L*a[1],G=$-_,U=1-G;for(let W=0;W<f;W++){let q=W*b,Z=Math.floor(q),K=Math.min(Math.ceil(q),c-1),J=q-Z,tt=1-J,et=B+Z*a[2],nt=B+K*a[2],rt=V+Z*a[2],lt=V+K*a[2],st=U*tt,pt=U*J,It=G*tt,Tt=G*J;for(let St=0;St<p;St++){let Ft=C[w++];h[et+St]+=Ft*st,h[nt+St]+=Ft*pt,h[rt+St]+=Ft*It,h[lt+St]+=Ft*Tt}}}}return e.makeTensorInfo([l,c,u,p],"float32",h)}var fE={kernelName:eu,backendName:"cpu",kernelFunc:KW};function qW(r){let{inputs:t,backend:e,attrs:o}=r,{images:n}=t,{alignCorners:s,halfPixelCenters:i,size:a}=o;j(n,"resizeNearestNeighbor");let l=y.computeStrides(n.shape),[u,c]=a,[p,m,f,h]=n.shape,d=e.data.get(n.dataId).values,g=new Float32Array(p*u*c*h),x=[s&&u>1?m-1:m,s&&c>1?f-1:f],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],C=x[0]/b[0],w=x[1]/b[1],I=0;for(let E=0;E<p;E++){let A=E*l[0];for(let $=0;$<u;$++){let _=i?C*($+.5):C*$,L=Math.min(m-1,s?Math.round(_):Math.floor(_));i&&(L=Math.max(0,L));let B=A+L*l[1];for(let V=0;V<c;V++){let G=i?w*(V+.5):w*V,U=Math.min(f-1,s?Math.round(G):Math.floor(G));i&&(U=Math.max(0,U));let W=B+U*l[2];for(let q=0;q<h;q++){let Z=d[W+q];g[I++]=Z}}}}return e.makeTensorInfo([p,u,c,h],n.dtype,g)}var hE={kernelName:bi,backendName:"cpu",kernelFunc:qW};function jW(r){let{inputs:t,backend:e,attrs:o}=r,{images:n,dy:s}=t,{alignCorners:i}=o;j([s,n],"resizeNearestNeighborGrad");let a=y.computeStrides(n.shape),l=y.computeStrides(s.shape),[u,c,p,m]=n.shape,[,f,h]=s.shape,d=new Float32Array(u*c*p*m),g=e.data.get(s.dataId).values,x=[i&&f>1?c-1:c,i&&h>1?p-1:p],b=[i&&f>1?f-1:f,i&&h>1?h-1:h],C=x[0]/b[0],w=x[1]/b[1],I=1/C,E=1/w,A=Math.ceil(I)*2+2,$=Math.ceil(E)*2+2;for(let _=0;_<u;_++){let L=_*a[0];for(let B=0;B<c;B++){let V=L+B*a[1],G=Math.floor(B*I),U=Math.floor(G-A/2);for(let W=0;W<p;W++){let q=V+W*a[2],Z=Math.floor(W*E),K=Math.floor(Z-$/2);for(let J=0;J<m;J++){let tt=0;for(let et=0;et<A;et++){let nt=et+U;if(nt<0||nt>=f)continue;let rt=L+nt*l[1],lt=nt*C,st=Math.min(c-1,i?Math.round(lt):Math.floor(lt));if(B===st)for(let pt=0;pt<$;pt++){let It=pt+K;if(It<0||It>=h)continue;let Tt=rt+It*l[2],St=It*w,Ft=Math.min(p-1,i?Math.round(St):Math.floor(St));W===Ft&&(tt+=g[Tt+J])}}d[q+J]=tt}}}}return e.makeTensorInfo(n.shape,n.dtype,d)}var dE={kernelName:tu,backendName:"cpu",kernelFunc:jW};function XW(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{dims:s}=o;j(n,"reverse");let i=n.shape.length,a=y.parseAxisParam(s,n.shape);if(i===0)return rr({inputs:{x:n},backend:e});let l=new Ut(n.shape,n.dtype),u=e.bufferSync(n);for(let c=0;c<l.size;c++){let p=l.indexToLoc(c),m=p.slice();a.forEach(f=>m[f]=n.shape[f]-1-m[f]),l.set(u.get(...m),...p)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}var gE={kernelName:Ci,backendName:"cpu",kernelFunc:XW};var xE={kernelName:au,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:o}=r,{radians:n,fillValue:s,center:i}=t,a=e,l=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(o.shape)),[u,c,p,m]=o.shape,[f,h]=S.getImageCenter(i,c,p),d=255,g=Math.sin(n),x=Math.cos(n),b=a.data.get(o.dataId).values;for(let w=0;w<u;w++){let I=w*p*c*m;for(let E=0;E<c;E++){let A=E*(p*m);for(let $=0;$<p;$++){let _=$*m;for(let L=0;L<m;L++){let B=[u,E,$,L],V=B[2],G=B[1],U=(V-f)*x-(G-h)*g,W=(V-f)*g+(G-h)*x;U=Math.round(U+f),W=Math.round(W+h);let q=s;if(typeof s!="number"&&(L===3?q=d:q=s[L]),U>=0&&U<p&&W>=0&&W<c){let K=W*(p*m),J=U*m,tt=I+K+J+L;q=b[tt]}let Z=I+A+_+L;l[Z]=q}}}}return{dataId:a.write(l,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var YW=bt(Xn,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),yE={kernelName:Xn,backendName:"cpu",kernelFunc:YW};function ZW(r){let{inputs:t,backend:e,attrs:o}=r,{indices:n,updates:s}=t,{shape:i}=o,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=S.calculateShapes(s,n,i),m=!0,f=e.bufferSync(n),h=e.bufferSync(s),d=Es(f,h,i,p,u,l,a,c,0,m);return e.makeTensorInfo(i,d.dtype,d.values)}var bE={kernelName:Ff,backendName:"cpu",kernelFunc:ZW};function JW(r,t){let e=0,o=r.length,n=0;for(;e<o;)n=Math.floor((e+o)/2),r[n]<t?e=n+1:o=n;return o}function QW(r,t){let e=0,o=r.length,n=0;for(;e<o;)n=Math.floor((e+o)/2),r[n]<=t?e=n+1:o=n;return o}function wE(r,t,e,o,n,s){let i=y.getArrayFromDType("int32",e*n);for(let a=0;a<e;++a){let l=r.slice(a*o,(a+1)*o),u=a*n;for(let c=0;c<n;++c)i[u+c]=s==="left"?JW(l,t[c+u]):QW(l,t[c+u])}return i}function tU(r){let{inputs:t,backend:e,attrs:o}=r,{sortedSequence:n,values:s}=t,{side:i}=o,a=e.data.get(n.dataId).values,l=e.data.get(s.dataId).values,u=wE(a,l,n.shape[0],n.shape[1],s.shape[1],i);return e.makeTensorInfo(s.shape,"int32",u)}var CE={kernelName:_f,backendName:"cpu",kernelFunc:tU};function eU(r){let{inputs:t,backend:e}=r,{condition:o,t:n,e:s}=t;j([o,n,s],"select");let i=o.shape.length,a=e.data.get(o.dataId).values,l=e.data.get(n.dataId).values,u=e.data.get(s.dataId).values,c=Te(n.dtype,s.dtype),p=y.makeZerosTypedArray(y.sizeFromShape(n.shape),c),m=0,f=i===0||i>1||n.shape.length===1?1:y.sizeFromShape(n.shape.slice(1));for(let h=0;h<a.length;h++)for(let d=0;d<f;d++)a[h]===1?p[m++]=l[h]:p[m++]=u[h];return e.makeTensorInfo(n.shape,c,p)}var IE={kernelName:Ii,backendName:"cpu",kernelFunc:eU};var rU=S.SELU_SCALEALPHA,oU=S.SELU_SCALE,nU=bt(Zn,r=>r>=0?oU*r:rU*(Math.exp(r)-1)),SE={kernelName:Zn,backendName:"cpu",kernelFunc:nU};var sU=bt(ts,r=>r<0?-1:r>0?1:0),NE={kernelName:ts,backendName:"cpu",kernelFunc:sU};var iU=bt(Jn,r=>Math.sin(r)),TE={kernelName:Jn,backendName:"cpu",kernelFunc:iU};var aU=bt(Qn,r=>Math.sinh(r)),vE={kernelName:Qn,backendName:"cpu",kernelFunc:aU};var lU=11920928955078125e-23,kE=Math.log(lU)+2,uU=bt(rs,r=>{let t=r>-kE,e=r<kE,o=Math.exp(r),n;return e?n=o:t?n=r:n=Math.log(1+o),n}),EE={kernelName:rs,backendName:"cpu",kernelFunc:uU};function cU(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{blockShape:s,paddings:i}=o;j([n],"spaceToBatchND");let a=y.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let E=1+s.length;E<n.shape.length;++E)l.push([0,0]);let u=sg.kernelFunc({inputs:{x:n},backend:e,attrs:{paddings:l,constantValue:0}}),c=S.getReshaped(u.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(u.shape,s,a,!1),d=Dt({inputs:{x:u},backend:e,attrs:{shape:c}}),b=fe({inputs:{x:d},backend:e,attrs:{perm:p}}),I=Dt({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(b),I}var AE={kernelName:Ti,backendName:"cpu",kernelFunc:cU};function pU(r){let{inputs:t,backend:e}=r,{indices:o,values:n,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${o.shape}`);if(n.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${n.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(o.dataId).values,l=e.data.get(n.dataId).values,u=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,m,f,h,d]=qd(a,o.shape,o.dtype,l,n.dtype,u,c);return[e.makeTensorInfo(m,o.dtype,p),e.makeTensorInfo([m[0]],n.dtype,f),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}var $E={kernelName:Of,backendName:"cpu",kernelFunc:pU};function mU(r){let{inputs:t,backend:e}=r,{inputIndices:o,inputShape:n,newShape:s}=t;if(o.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${o.shape}`);if(n.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${n.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(n.dataId).values),a=e.data.get(o.dataId).values,l=Array.from(e.data.get(s.dataId).values),[u,c,p]=jd(a,o.shape,o.dtype,i,l);return[e.makeTensorInfo(c,o.dtype,u),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var DE={kernelName:Lf,backendName:"cpu",kernelFunc:mU};function fU(r){let{inputs:t,backend:e}=r,{data:o,indices:n,segmentIds:s}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(n.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values,l=e.data.get(s.dataId).values,[u,c]=gc(i,o.shape,o.dtype,a,l,!0);return e.makeTensorInfo(c,o.dtype,u)}var RE={kernelName:Pf,backendName:"cpu",kernelFunc:fU};function hU(r){let{inputs:t,backend:e}=r,{data:o,indices:n,segmentIds:s}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(n.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values,l=e.data.get(s.dataId).values,[u,c]=gc(i,o.shape,o.dtype,a,l);return e.makeTensorInfo(c,o.dtype,u)}var FE={kernelName:zf,backendName:"cpu",kernelFunc:hU};function dU(r){let{inputs:t,backend:e,attrs:o}=r,{sparseIndices:n,sparseValues:s,defaultValue:i}=t,{outputShape:a}=o,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,n,a),f=!1,h=e.bufferSync(n),d;switch(s.dtype){case"bool":{let g=e.bufferSync(s),x=Boolean(e.data.get(i.dataId).values[0]);d=Es(h,g,a,m,c,u,l,p,x,f);break}case"float32":{let g=e.bufferSync(s),x=e.data.get(i.dataId).values[0];d=Es(h,g,a,m,c,u,l,p,x,f);break}case"int32":{let g=e.bufferSync(s),x=e.data.get(i.dataId).values[0];d=Es(h,g,a,m,c,u,l,p,x,f);break}case"string":{let g=e.bufferSync(s),x=y.decodeString(e.data.get(i.dataId).values[0]);d=Es(h,g,a,m,c,u,l,p,x,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,d.dtype,d.values)}var _E={kernelName:Mf,backendName:"cpu",kernelFunc:dU};function gU(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{numOrSizeSplits:s,axis:i}=o,a=y.parseAxisParam(i,n.shape)[0],l=S.prepareSplitSize(n,s,a),u=new Array(n.shape.length).fill(0),c=n.shape.slice();return l.map(p=>{let m=[...c];m[a]=p;let f=Io({inputs:{x:n},backend:e,attrs:{begin:u,size:m}});return u[a]+=p,f})}var OE={kernelName:vi,backendName:"cpu",kernelFunc:gU};var LE={kernelName:ru,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,o=t;j(e,"square");let n=o.data.get(e.dataId).values,s=new Float32Array(n.length);for(let a=0;a<n.length;++a){let l=n[a];s[a]=l*l}return{dataId:o.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var xU=bt(ls,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),PE={kernelName:ls,backendName:"cpu",kernelFunc:xU};function yU(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=o;j(n,"stridedSlice");let{finalShapeSparse:f,finalShape:h,isIdentity:d,sliceDim0:g,isSimpleSlice:x,begin:b,end:C,strides:w}=Pe.sliceInfo(n.shape,s,i,a,l,u,c,p,m),I;if(d)I=Dt({inputs:{x:n},backend:e,attrs:{shape:h}});else if(g||x){y.assert(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);let E=Pe.computeOutShape(b,C,w),A=Io({inputs:{x:n},backend:e,attrs:{begin:b,size:E}});I=Dt({inputs:{x:A},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(A)}else{let E=e.bufferSync(n),A=Xd(f,E,w,b);I=e.makeTensorInfo(h,A.dtype,A.values)}return I}var zE={kernelName:ou,backendName:"cpu",kernelFunc:yU};function bU(r){let{inputs:t,backend:e,attrs:o}=r,{separator:n,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=o,{data:c,dataSplits:p}=t,m=e.data.get(c.dataId).values,f=e.data.get(p.dataId).values,[h,d]=Yd(m,f,n,s,i,a,l,u);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",d)]}var ME={kernelName:Bf,backendName:"cpu",kernelFunc:bU};function wU(r){let{inputs:t,backend:e,attrs:o}=r,{skipEmpty:n}=o,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values[0],[u,c,p]=Zd(a,l,n),m=c.length;return[e.makeTensorInfo([m,2],"int32",u),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var BE={kernelName:Vf,backendName:"cpu",kernelFunc:wU};function CU(r){let{inputs:t,backend:e,attrs:o}=r,{numBuckets:n}=o,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(n<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=Jd(i,n);return e.makeTensorInfo(s.shape,"int32",a)}var VE={kernelName:Gf,backendName:"cpu",kernelFunc:CU};var IU=bt(is,r=>Math.tan(r)),GE={kernelName:is,backendName:"cpu",kernelFunc:IU};var SU=bt(as,r=>Math.tanh(r)),WE={kernelName:as,backendName:"cpu",kernelFunc:SU};function NU(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{reps:s}=o;j(n,"tile");let i=Qd(e.bufferSync(n),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var UE={kernelName:Ko,backendName:"cpu",kernelFunc:NU};function TU(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{k:s,sorted:i}=o;j(n,"topk");let a=e.data.get(n.dataId).values,[l,u]=tg(a,n.shape,n.dtype,s,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}var HE={kernelName:nu,backendName:"cpu",kernelFunc:TU};function vU(r){let{inputs:t,attrs:e,backend:o}=r,{image:n,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,p,m,f]=n.shape,[h,d]=u!=null?u:[p,m],g=[c,h,d,f],x=y.computeStrides(n.shape),b=x[0],C=x[1],w=x[2],I=y.computeStrides(g),E=I[0],A=I[1],$=I[2],_=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(g));_.fill(l);let L=o.data.get(n.dataId).values,B=o.data.get(s.dataId).values;for(let G=0;G<c;++G){let U=s.shape[0]===1?B:B.subarray(G*8,G*8+8);for(let W=0;W<h;++W)for(let q=0;q<d;++q)for(let Z=0;Z<f;++Z){let K,J=U[6]*q+U[7]*W+1;if(J===0)continue;let tt=(U[0]*q+U[1]*W+U[2])/J,et=(U[3]*q+U[4]*W+U[5])/J,nt=KE(tt,m,a),rt=KE(et,p,a);switch(i){case"nearest":K=DU(L,p,m,b,C,w,G,rt,nt,Z,l);break;case"bilinear":K=RU(L,p,m,b,C,w,G,rt,nt,Z,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let lt=G*E+W*A+q*$+Z;_[lt]=K}return o.makeTensorInfo(g,n.dtype,_)}return{dataId:o.write(_,g,n.dtype),shape:n.shape,dtype:n.dtype}}var qE={kernelName:su,backendName:"cpu",kernelFunc:vU};function KE(r,t,e){switch(e){case"reflect":return kU(r,t);case"wrap":return EU(r,t);case"nearest":return $U(r,t);case"constant":default:return AU(r,t)}}function kU(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let o=2*t;e<o&&(e=o*Math.trunc(-e/o)+e),e=e<-t?e+o:-e-1}else if(e>t-1)if(t<=1)e=0;else{let o=2*t;e-=o*Math.trunc(e/o),e>=t&&(e=o-e-1)}return y.clamp(0,e,t-1)}function EU(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let o=t-1;e+=t*(Math.trunc(-e/o)+1)}else if(e>t-1)if(t<=1)e=0;else{let o=t-1;e-=t*Math.trunc(e/o)}return y.clamp(0,e,t-1)}function AU(r,t){return r}function $U(r,t){return y.clamp(0,r,t-1)}function sf(r,t,e,o,n,s,i,a,l,u,c){let p=i*o+a*n+l*s+u;return 0<=a&&a<t&&0<=l&&l<e?r[p]:c}function DU(r,t,e,o,n,s,i,a,l,u,c){let p=Math.round(a),m=Math.round(l);return sf(r,t,e,o,n,s,i,p,m,u,c)}function RU(r,t,e,o,n,s,i,a,l,u,c){let p=Math.floor(a),m=Math.floor(l),f=p+1,h=m+1,d=(h-l)*sf(r,t,e,o,n,s,i,p,m,u,c)+(l-m)*sf(r,t,e,o,n,s,i,p,h,u,c),g=(h-l)*sf(r,t,e,o,n,s,i,f,m,u,c)+(l-m)*sf(r,t,e,o,n,s,i,f,h,u,c);return(f-a)*d+(a-p)*g}function FU(r){let{inputs:t,attrs:e,backend:o}=r,{axis:n}=e,{x:s}=t;j(s,"unique");let i=o.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:u}=eg(i,n,s.shape,s.dtype);return[o.makeTensorInfo(l,s.dtype,a),o.makeTensorInfo([u.length],"int32",u)]}var jE={kernelName:iu,backendName:"cpu",kernelFunc:FU};function _U(r){let{inputs:t,backend:e,attrs:o}=r,{value:n}=t,{axis:s}=o;s<0&&(s+=n.shape.length);let i=n.shape.length,a=n.shape[s],l=new Array(i-1),u=0;for(let f=0;f<i;f++)f!==s&&(l[u++]=n.shape[f]);let c=new Array(i).fill(0),p=n.shape.slice();p[s]=1;let m=new Array(a);for(let f=0;f<m.length;f++){c[s]=f;let h=Io({inputs:{x:n},backend:e,attrs:{begin:c,size:p}});m[f]=Dt({inputs:{x:h},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(h)}return m}var XE={kernelName:Ei,backendName:"cpu",kernelFunc:_U};function OU(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,segmentIds:s}=t,{numSegments:i}=o;j(n,"unsortedSegmentSum");let a=n.shape.length,l=s.shape.length,u=[],c=[],p=a-l,m=s;for(let h=0;h<p;++h){let d=yc({inputs:{input:m},backend:e,attrs:{dim:h+1}});m=d,c.push(d)}for(let h=0;h<i;++h){let d=y.createScalarValue(h,"int32"),g=e.makeTensorInfo([],"int32",d),x=Ew({inputs:{a:g,b:m},backend:e}),b=bo({inputs:{x},backend:e,attrs:{dtype:"float32"}}),C=ol({inputs:{a:b,b:n},backend:e}),w=As({inputs:{x:C},backend:e,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(g),c.push(x),c.push(b),c.push(C),c.push(w)}let f=a0({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),f}var YE={kernelName:Ai,backendName:"cpu",kernelFunc:OU};var LU=[I1,Fv,S1,N1,zv,T1,v1,k1,E1,A1,$1,D1,R1,F1,_1,L1,P1,z1,M1,C1,B1,V1,G1,W1,Pv,Mv,U1,_v,H1,q1,j1,X1,Y1,Z1,J1,Q1,tk,ek,rk,ok,nk,sk,ik,ak,lk,uk,ck,pk,mk,fk,dk,d1,gk,Bv,xk,Vv,yk,Gv,bk,wk,Ck,Wv,Ik,Sk,Nk,Tk,vk,Uv,Hv,Ov,kk,K1,Ek,Ak,$k,g1,Kv,qv,Dk,jv,Rk,Fk,_k,Ok,Lk,Pk,zk,Xv,Mk,Bk,Vk,Gk,Uk,Hk,Kk,Yv,qk,jk,Zk,Zv,Jv,Jk,Qk,tE,Qv,eE,nE,sE,sg,iE,x1,e1,aE,lE,uE,cE,Lv,rf,pE,y1,b1,w1,mE,fE,hE,dE,gE,xE,yE,i1,bE,CE,IE,SE,l1,NE,TE,vE,u1,Xk,EE,AE,$E,DE,RE,FE,_E,OE,p1,LE,m1,PE,zE,ME,BE,VE,f1,hk,GE,WE,UE,HE,qE,t1,jE,XE,YE,rE];for(let r of LU)Uf(r);var sl={},ig={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ZE(r,t){sl[r]=t}function zr(r,t){if(!(r in sl)||t!=null){let o=zU(r,t);if(o!==null)sl[r]=o;else return console.log("Could not get context for WebGL version",r),null}let e=sl[r];return e==null||e.isContextLost()?(delete sl[r],zr(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),sl[r])}function PU(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function zU(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t==null?PU(r):t;return e.addEventListener("webglcontextlost",o=>{o.preventDefault(),delete sl[r]},!1),P().getBool("SOFTWARE_WEBGL_ENABLED")&&(ig.failIfMajorPerformanceCaveat=!1),r===1?e.getContext("webgl",ig)||e.getContext("experimental-webgl",ig):e.getContext("webgl2",ig)}var Ji;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(Ji||(Ji={}));var or;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(or||(or={}));var je;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(je||(je={}));function il(r,t){return[t,r]}function JE(r,t){return r*t}function af(r){let t=y.sizeFromShape(r),e=Math.ceil(t/4);return y.sizeToSquarishShape(e)}function un(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function QE(r,t){let[e,o]=un(r,t);return e*o*4}function lf(r,t){let e=r,o,n,s,i,a,l,u,c,p,m;return P().getNumber("WEBGL_VERSION")===2?(o=e.R32F,n=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,p=e.HALF_FLOAT,m=e.FLOAT,l=e.RGBA8):(o=r.RGBA,n=r.RGBA,s=r.RGBA,i=e.RGBA,a=r.RGBA,u=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,m=r.FLOAT,l=r.RGBA),{internalFormatFloat:o,internalFormatHalfFloat:n,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function ut(r,t){let e=t();return P().getBool("DEBUG")&&MU(r),e}function MU(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+GU(r,t))}var BU=596e-10,VU=65504;function tA(r){return!!(P().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||BU<Math.abs(r)&&Math.abs(r)<VU)}function GU(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function uf(r,t){return $s(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function eA(r,t){let e=$s(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ut(r,()=>r.shaderSource(e,t)),ut(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function rA(r,t){let e=$s(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ut(r,()=>r.shaderSource(e,t)),ut(r,()=>r.compileShader(e)),P().get("ENGINE_COMPILE_ONLY"))return e;if(r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw m0(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var WU=/ERROR: [0-9]+:([0-9]+):/g;function m0(r,t){let e=WU.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let o=+e[1],n=r.split(`
`),s=n.length.toString().length+2,i=n.map((p,m)=>y.rightPad((m+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let l=i.slice(0,o-1),u=i.slice(o-1,o),c=i.slice(o);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${y.rightPad(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function oA(r){return $s(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function nA(r,t){if(ut(r,()=>r.linkProgram(t)),!P().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function lg(r,t){if(ut(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function sA(r,t){let e=$s(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return ut(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),ut(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function iA(r,t){let e=$s(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return ut(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),ut(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function aA(r){return $s(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function lA(r,t){let e=P().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let o=`[${r}x${t}]`;throw new Error("Requested texture size "+o+" is invalid.")}if(r>e||t>e){let o=`[${r}x${t}]`,n=`[${e}x${e}]`;throw new Error("Requested texture size "+o+" greater than WebGL maximum on this browser / GPU "+n+".")}}function uA(r){return $s(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function f0(r,t,e,o,n,s,i){let a=r.getAttribLocation(t,e);return a===-1?!1:(ut(r,()=>r.bindBuffer(r.ARRAY_BUFFER,o)),ut(r,()=>r.vertexAttribPointer(a,n,r.FLOAT,!1,s,i)),ut(r,()=>r.enableVertexAttribArray(a)),!0)}function UU(r,t,e){KU(r,e),ut(r,()=>r.activeTexture(r.TEXTURE0+e)),ut(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function cA(r,t,e){return $s(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function pA(r,t,e){return r.getUniformLocation(t,e)}function mA(r,t,e,o){ut(r,()=>UU(r,t,o)),ut(r,()=>r.uniform1i(e,o))}function ug(r,t,e){ut(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),ut(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function h0(r,t){ut(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),ut(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function cf(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+HU(r,t))}function HU(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function $s(r,t,e){let o=ut(r,()=>t());if(o==null)throw new Error(e);return o}function KU(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,o=t+r.TEXTURE0;if(o<r.TEXTURE0||o>e){let n=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${n}.`)}}function Qi(r,t=2){return y.sizeFromShape(r.slice(0,r.length-t))}function ta(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function pf(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[Qi(r),...ta(r)]),t}function fA(r,t=!1){let e=P().getNumber("WEBGL_MAX_TEXTURE_SIZE"),o=P().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");o===1/0&&P().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(o=e/2),t&&(e=e*2,o=o*2,r=r.map((a,l)=>l>=r.length-2?y.nearestLargerEven(r[l]):r[l]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=y.squeezeShape(r).newShape);let n=y.sizeFromShape(r),s=null;r.length<=1&&n<=e?s=[1,n]:r.length===2&&r[0]<=e&&r[1]<=e?s=r:r.length===3&&r[0]*r[1]<=e&&r[2]<=e?s=[r[0]*r[1],r[2]]:r.length===3&&r[0]<=e&&r[1]*r[2]<=e?s=[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e?s=[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e&&(s=[r[0],r[1]*r[2]*r[3]]);let i=s!=null&&Math.max(...s)>o&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let a=Qi(r),l=2,u=2;r.length&&([l,u]=ta(r)),n=a*(l/2)*(u/2),s=y.sizeToSquarishShape(n).map(c=>c*2)}else s=y.sizeToSquarishShape(n);return s}function ag(r){return r%2===0}function al(r,t){if(r=r.slice(-2),t=t.slice(-2),y.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r.slice(-1)[0],o=t.slice(-1)[0];if(e===o||ag(e)&&ag(o)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&ag(r[0])&&ag(t[0])}var u0,c0;function hA(r){if(u0==null){let t=zr(r);u0=t.getParameter(t.MAX_TEXTURE_SIZE)}return u0}function dA(r){if(c0==null){let t=zr(r);c0=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,c0)}function gA(r){if(r===0)return 0;let t,e=zr(r);return Yr(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Yr(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Yr(r,t){return r.getExtension(t)!=null}function d0(r){try{if(zr(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function xA(r){if(r===0)return!1;let t=zr(r);if(r===1){if(!Yr(t,"OES_texture_float"))return!1}else if(!Yr(t,"EXT_color_buffer_float"))return!1;return p0(t)}function yA(r){if(r===0)return!1;let t=zr(r);if(r===1){if(!Yr(t,"OES_texture_float")||!Yr(t,"WEBGL_color_buffer_float"))return!1}else{if(Yr(t,"EXT_color_buffer_float"))return p0(t);let o="EXT_color_buffer_half_float";if(Yr(t,o)){let n=t.getExtension(o);return qU(t,n)}return!1}return p0(t)}function p0(r){let t=lf(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e);let o=1,n=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,o,n,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(s),i}function qU(r,t){let e=lf(r,t),o=r.createTexture();r.bindTexture(r.TEXTURE_2D,o);let n=1,s=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,n,s,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,o,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(o),r.deleteFramebuffer(i),a}function bA(r){return r!==2?!1:zr(r).fenceSync!=null}function cn(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&y.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var yt=P();yt.registerFlag("HAS_WEBGL",()=>yt.getNumber("WEBGL_VERSION")>0);yt.registerFlag("WEBGL_VERSION",()=>d0(2)?2:d0(1)?1:0);yt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);yt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>yt.get("WEBGL_VERSION")===2);yt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);yt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);yt.registerFlag("WEBGL_PACK",()=>yt.getBool("HAS_WEBGL"));yt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_CLIP",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_REDUCE",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_LAZILY_UNPACK",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_CONV_IM2COL",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>hA(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>dA(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=yt.getNumber("WEBGL_VERSION");return r===0?0:gA(r)});yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>yt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!_i.isMobile());yt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>xA(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>yt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:yt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));yt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>yA(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>bA(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>yt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);yt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});yt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>_i.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});yt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);yt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);yt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);yt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);yt.registerFlag("WEBGL_EXP_CONV",()=>!1);yt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>yt.getBool("IS_TEST"));yt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);yt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);yt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);yt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function he(){let r,t,e,o,n,s,i,a,l,u;return P().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",o="in",n="texture",s="outputColor",i="out vec4 outputColor;",a=P().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",o="varying",n="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:o,texture2D:n,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function Bo(r,t,e="index"){let o=y.computeStrides(t);return o.map((n,s)=>{let i=`int ${r[s]} = ${e} / ${n}`,a=s===o.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * ${n}`:`index -= ${r[s]} * ${n}`;return`${i}; ${a};`}).join("")}function ll(r,t,e="index"){let o=y.computeStrides(t);return o.map((n,s)=>{let i=`int ${r[s]} = ${e} / outShapeStrides[${s}]`,a=s===o.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function jU(r,t){let e=r.length,o=r.map(s=>`${t}[${s}]`),n=new Array(e-1);n[e-2]=o[e-1];for(let s=e-3;s>=0;--s)n[s]=`(${n[s+1]} * ${o[s+1]})`;return n}function wA(r,t,e="index"){let o=r.map((s,i)=>i),n=jU(o,t);return n.map((s,i)=>{let a=`int ${r[i]} = ${e} / ${n[i]}`,l=i===n.length-1?`int ${r[i+1]} = ${e} - ${r[i]} * ${n[i]}`:`index -= ${r[i]} * ${n[i]}`;return`${a}; ${l};`}).join("")}function bc(r){let t=y.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function wc(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var pg=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:CA}=S;function IA(r,t,e){let o=[];if(r.forEach(f=>{let h=y.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?o.push(`uniform float ${f.name}${h>1?`[${h}]`:""};`):(o.push(`uniform sampler2D ${f.name};`),o.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){let{uniformShape:d}=mg(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(d.length){case 1:o.push(`uniform int ${f.name}Shape;`);break;case 2:o.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:o.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:o.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}o.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:o.push("uniform int outShape;");break;case 2:o.push("uniform ivec2 outShape;"),o.push("uniform int outShapeStrides;");break;case 3:o.push("uniform ivec3 outShape;"),o.push("uniform ivec2 outShapeStrides;");break;case 4:o.push("uniform ivec4 outShape;"),o.push("uniform ivec3 outShapeStrides;");break;default:break}o.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{o.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let n=o.join(`
`),s=r.map(f=>XU(f,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=t.texShape,a=he(),l=JU(a),u,c,p=e4(a);return t.isPacked?(u=YU(t.logicalShape,i,e.enableShapeUniforms),c=t4(a)):(u=ZU(t.logicalShape,i,e.enableShapeUniforms),c=QU(a)),e.packedInputs&&(p+=s4),[p,l,c,n,u,s,e.userCode].join(`
`)}function Ic(r,t=!1){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return x4(r,t);case 1:return b4(r,t);case 2:return C4(r,t);case 3:return S4(r,t);case 4:return T4(r,t);case 5:return v4(r);case 6:return k4(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function SA(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return g4(r);case 1:return y4(r,t);case 2:return w4(r,t);case 3:return I4(r,t);default:return N4(r,t)}}function XU(r,t,e=!1,o){let n="";e?n+=SA(r,o):n+=Ic(r,o);let s=r.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(e?n+=E4(r,t):n+=A4(r,t)),n}function YU(r,t,e){switch(r.length){case 0:return NA();case 1:return i4(r,t,e);case 2:return h4(r,t,e);case 3:return l4(r,t,e);default:return c4(r,t,e)}}function ZU(r,t,e){switch(r.length){case 0:return NA();case 1:return a4(r,t,e);case 2:return d4(r,t,e);case 3:return u4(r,t,e);case 4:return p4(r,t,e);case 5:return m4(r,t);case 6:return f4(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function JU(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function QU(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function t4(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function e4(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${r4}
    ${o4}
    ${n4}
  `}var r4=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,o4=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,n4=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,s4=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function NA(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function i4(r,t,e){let o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return o[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${o[1]}.0);
      }
    `:o[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${o[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      return 2 * (resTexRC.x * ${o[1]} + resTexRC.y);
    }
  `}function a4(r,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function l4(r,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(r[2]/2),s=n*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      int index = resTexRC.x * ${o[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec3(b, r, c);
    }
  `}function u4(r,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${ll(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let o=Bo(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${o}
      return ivec3(r, c, d);
    }
  `}function c4(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(r[r.length-1]/2),s=n*Math.ceil(r[r.length-2]/2),i=s,a="",l="b, r, c";for(let u=2;u<r.length-1;u++)i*=r[r.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,l=`b${u}, `+l;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      int index = resTexRC.x * ${o[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec${r.length}(${l});
    }
  `}function p4(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${ll(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let o=Bo(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${o}
      return ivec4(r, c, d, d2);
    }
  `}function m4(r,t){let e=Bo(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function f4(r,t){let e=Bo(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function h4(r,t,e){let o=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(y.arraysEqual(r,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${o[0]}, ${o[1]}));
      }
    `;let n=Math.ceil(r[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));

      int index = resTexRC.x * ${o[1]} + resTexRC.y;
      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec2(r, c);
    }
  `}function d4(r,t,e){return y.arraysEqual(r,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function ul(r){return`offset${r}`}function g4(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),o=he();return`
    vec4 ${e}() {
      return ${o.texture2D}(${t}, halfCR);
    }
  `}function x4(r,t){let e=r.name,o="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${o}() {return ${e};}`;let[n,s]=r.shapeInfo.texShape;if(n===1&&s===1)return`
      float ${o}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=ul(e);if(t)return`
    float ${o}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,l]=r.shapeInfo.texShape;return`
    float ${o}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function y4(r,t){let e=r.name,o="get"+e.charAt(0).toUpperCase()+e.slice(1),n=r.shapeInfo.texShape,s=he();if(t)return`
    vec4 ${o}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return`
    vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function b4(r,t){let e=r.name,o="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${o}(int index) {
        ${Sc(r)}
      }
    `;let n=r.shapeInfo.texShape,s=n[0],i=n[1];if(i===1&&s===1)return`
      float ${o}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=ul(e);return i===1?t?`
      float ${o}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${o}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${o}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${o}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${o}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${o}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function w4(r,t){let e=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],l=he();if(s!=null&&y.arraysEqual(e,s))return t?`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);

        return ${l.texture2D}(${o}, uv);
      }
    `:`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${o}, uv);
      }
    `;if(t)return`
    vec4 ${n}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${o}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${o}, uv);
    }
  `}function C4(r,t){let e=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=r.shapeInfo.texShape;if(s!=null&&y.arraysEqual(e,s)){if(t)return`
      float ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${n}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${o}, uv);
    }
  `}let{newShape:i,keptDims:a}=y.squeezeShape(e),l=i;if(l.length<e.length){let m=Nc(r,l),f=["row","col"];return`
      ${Ic(m,t)}
      float ${n}(int row, int col) {
        return ${n}(${Tc(f,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Sc(r)}
      }
    `;let u=s[0],c=s[1],p=ul(o);return c===1?t?`
      float ${n}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${o}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${o}TexShape[0]));
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${o}, uv);
    }
  `:u===1?t?`
      float ${n}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${o}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${o}TexShape[1]), 0.5);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${o}, uv);
    }
  `:t?`
      float ${n}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);
        return sampleTexture(${o}, uv);
      }
    `:`
  float ${n}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${o}, uv);
  }
`}function I4(r,t){let e=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let m=e.slice(1),f=[1,2],h=Nc(r,m),d=["b","row","col"];return`
        ${SA(h,t)}
        vec4 ${n}(int b, int row, int col) {
          return ${n}(${Tc(d,f)});
        }
      `}let a=he();if(t)return`
    vec4 ${n}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${o}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${o}, uv);
    }
  `}function S4(r,t){let e=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=y.squeezeShape(e),u=a;if(u.length<e.length){let d=Nc(r,u),g=["row","col","depth"];return`
        ${Ic(d,t)}
        float ${n}(int row, int col, int depth) {
          return ${n}(${Tc(g,l)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Sc(r)}
      }
    `;let c=r.shapeInfo.texShape,p=c[0],m=c[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return t?`
      float ${n}(int row, int col, int depth) {
        int stride1 = ${o}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
        float ${n}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${o}, uv);
        }
      `;if(m===i&&f==null)return t?`
      float ${n}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${o}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${n}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${o}, uv);
    }
  `;let h=ul(o);return t?`
    float ${n}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${o}Shape[1] * ${o}Shape[2];
      int stride1 = ${o}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${h};
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);
      return sampleTexture(${o}, uv);
    }
    `:`
      float ${n}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${o}, uv);
      }
  `}function N4(r,t){let e=r.name,o="get"+e.charAt(0).toUpperCase()+e.slice(1),n=he();if(t)return`
    vec4 ${o}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${n.texture2D}(${e}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],p=Math.ceil(s[i-1]/2),m=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",h=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let d=2;d<i-1;d++)f=`int b${d}, `+f,m*=s[i-d-1],h=`b${d} * ${m} + `+h;return`
    vec4 ${o}(${f}) {
      int index = ${h};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${n.texture2D}(${e}, uv);
    }
  `}function T4(r,t){let e=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:l,keptDims:u}=y.squeezeShape(e);if(l.length<e.length){let b=Nc(r,l),C=["row","col","depth","depth2"];return`
      ${Ic(b,t)}
      float ${n}(int row, int col, int depth, int depth2) {
        return ${n}(${Tc(C,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${Sc(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1],h=`int stride2 = ${o}Shape[3];`,d=`int stride1 = ${o}Shape[2] * stride2;`,g=`int stride0 = ${o}Shape[1] * stride1;`;if(f===a&&c==null)return t?`
      float ${n}(int row, int col, int depth, int depth2) {
        ${h}
        ${d}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${o}, uv);
      }
    `;if(f===s&&c==null)return t?`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${o}Shape[1] * ${o}Shape[2], ${o}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${o}, uv);
      }
    `;let x=ul(o);return t?`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${d}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${x});
      return sampleTexture(${o}, uv);
    }
  `:`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${x});
      return sampleTexture(${o}, uv);
    }
  `}function v4(r){let t=r.shapeInfo.logicalShape,e=r.name,o="get"+e.charAt(0).toUpperCase()+e.slice(1),n=t[4],s=t[3]*n,i=t[2]*s,a=t[1]*i,{newShape:l,keptDims:u}=y.squeezeShape(t);if(l.length<t.length){let d=Nc(r,l),g=["row","col","depth","depth2","depth3"];return`
      ${Ic(d)}
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        return ${o}(${Tc(g,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${n})) +
          depth3;
        ${Sc(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1];if(f===a&&c==null)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${n}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===n&&c==null)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=ul(e);return`
    float ${o}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${n} + depth3 + ${h};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function k4(r){let t=r.shapeInfo.logicalShape,e=r.name,o="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:n,keptDims:s}=y.squeezeShape(t);if(n.length<t.length){let g=Nc(r,n),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ic(g)}
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${o}(${Tc(x,s)});
      }
    `}let i=t[5],a=t[4]*i,l=t[3]*a,u=t[2]*l,c=t[1]*u;if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Sc(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],h=m[1];if(h===c&&p==null)return`
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(h===i&&p==null)return`
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let d=ul(e);return`
    float ${o}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${d};
      vec2 uv = uvFromFlat(${f}, ${h}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Sc(r){let t=r.name,e=y.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function E4(r,t){let e=r.name,o=e.charAt(0).toUpperCase()+e.slice(1),n="get"+o+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=CA(r.shapeInfo.logicalShape,t.logicalShape),l=Et(i),u=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(b=>`coords.${p[b+u]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((b,C)=>`coords.${p[C+u]}`).join(", ");let f="return outputValue;",d=y.sizeFromShape(r.shapeInfo.logicalShape)===1,x=y.sizeFromShape(t.logicalShape)===1;if(s===1&&!d&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(d&&!x)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let b=s-2,C=s-1;a.indexOf(b)>-1&&a.indexOf(C)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(C)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${n}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${o}(${m});
      ${f}
    }
  `}function A4(r,t){let e=r.name,o=e.charAt(0).toUpperCase()+e.slice(1),n="get"+o+"AtOutCoords",s=t.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!r.shapeInfo.isUniform&&a===l&&r.shapeInfo.flatOffset==null&&y.arraysEqual(i,s))return`
      float ${n}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let u=Et(l),c=CA(r.shapeInfo.logicalShape,t.logicalShape),p=l-a,m,f=["x","y","z","w","u","v"];a===0?m="":l<2&&c.length>=1?m="coords = 0;":m=c.map(d=>`coords.${f[d+p]} = 0;`).join(`
`);let h="";return l<2&&a>0?h="coords":h=r.shapeInfo.logicalShape.map((d,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${n}() {
      ${u} coords = getOutputCoords();
      ${m}
      return get${o}(${h});
    }
  `}function Et(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function mg(r,t,e){let{newShape:o,keptDims:n}=y.squeezeShape(t),s=t.length,i=r&&s===3&&t[0]===1,a=i?t.slice(1):o,l=!r&&s>1&&!y.arraysEqual(t,e)&&o.length<s||i;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:n}}function Nc(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function Tc(r,t){return t.map(e=>r[e]).join(", ")}function vA(r,t,e,o){let n=e.map((c,p)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),s=n.map(c=>c.shapeInfo),i={logicalShape:o.shape,texShape:o.texData.texShape,isUniform:!1,isPacked:o.texData.isPacked,flatOffset:null},a=IA(n,i,t),l=rA(r.gl,a),u=r.createProgram(l);return P().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},g0(r,t,u))}function g0(r,t,e){let o={},n={},s={},i=[],a,l,u,c=null,p=null;p=r.getUniformLocation(e,"NAN",!1),P().getNumber("WEBGL_VERSION")===1&&(c=r.getUniformLocation(e,"INFINITY",!1));let m=!1;for(let f=0;f<t.variableNames.length;f++){let h=t.variableNames[f];o[h]=r.getUniformLocation(e,h,m),o[`offset${h}`]=r.getUniformLocation(e,`offset${h}`,m),t.enableShapeUniforms&&(n[`${h}Shape`]=r.getUniformLocation(e,`${h}Shape`,m),s[`${h}TexShape`]=r.getUniformLocation(e,`${h}TexShape`,m))}return t.enableShapeUniforms&&(a=r.getUniformLocation(e,"outShape",m),u=r.getUniformLocation(e,"outShapeStrides",m),l=r.getUniformLocation(e,"outTexShape",m)),t.customUniforms&&t.customUniforms.forEach((f,h)=>{i[h]=r.getUniformLocation(e,f.name,m)}),{uniformLocations:o,customUniformLocations:i,infLoc:c,nanLoc:p,inShapesLocations:n,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:l}}function TA(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,o)=>{let n=e.logicalShape,s=t[o],i=s.shape;if(!y.arraysEqual(n,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${n} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,l=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function kA(r,t,e,o,n){t.program.enableShapeUniforms||(TA(t.inShapeInfos,e),TA([t.outShapeInfo],[o]));let s=o.texData.texture,i=o.texData.texShape;o.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):r.setOutputMatrixTexture(s.texture,i[0],i[1]),r.setProgram(t.webGLProgram),P().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,u)=>{let c=t.program.variableNames[u],p=t.uniformLocations[c],m=t.uniformLocations[`offset${c}`],f=t.inShapesLocations[`${c}Shape`],h=t.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:d}=mg(t.program.packedInputs,l.shape,l.texData.texShape);switch(d.length){case 1:r.gl.uniform1iv(f,new Int32Array(d));break;case 2:r.gl.uniform2iv(f,new Int32Array(d));break;case 3:r.gl.uniform3iv(f,new Int32Array(d));break;case 4:r.gl.uniform4iv(f,new Int32Array(d));break;default:break}}if(h&&r.gl.uniform2i(h,l.texData.texShape[0],l.texData.texShape[1]),p!=null){if(l.isUniform){if(y.sizeFromShape(l.shape)<2)r.gl.uniform1f(p,l.uniformValues[0]);else{let d=l.uniformValues;d instanceof Float32Array||(d=new Float32Array(d)),r.gl.uniform1fv(p,d)}return}l.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,l.texData.slice.flatOffset),r.setInputMatrixTexture(l.texData.texture.texture,p,u)}});let a=t.outShapeLocation;if(a)switch(o.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(o.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(o.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(o.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(o.shape));break;default:break}if(t.outShapeStridesLocation){let l=y.computeStrides(o.shape);switch(o.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),t.program.customUniforms&&n&&t.program.customUniforms.forEach((l,u)=>{let c=t.customUniformLocations[u],p=n[u];if(l.type==="float")r.gl.uniform1fv(c,p);else if(l.type==="vec2")r.gl.uniform2fv(c,p);else if(l.type==="vec3")r.gl.uniform3fv(c,p);else if(l.type==="vec4")r.gl.uniform4fv(c,p);else if(l.type==="int")r.gl.uniform1iv(c,p);else if(l.type==="ivec2")r.gl.uniform2iv(c,p);else if(l.type==="ivec3")r.gl.uniform3iv(c,p);else if(l.type==="ivec4")r.gl.uniform4iv(c,p);else throw Error(`uniform type ${l.type} is not supported yet.`)}),r.executeProgram()}function EA(r,t,e){let o="";t.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:p}=mg(r.packedInputs,i.shape,l),m="",f="",h="";if(c.length===1&&r.packedInputs){let I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];m=`${I[0]>1}_${I[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let I=y.computeStrides(c);h=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}let d=i.shape.length,g=c.length===2&&y.arraysEqual(i.shape,l),x=y.sizeFromShape(i.shape)===1,b=S.getBroadcastDims(i.shape,e.shape),C=!r.packedInputs&&d===e.shape.length&&y.arraysEqual(l,e.texData.texShape),w=r.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;o+=`${d}_${C}_${u?p:""}_${c.length}_${x}_${b}_${g}_${m}_${f}_${h}_${w}_${a}`}else{let l=i.isUniform?"uniform":i.texData.texShape;o+=`${i.shape}_${l}_${a}`}});let n=r.userCode,s=r.constructor.name;return s+="_"+o+"_"+n+`${P().getNumber("WEBGL_VERSION")}`,s}function Xt(r){return P().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var fg=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ji.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=he();this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?ll(["r","c","d"],t):Bo(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var hg=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ji.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=he();this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?ll(["r","c","d"],t):Bo(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var dg=class{constructor(t){this.variableNames=["A"],this.outTexUsage=or.DOWNLOAD;let e=he();this.outputShape=t,this.userCode=`
      ${pg}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var gg=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=or.DOWNLOAD;let e=he();this.outputShape=t,this.userCode=`
      ${pg}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var R4={R:0,G:1,B:2,A:3},mf=class{constructor(t,e=!1,o="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=he();this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<o.length;a++){let l=o[a];i+=`
          if(offset == ${a}) {
            result = values[${R4[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?wc():bc(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${o.length});

        flatIndex = idiv(flatIndex, ${o.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${n.texture2D}(A, uv);
          ${i}
        }
        ${n.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var xg=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=he();this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length);let n="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let l=i*2+a;n+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${o.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?wc():bc(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${n}

          ${o.output} = ${s};
        }
    `}};function AA(r){let t=he(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return eA(r,e)}function $A(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return sA(r,t)}function DA(r){let t=new Uint16Array([0,1,2,2,1,3]);return iA(r,t)}function ff(r,t,e,o,n,s){lA(t,e);let i=aA(r),a=r.TEXTURE_2D;return ut(r,()=>r.bindTexture(a,i)),ut(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),ut(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),ut(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),ut(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),P().getNumber("WEBGL_VERSION")===1?ut(r,()=>r.texImage2D(a,0,o,t,e,0,n,s,null)):ut(r,()=>r.texStorage2D(a,1,o,t,e)),ut(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function x0(r){return r.internalFormatFloat}function RA(r,t,e,o){let[n,s]=il(t,e);return ff(r,n,s,x0(o),o.textureFormatFloat,r.FLOAT)}function y0(r){return r.internalFormatHalfFloat}function FA(r,t,e,o){let[n,s]=il(t,e);return ff(r,n,s,y0(o),o.textureFormatFloat,o.textureTypeHalfFloat)}function b0(r){return r.downloadTextureFormat}function _A(r,t,e,o){let[n,s]=il(t,e);return ff(r,n,s,b0(o),r.RGBA,r.UNSIGNED_BYTE)}function w0(r){return r.internalFormatPackedFloat}function OA(r,t,e,o){let[n,s]=un(t,e);return ff(r,n,s,w0(o),r.RGBA,r.FLOAT)}function C0(r){return r.internalFormatPackedHalfFloat}function LA(r,t,e,o){let[n,s]=un(t,e);return ff(r,n,s,C0(o),r.RGBA,o.textureTypeHalfFloat)}function PA(r,t,e){return ut(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),f0(r,t,"clipSpacePos",e,3,20,0)&&f0(r,t,"uv",e,2,20,12)}function zA(r,t,e,o,n,s){ut(r,()=>r.bindTexture(r.TEXTURE_2D,t));let i,a,l;n instanceof Uint8Array?(i=new Uint8Array(e*o*4),a=r.UNSIGNED_BYTE,l=r.RGBA):(i=new Float32Array(e*o*4),a=r.FLOAT,l=s.internalFormatPackedFloat),i.set(n),P().getNumber("WEBGL_VERSION")===2?ut(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,o,r.RGBA,a,i)):ut(r,()=>r.texImage2D(r.TEXTURE_2D,0,l,e,o,0,r.RGBA,a,i)),ut(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function MA(r,t,e){ut(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?P().getNumber("WEBGL_VERSION")===2?ut(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,r.RGBA,r.UNSIGNED_BYTE,e.data)):ut(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):P().getNumber("WEBGL_VERSION")===2?ut(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,e)):ut(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),ut(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function BA(r,t,e,o){let n=r.createBuffer();ut(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,n));let a=4*4*t*e;return ut(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),ut(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),ut(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),n}function VA(r,t,e){let o=r,n=new Float32Array(e);return o.bindBuffer(o.PIXEL_PACK_BUFFER,t),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,n),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),n}function GA(r,t,e,o){let[n,s]=il(t,e),i=4,a=new Uint8Array(JE(t*e,i));return ut(r,()=>r.readPixels(0,0,n,s,o.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function WA(r,t,e,o,n,s,i,a){let l=r,u=new Float32Array(QE(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function UA(r,t,e){let o=new Float32Array(t*e*4);return ut(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,o)),o}var vc=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let e=P().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,ZE(e,t)):this.gl=zr(e),t=this.gl,P().getNumber("WEBGL_VERSION")===2){let s=t;this.createVertexArray=()=>ut(s,()=>s.createVertexArray()),this.bindVertexArray=i=>ut(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>ut(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>ut(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(t!=null){let s=t.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ut(t,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>ut(t,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ut(t,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>ut(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let o="WEBGL_color_buffer_float",n="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),P().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=uf(this.gl,s),Yr(this.gl,i))this.textureHalfFloatExtension=uf(this.gl,i);else if(P().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(o),Yr(this.gl,n))this.colorBufferHalfFloatExtension=uf(this.gl,n);else if(P().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(o="EXT_color_buffer_float",Yr(this.gl,o))this.colorBufferFloatExtension=this.gl.getExtension(o);else if(Yr(this.gl,n))this.colorBufferHalfFloatExtension=this.gl.getExtension(n);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=$A(this.gl),this.indexBuffer=DA(this.gl),this.framebuffer=uA(this.gl),this.textureConfig=lf(this.gl,this.textureHalfFloatExtension)}get debug(){return P().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;ut(t,()=>t.finish()),ut(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ut(t,()=>t.deleteFramebuffer(this.framebuffer)),ut(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ut(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ut(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),RA(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),FA(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),_A(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),MA(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,o,n){this.throwIfDisposed(),zA(this.gl,t,e,o,n,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),LA(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),OA(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(h0(this.gl,this.framebuffer),this.outputTexture=null),ut(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,o){return this.downloadMatrixDriver(t,()=>GA(this.gl,e,o,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,o,n,s,i){return WA(this.gl,t,e,o,n,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return VA(this.gl,t,e)}createBufferFromTexture(t,e,o){this.bindTextureToFrameBuffer(t);let n=BA(this.gl,e,o,this.textureConfig);return this.unbindTextureToFrameBuffer(),n}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,o;if(P().getBool("WEBGL_FENCE_API_ENABLED")){let n=t,s=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),o=()=>{let i=n.clientWaitSync(s,0,0);return i===n.ALREADY_SIGNALED||i===n.CONDITION_SATISFIED},e=s}else P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),o=()=>this.isQueryAvailable(e,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):o=()=>!0;return{query:e,isFencePassed:o}}downloadMatrixFromPackedTexture(t,e,o){return this.downloadMatrixDriver(t,()=>UA(this.gl,e,o))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=AA(e));let o=oA(e);ut(e,()=>e.attachShader(o,this.vertexShader)),ut(e,()=>e.attachShader(o,t)),nA(e,o);let n;return n=Object.assign(o,{vao:this.createVertexArray()}),this.bindVertexArray(n.vao),ut(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(PA(e,n,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&lg(e,n),this.setProgram(n),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(ut(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&lg(this.gl,this.program)),ut(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,o=!0){return this.throwIfDisposed(),o?cA(this.gl,t,e):pA(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ut(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,o){this.throwIfDisposed(),this.throwIfNoProgram(),mA(this.gl,t,e,o)}setOutputMatrixTexture(t,e,o){this.setOutputMatrixTextureDriver(t,o,e)}setOutputPackedMatrixTexture(t,e,o){this.throwIfDisposed();let[n,s]=un(e,o);this.setOutputMatrixTextureDriver(t,n,s)}setOutputMatrixWriteRegion(t,e,o,n){this.setOutputMatrixWriteRegionDriver(o,t,n,e)}setOutputPackedMatrixWriteRegion(t,e,o,n){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&lg(this.gl,this.program),cf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ut(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ut(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=uf(this.gl,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let o=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=o.createQuery();return o.beginQuery(n.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,o=this.getQueryTimerExtensionWebGL2();e.endQuery(o.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){return M(this,null,function*(){return yield y.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})}getQueryTime(t,e){if(e===0)return null;if(e===2){let o=this.gl;return o.getQueryParameter(t,o.QUERY_RESULT)/1e6}else{let o=this.getQueryTimerExtensionWebGL1();return o.getQueryObjectEXT(t,o.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let o=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=o.getQueryParameter(t,o.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let o=this.getQueryTimerExtensionWebGL1(),n=o.getQueryObjectEXT(t,o.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=_4(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:o}=this.itemsToPoll[e];o()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let o;"setTimeoutCustom"in P().platform&&(o=P().platform.setTimeoutCustom.bind(P().platform)),y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,o)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),ug(this.gl,t,this.framebuffer),this.debug&&cf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(ug(this.gl,this.outputTexture,this.framebuffer),this.debug&&cf(this.gl)):h0(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let o=e();return this.unbindTextureToFrameBuffer(),o}setOutputMatrixTextureDriver(t,e,o){this.throwIfDisposed();let n=this.gl;ug(n,t,this.framebuffer),this.debug&&cf(n),this.outputTexture=t,ut(n,()=>n.viewport(0,0,e,o)),ut(n,()=>n.scissor(0,0,e,o))}setOutputMatrixWriteRegionDriver(t,e,o,n){this.throwIfDisposed(),ut(this.gl,()=>this.gl.scissor(t,e,o,n))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function _4(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:HA,bincountImpl:yg,bincountReduceImpl:KA,castImpl:qA,ceilImpl:jA,concatImpl:XA,equalImpl:YA,expImpl:ZA,expm1Impl:JA,floorImpl:QA,gatherNdImpl:t$,gatherV2Impl:e$,greaterImpl:r$,greaterEqualImpl:o$,lessImpl:n$,lessEqualImpl:s$,linSpaceImpl:i$,logImpl:a$,maxImpl:l$,maximumImpl:u$,minimumImpl:c$,multiplyImpl:p$,negImpl:m$,notEqualImpl:f$,prodImpl:h$,raggedGatherImpl:d$,raggedRangeImpl:g$,raggedTensorToTensorImpl:x$,rangeImpl:y$,rsqrtImpl:b$,scatterImpl:w$,sigmoidImpl:C$,simpleAbsImpl:bg,sliceImpl:I$,sparseFillEmptyRowsImpl:S$,sparseReshapeImpl:N$,sparseSegmentReductionImpl:wg,sqrtImpl:T$,stridedSliceImpl:v$,stringNGramsImpl:k$,stringSplitImpl:E$,stringToHashBucketFastImpl:A$,subImpl:$$,tileImpl:D$,topKImpl:R$,transposeImpl:cl,uniqueImpl:F$}=Xw;function I0(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function Ce(r,t){return t===1?[r]:I0(r,t)}function _$(r,t){if(r===1)return"rc";let e="";for(let o=0;o<r;o++)e+=t[o],o<r-1&&(e+=",");return e}var Cg=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Xt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=Ce("rc",this.rank),o=Et(this.rank),n=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();

          if(${n}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let o=0;o<=1;o++)for(let n=0;n<=1;n++){let s=`${o===0?"r":"rp1"}, ${n===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let o=this.rank-2;o<this.rank;o++)e+=`${t[o]} >= ${this.enableShapeUniforms?`outShape[${o}]`:this.outputShape[o]}`,o<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),o=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${o};
      bool rEdge = rp1 >= ${n};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var kc=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length);let o="";for(let n=0;n<4;n++){let s="thisRC = rc;";n%2===1&&(s+="thisRC.z += 1;"),n>1&&(s+="thisRC.y += 1;"),o+=`
        ${s}
        ${n>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${n}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${n>0?"}":""}
      `}this.userCode=`
      ${O4(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?wc():bc(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${o}

        setOutput(result);
      }
    `}};function O4(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?wA(["r","c","d"],"inputShape"):Bo(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var Ig=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,o){let n=L$(e,o),s=P$(t,n,o);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=O$(t,n,this.gpgpu.gl,this.gpgpu.textureConfig,o);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let l=this.freeTextures[s].shift();return this.usedTextures[s].push(l),l}let a;return n===je.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):n===je.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):n===je.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):n===je.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):n===je.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,o,n){if(this.freeTextures==null)return;let s=L$(o,n),i=P$(e,s,n);i in this.freeTextures||(this.freeTextures[i]=[]);let a=O$(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,n),l=P().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let u=this.usedTextures[i],c=u.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function L4(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function O$(r,t,e,o,n){let s=P4(t,o),i;if(n){let[l,u]=un(r[0],r[1]);i=l*u}else{let[l,u]=il(r[0],r[1]);i=l*u}let a=L4(e,s);return i*a}function P4(r,t){switch(r){case je.PACKED_2X2_FLOAT32:return w0(t);case je.PACKED_2X2_FLOAT16:return C0(t);case je.UNPACKED_FLOAT32:return x0(t);case je.UNPACKED_FLOAT16:return y0(t);case je.PACKED_4X1_UNSIGNED_BYTE:return b0(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function z4(r){return P().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?je.PACKED_2X2_FLOAT32:je.UNPACKED_FLOAT32:r?je.PACKED_2X2_FLOAT16:je.UNPACKED_FLOAT16}function L$(r,t){if(r===or.UPLOAD)return je.PACKED_2X2_FLOAT32;if(r===or.RENDER||r==null)return z4(t);if(r===or.DOWNLOAD||r===or.PIXELS)return je.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function P$(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var Xe=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},De="if (isnan(x)) return x;",z$="return x;",S0="return abs(x);";var M$="return (x >= 0.0) ? x : (exp(x) - 1.0);",B$=De+`
  return (x < 0.0) ? 0.0 : x;
`,V$=De+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,pn="return x;",G$="return 1.0 / (1.0 + exp(-1.0 * x));";var U$="return x;",H$=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,K$=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,q$=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,j$="return 1.0 / (1.0 + exp(-1.0 * x));",Nr=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Sg=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length);let e=t.length,o=Ce("rc",e),n=Et(e),s=_$(e,o),i=o.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${n} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var B4=tr.whereImpl,V4=1e-7,G4=1e-4,Ng={};function W4(r){return r in Ng||(Ng[r]={}),Ng[r]}var U4=P().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),H4=600;function K4(){return P().global.screen==null?1024:P().global.screen.height*P().global.screen.width*window.devicePixelRatio*H4/1024/1024}var pl=class extends dn{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!P().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof vc)e=t;else{let o=zr(P().getNumber("WEBGL_VERSION"),t);e=new vc(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=zr(P().getNumber("WEBGL_VERSION"));e=new vc(o),this.binaryCache=W4(P().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Ig(this.gpgpu),this.numMBBeforeWarning=K4(),this.texData=new na(this,oo())}nextDataId(){return pl.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,o,n,s,i){let a=this.makeTensorInfo(e,o),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[n,s]},l.texShape=[n,s];let u=pf(e),c=new mf(u,!1,i),p=this.runWebGLProgram(c,[a],o,[[n,s]]);return p.shape=e,l.texture=null,this.disposeIntermediateTensorInfo(a),p.dataId}write(t,e,o){if((P().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||P().getBool("DEBUG"))&&this.checkNumericalProblems(t),o==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let n={id:this.nextDataId()};return this.texData.set(n,{shape:e,dtype:o,values:t,usage:or.UPLOAD,refCount:1}),n}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}move(t,e,o,n,s){if(P().getBool("DEBUG")&&this.checkNumericalProblems(e),n==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:o,dtype:n,values:e,usage:or.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let e=this.texData.get(t),{values:o,dtype:n,complexTensorInfos:s,slice:i,shape:a,isPacked:l}=e;if(i!=null){let m;l?m=new Nr(a,pn):m=new Xe(a,pn);let f=this.runWebGLProgram(m,[{dataId:t,shape:a,dtype:n}],n),h=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),h}if(o!=null)return this.convertAndCacheOnCPU(t);if(n==="string")return o;let u=this.activeTimers!=null,c;u&&(c=y.now());let p;if(n==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);p=S.mergeRealAndImagArrays(m,f)}else p=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=y.now()-c),this.convertAndCacheOnCPU(t,p)}read(t){return M(this,null,function*(){if(this.pendingRead.has(t)){let h=this.pendingRead.get(t);return new Promise(d=>h.push(d))}let e=this.texData.get(t),{values:o,shape:n,slice:s,dtype:i,complexTensorInfos:a,isPacked:l}=e;if(s!=null){let h;l?h=new Nr(n,pn):h=new Xe(n,pn);let d=this.runWebGLProgram(h,[{dataId:t,shape:n,dtype:i}],i),g=this.read(d.dataId);return this.disposeIntermediateTensorInfo(d),g}if(o!=null)return this.convertAndCacheOnCPU(t);if(P().getBool("DEBUG")&&!P().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&P().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&P().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let h=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(h.texture.texture,...af(n))}this.pendingRead.set(t,[]),i!=="complex64"&&(yield this.gpgpu.createAndWaitForFence());let p;if(i==="complex64"){let h=yield Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),d=h[0],g=h[1];p=S.mergeRealAndImagArrays(d,g)}else if(u==null)p=this.getValuesFromTexture(t);else{let h=y.sizeFromShape(n);p=this.gpgpu.downloadFloat32MatrixFromBuffer(u,h)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let h=this.gpgpu.gl;ut(h,()=>h.deleteBuffer(u))}let m=this.convertAndCacheOnCPU(t,p),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(h=>h(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&oo().removeDataId(t,this),this.pendingDeletes--),m})}readToGPU(t,e={}){let o=this.texData.get(t),{values:n,shape:s,slice:i,dtype:a,isPacked:l,texture:u}=o;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let f;l?f=new Nr(s,pn):f=new Xe(s,pn);let h=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:a}],a),d=this.readToGPU(h,e);return this.disposeIntermediateTensorInfo(h),d}if(u==null)throw n!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,e.customTexShape),p=oo().makeTensorFromTensorInfo(c),m=this.texData.get(c.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){let e=this.readSync(t.dataId);if(t.dtype==="string")try{let o=e.map(n=>y.decodeString(n));return ft(t.shape,t.dtype,o)}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return ft(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){let o=t[e];if(!tA(o))throw P().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:o,isPacked:n}=this.texData.get(t),s=y.sizeFromShape(e);if(P().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),f=this.texData.get(m.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...af(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),h}let i=P().getBool("WEBGL_PACK")&&n===!0,a=i?pf(e):e,l=i?new gg(a):new dg(a),u=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:t}],"float32"),c=this.texData.get(u.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),p}timerAvailable(){return P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let e=this.activeTimers,o=[],n=!1;this.programTimersStack==null?(this.programTimersStack=o,n=!0):this.activeTimers.push(o),this.activeTimers=o,t();let s=y.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=y.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=e,n&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(()=>M(this,null,function*(){if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=yield Promise.all(s);a.kernelMs=y.sum(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}))()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(t){return P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=y.now(),t)}getQueryTime(t){return M(this,null,function*(){if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs})}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:o}=this.texData.get(t);return o!=null&&(this.disposeData(o.real.dataId,e),this.disposeData(o.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:e,dtype:o,texShape:n,usage:s,isPacked:i,slice:a}=this.texData.get(t),l=a&&a.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),e!=null&&(this.numBytesInGPU-=this.computeBytes(n,o),this.textureManager.releaseTexture(e,n,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=U4){return P().getBool("WEBGL_CPU_FORWARD")&&t.every(o=>this.texData.get(o.dataId).texture==null&&y.sizeFromShape(o.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return B4(t.shape,e)}packedUnaryOp(t,e,o){let n=new Nr(t.shape,e),s=this.compileAndRun(n,[t],o);return oo().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let n=bg(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,n)}if(P().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,S0,t.dtype);let e=new Xe(t.shape,S0),o=this.compileAndRun(e,[t]);return oo().makeTensorFromTensorInfo(o)}makeTensorInfo(t,e,o){let n;if(e==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let s=o.map(i=>y.encodeString(i));n=this.write(s,t,e)}else n=this.write(o,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}}makeOutput(t,e,o){return oo().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,o),this)}unpackTensor(t){let e=new Sg(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new Cg(t.shape),o=!0;return this.runWebGLProgram(e,[t],t.dtype,null,o)}packedReshape(t,e){let o=[Qi(t.shape),...ta(t.shape)],n={dtype:t.dtype,shape:o,dataId:t.dataId},s=[Qi(e),...ta(e)],i=new kc(s,o),a=!0,l=[o],u=this.runWebGLProgram(i,[n],t.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}decode(t,e){let o=this.texData.get(t),{isPacked:n,shape:s,dtype:i}=o;if(e!=null){let m=y.sizeFromShape(s),f=e[0]*e[1]*4;y.assert(m<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let a=pf(s),l;n?l=new hg(a):l=new fg(a);let u=!0,c=[e!=null?e:af(a)],p=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:t}],i,c,u,e);return{dtype:i,shape:s,dataId:p.dataId}}runWebGLProgram(t,e,o,n,s=!1,i){let a=this.makeTensorInfo(t.outputShape,o),l=this.texData.get(a.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Ji.DENSE){let x=i!=null?i:af(t.outputShape);l.texShape=x.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),y.sizeFromShape(a.shape)===0)return l.values=y.getTypedArrayFromDType(a.dtype,0),a;let u=[],c=e.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(x.dataId);if(b.texture==null){if(!t.packedInputs&&y.sizeFromShape(x.shape)<=P().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!b.isPacked!=!!t.packedInputs)x=b.isPacked?this.unpackTensor(x):this.packTensor(x),u.push(x),b=this.texData.get(x.dataId);else if(b.isPacked&&!al(b.shape,x.shape)){let C=x,w=x.shape;x.shape=b.shape,x=this.packedReshape(x,w),u.push(x),b=this.texData.get(x.dataId),C.shape=w}return{shape:x.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);let p={shape:a.shape,texData:l,isUniform:!1},m=EA(t,c,p),f=this.getAndSaveBinary(m,()=>vA(this.gpgpu,t,c,p)),h=this.activeTimers!=null,d;h&&(d=this.startTimer()),P().get("ENGINE_COMPILE_ONLY")||kA(this.gpgpu,f,c,p,n),u.forEach(x=>this.disposeIntermediateTensorInfo(x)),h&&(d=this.endTimer(d),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(d)}));let g=P().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let x=y.now();x-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!P().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let x=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),x}return a}compileAndRun(t,e,o,n,s=!1){return o=o||e[0].dtype,this.runWebGLProgram(t,e,o,n,s)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(P().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=z(()=>{if(!P().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=P().getBool("DEBUG");P().set("DEBUG",!1);let e=this.abs(xt(1e-8)).dataSync()[0];if(P().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?V4:G4}uploadToGPU(t){let e=this.texData.get(t),{shape:o,dtype:n,values:s,texture:i,usage:a,isPacked:l}=e;if(i!=null)return;let u=this.activeTimers!=null,c;u&&(c=y.now());let p=e.texShape;if(p==null&&(p=fA(o,l),e.texShape=p),s!=null){let m=pf(o),f,h=p[1],d=p[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([h,d]=un(p[0],p[1])),l?f=new xg(m,g):f=new mf(m,g);let x=g?[d,h]:p,b=this.makeTensorInfo(x,n),C=this.texData.get(b.dataId);g?C.usage=or.PIXELS:C.usage=or.UPLOAD,C.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),h,d,s);let w=[[d,h]],I=!0,E=this.runWebGLProgram(f,[b],n,w,I),A=this.texData.get(E.dataId);e.texShape=A.texShape,e.isPacked=A.isPacked,e.usage=A.usage,P().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(e.texture=A.texture,e.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=y.now()-c)}else{let m=this.acquireTexture(p,a,n,l);e.texture=m}}convertAndCacheOnCPU(t,e){let o=this.texData.get(t),{dtype:n}=o;return e!=null&&(o.values=q4(e,n)),o.values}acquireTexture(t,e,o,n){if(this.numBytesInGPU+=this.computeBytes(t,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,n)}computeBytes(t,e){return t[0]*t[1]*y.bytesPerElement(e)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}checkCompileCompletionAsync(){return M(this,null,function*(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(let[,e]of Object.entries(this.binaryCache)){let o=new Promise(n=>{try{this.checkCompletion_(e),n(!0)}catch(s){throw s}});t.push(o)}return Promise.all(t)}})}checkCompletionAsync_(t){return M(this,null,function*(){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(yield Sp(),this.checkCompletionAsync_(t))})}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(m0(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,t]of Object.entries(this.binaryCache)){let{uniformLocations:e,customUniformLocations:o,infLoc:n,nanLoc:s,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:l,outShapeStridesLocation:u,outTexShapeLocation:c}=g0(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=o,t.infLoc=n,t.nanLoc=s,t.inShapesLocations=i,t.inTexShapesLocations=a,t.outShapeLocation=l,t.outShapeStridesLocation=u,t.outTexShapeLocation=c}}createTensorFromGPUData(t,e,o){t.channels=t.channels||"RGBA";let{texture:n,height:s,width:i,channels:a}=t,l=oo().backend;if(!l.gpgpu.gl.isTexture(n))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(n,e,o,s,i,a);return oo().makeTensorFromDataId(u,e,o,l)}};pl.nextDataId=0;function q4(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let o=0;o<e.length;++o)e[o]=Math.round(r[o]);return e}else throw new Error(`Unknown dtype ${t}`)}_i.isBrowser()&&nh("webgl",()=>new pl,2);var Ec=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Zr=class{constructor(t,e,o){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(e,o),this.enableShapeUniforms=Xt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var mn=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var So=class{constructor(t,e,o,n=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(e,o);let s=this.outputShape.length;this.enableShapeUniforms=Xt(s);let i="";if(n)if(s===0||y.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Et(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=Ce("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Ie(r){let{inputs:t,backend:e}=r,{x:o}=t;return e.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}var X$={kernelName:Ho,backendName:"webgl",kernelFunc:Ie};function Tr(r){let{inputs:t,backend:e}=r,{real:o,imag:n}=t,s=e.makeTensorInfo(o.shape,"complex64"),i=e.texData.get(s.dataId),a=Ie({inputs:{x:o},backend:e}),l=Ie({inputs:{x:n},backend:e});return i.complexTensorInfos={real:a,imag:l},s}var Y$={kernelName:$l,backendName:"webgl",kernelFunc:Tr};var N0="return (a < 0.) ? b * a : a;",T0=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function j4(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{alpha:s}=o,i=e.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),a=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new So(T0,n.shape,i.shape):new Zr(N0,n.shape,i.shape),l=e.runWebGLProgram(a,[n,i],"float32");return e.disposeIntermediateTensorInfo(i),l}var Z$={kernelName:oi,backendName:"webgl",kernelFunc:j4};var v0="return (a < 0.) ? b * a : a;",k0=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function X4(r){let{inputs:t,backend:e}=r,{x:o,alpha:n}=t,s=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new So(k0,o.shape,n.shape):new Zr(v0,o.shape,n.shape);return e.runWebGLProgram(s,[o,n],"float32")}var J$={kernelName:gi,backendName:"webgl",kernelFunc:X4};var No="if (isnan(x)) return x;";function mt({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:o}){return({inputs:n,backend:s})=>{let{x:i}=n,a=s,l=o||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),m=e(p.values,l);return a.makeTensorInfo(i.shape,l,m)}let u=P().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new Nr(i.shape,t):c=new Xe(i.shape,r),a.runWebGLProgram(c,[i],l)}}function Vt({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:o=!1,cpuKernelImpl:n,dtype:s}){return({inputs:i,backend:a})=>{let{a:l,b:u}=i,c=a;if(o&&l.dtype==="complex64"){let h=c.texData.get(l.dataId),d=c.texData.get(u.dataId),[g,x]=[[h.complexTensorInfos.real,d.complexTensorInfos.real],[h.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(C=>{let[w,I]=C,E={dataId:w.dataId,dtype:w.dtype,shape:l.shape},A={dataId:I.dataId,dtype:I.dtype,shape:u.shape},$=new Zr(r,l.shape,u.shape);return c.runWebGLProgram($,[E,A],Te(w.dtype,I.dtype))}),b=Tr({inputs:{real:g,imag:x},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(x),b}let p=s||Te(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&n!=null){let h=c.texData.get(l.dataId).values,d=c.texData.get(u.dataId).values,g=l.dtype==="string"?S.fromUint8ToStringArray(h):h,x=l.dtype==="string"?S.fromUint8ToStringArray(d):d,[b,C]=n(l.shape,u.shape,g,x,p),w=c.makeTensorInfo(C,p),I=c.texData.get(w.dataId);return I.values=b,w}let m=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return m?f=new So(t,l.shape,u.shape,e):f=new Zr(r,l.shape,u.shape),c.runWebGLProgram(f,[l,u],p)}}function Ds(r,t=!1){if(r==="linear")return t?U$:z$;if(r==="relu")return t?K$:B$;if(r==="elu")return t?H$:M$;if(r==="relu6")return t?q$:V$;if(r==="prelu")return t?k0:v0;if(r==="leakyrelu")return t?T0:N0;if(r==="sigmoid")return t?j$:G$;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var Ac=class{constructor(t,e,o,n=!1,s=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o,this.enableShapeUniforms=Xt(this.outputShape.length);let c=n?t[1]:t[2],p=Math.ceil(c/2),m=n?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",h=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],d=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";a&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");let b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let C="rc.x",w="rc.x";t[0]<e[0]?C=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(w=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${C};
        int batchB = ${w};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${d[0]});
          result += (${h[1]} * ${d[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${x}

        setOutput(result);
      }
    `}};var E0={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},hf=class{constructor(t,e,o){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(e,o),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var Q$="return a * b;";function df(r){let{inputs:t,backend:e}=r,{a:o,b:n}=t,s=S.upcastType(o.dtype,n.dtype);if(o.dtype==="complex64"){let a=e.texData.get(o.dataId),l=e.texData.get(n.dataId),u=new hf(E0.REAL,o.shape,n.shape),c=new hf(E0.IMAG,o.shape,n.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:o.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:n.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:n.shape}],m=e.runWebGLProgram(u,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),h=Tr({inputs:{real:m,imag:f},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),h}if(e.shouldExecuteOnCPU([o,n])){let a=e.texData.get(o.dataId),l=e.texData.get(n.dataId),[u,c]=p$(o.shape,n.shape,a.values,l.values,s),p=e.makeTensorInfo(c,s),m=e.texData.get(p.dataId);return m.values=u,p}let i;return P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new So(Q$,o.shape,n.shape):i=new Zr(Q$,o.shape,n.shape),e.runWebGLProgram(i,[o,n],s)}var t2={kernelName:Un,backendName:"webgl",kernelFunc:df};function e2(r,t,e){let o=[Qi(r.shape),...ta(r.shape)],n={dtype:r.dtype,shape:o,dataId:r.dataId},s=[Qi(t),...ta(t)],i=new kc(s,o),a=!0,l=[o],u=e.runWebGLProgram(i,[n],r.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function Q(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{shape:s}=o,i=e,a=y.sizeFromShape(n.shape),l=y.inferFromImplicitShape(s,a),u=y.sizeFromShape(l);y.assert(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${n.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(n.dataId);return c.isPacked&&!al(n.shape,l)&&!(c.texture!==null&&al(c.shape,l))?e2(n,l,i):(i.incRef(n.dataId),{dataId:n.dataId,shape:l,dtype:n.dtype})}var r2={kernelName:yi,backendName:"webgl",kernelFunc:Q};var gf=class{constructor(t,e){this.variableNames=["x"];let{windowSize:o,batchSize:n,inSize:s,outSize:i}=t;this.outputShape=[n,i];let a=Math.floor(o/4)*4,l=o%4,u="sumValue += dot(values, ones);";if(e!=null){let p=1/e;u=`sumValue += dot(values * ${y.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%o>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var Tg=class{constructor(t,e){this.variableNames=["x"];let{windowSize:o,batchSize:n,inSize:s,outSize:i}=t;this.outputShape=[n,i];let a="0.0",l="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",l="min"):e==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?u="sumValue":e==="prod"?u="prodValue":e==="all"?u="allValue":e==="any"&&(u="anyValue");let c=Math.floor(o/4)*4,p=o%4,m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";e==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):e==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let h="";s%o>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${u});
      }
    `}};function Z4(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],o=S.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:o,outSize:Math.ceil(e/o)})}return t}function Mr(r,t,e,o){let n=Z4(r.shape),s=r;for(let i=0;i<n.length;i++){let{inSize:a,windowSize:l,outSize:u}=n[i],c,p;e==="mean"?c=i===0?new gf({windowSize:l,inSize:a,batchSize:r.shape[0],outSize:u},a):new gf({windowSize:l,inSize:a,batchSize:r.shape[0],outSize:u}):c=new Tg({windowSize:l,inSize:a,batchSize:r.shape[0],outSize:u},e),p=s,s=o.runWebGLProgram(c,[s],t),p.dataId!==r.dataId&&o.disposeIntermediateTensorInfo(p)}return s}var vg=class{constructor(t,e){this.variableNames=["A"];let o=new Array(t.length);for(let i=0;i<o.length;i++)o[i]=t[e[i]];this.outputShape=o,this.rank=o.length;let n=Et(this.rank),s=J4(e);this.userCode=`
    void main() {
      ${n} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function J4(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],o=new Array(t);for(let n=0;n<r.length;n++)o[r[n]]=e[n];return o.join()}var kg=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let o=new Array(t.length);for(let c=0;c<o.length;c++)o[c]=t[e[c]];if(this.outputShape=o,this.rank=o.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let n=Et(this.rank),s=I0("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${o[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${n} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${o[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function ea(r,t,e){let o=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kg(r.shape,t):new vg(r.shape,t);return e.runWebGLProgram(o,[r],r.dtype)}function o2(r,t,e,o){let n=t,s=r.shape.length,i=y.parseAxisParam(n,r.shape),a=i,l=S.getAxesPermutation(a,s),u=l!=null,c=r;u&&(c=ea(r,l,o),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,m]=S.computeOutAndReduceShapes(c.shape,a),f=p;e&&(f=S.expandShapeToKeepDim(p,i));let h=y.sizeFromShape(m),g=y.sizeFromShape(r.shape)/h,x=Q({inputs:{x:c},attrs:{shape:[g,h]},backend:o}),b=Na(r.dtype),C=Mr(x,b,"sum",o),w=Q({inputs:{x:C},attrs:{shape:f},backend:o});return o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(C),u&&o.disposeIntermediateTensorInfo(c),w}function ml(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o;return o2(n,s,i,e)}var n2={kernelName:Ni,backendName:"webgl",kernelFunc:ml};function ae(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{perm:s}=o,i=e,a=n.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=n.shape[s[c]];let u;if(i.shouldExecuteOnCPU([n])){let p=i.texData.get(n.dataId).values,m=cl(p,n.shape,n.dtype,s,l);u=i.makeTensorInfo(l,n.dtype);let f=i.texData.get(u.dataId);f.values=m}else u=ea(n,s,i);return u}var s2={kernelName:qo,backendName:"webgl",kernelFunc:ae};var A0=1e3;function fl({a:r,b:t,transposeA:e,transposeB:o,backend:n,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){let u=r.shape.length,c=t.shape.length,p=e?r.shape[u-2]:r.shape[u-1],m=o?t.shape[c-1]:t.shape[c-2],f=e?r.shape[u-1]:r.shape[u-2],h=o?t.shape[c-2]:t.shape[c-1],d=r.shape.slice(0,-2),g=t.shape.slice(0,-2),x=y.sizeFromShape(d),b=y.sizeFromShape(g),w=Rr.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,h]);y.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${o} must match.`);let I=e?[x,p,f]:[x,f,p],E=o?[b,h,m]:[b,m,h],A=Q({inputs:{x:r},backend:n,attrs:{shape:I}}),$=Q({inputs:{x:t},backend:n,attrs:{shape:E}}),_=[A,$],L=Math.max(x,b),B=e?A.shape[1]:A.shape[2],V=s!=null,G=i!=null,U=l==="leakyrelu",W=l!=null?Ds(l,!0):null,q=V||G||U||W!=null,Z;if((f===1||h===1)&&B>A0&&q===!1){let J=A,tt=$;e&&(J=ae({inputs:{x:A},backend:n,attrs:{perm:[0,2,1]}}),_.push(J)),o&&(tt=ae({inputs:{x:$},backend:n,attrs:{perm:[0,2,1]}}),_.push(tt));let et=h!==1,nt=h===1,rt=J;et&&(rt=Q({inputs:{x:J},backend:n,attrs:{shape:[L,B,1]}}),_.push(rt));let lt=h===1?2:1,st=tt;nt&&(st=Q({inputs:{x:tt},backend:n,attrs:{shape:[L,1,B]}}),_.push(st));let pt=df({inputs:{a:rt,b:st},backend:n});Z=ml({inputs:{x:pt},backend:n,attrs:{axis:lt,keepDims:!0}}),_.push(pt)}else{let J=Te(r.dtype,t.dtype),tt=new Ac(I,E,[L,f,h],e,o,V,W,G,U),et=[A,$];if(s!=null&&et.push(s),G&&et.push(i),U){let nt=n.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));et.push(nt),_.push(nt)}Z=n.runWebGLProgram(tt,et,J)}let K=Q({inputs:{x:Z},backend:n,attrs:{shape:w}});_.push(Z);for(let J of _)n.disposeIntermediateTensorInfo(J);return K}function Q4(r){let{inputs:t,backend:e,attrs:o}=r,{a:n,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=o;return fl({a:n,b:s,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var i2={kernelName:ga,backendName:"webgl",kernelFunc:Q4};var a2="return abs(x);";function tH(r){let{inputs:t,backend:e}=r,{x:o}=t;if(e.shouldExecuteOnCPU([o])&&o.dtype!=="complex64"){let s=e.texData.get(o.dataId),i=bg(s.values);return e.makeTensorInfo(o.shape,o.dtype,i)}let n;return P().getBool("WEBGL_PACK_UNARY_OPERATIONS")?n=new Nr(o.shape,a2):n=new Xe(o.shape,a2),e.runWebGLProgram(n,[o],o.dtype)}var l2={kernelName:Ms,backendName:"webgl",kernelFunc:tH};var eH=De+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,rH=mt({opSnippet:eH}),u2={kernelName:xn,backendName:"webgl",kernelFunc:rH};var oH=De+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,nH=mt({opSnippet:oH}),c2={kernelName:yn,backendName:"webgl",kernelFunc:nH};var p2="return a + b;",sH=Vt({opSnippet:p2,packedOpSnippet:p2,supportsComplex:!0,cpuKernelImpl:HA}),m2={kernelName:vo,backendName:"webgl",kernelFunc:sH};var Eg=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let o=[];this.variableNames.forEach(s=>{o.push(`float v${s} = get${s}AtOutCoords();`)});let n=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${o.join(`
        `)}

        float result = ${n};
        setOutput(result);
      }
    `}};var Ag=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let o=[];this.variableNames.forEach(s=>{o.push(`vec4 v${s} = get${s}AtOutCoords();`)});let n=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${o.join(`
        `)}

        vec4 result = ${n};
        setOutput(result);
      }
    `}};function $g(r){let{inputs:t,backend:e}=r,o=t;if(o.length===1)return Ie({inputs:{x:o[0]},backend:e});if(o.length>P().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(o.length/2),u=$g({inputs:o.slice(0,l),backend:e}),c=$g({inputs:o.slice(l),backend:e});return $g({inputs:[u,c],backend:e})}let n=o.map(l=>l.dtype).reduce((l,u)=>Te(l,u)),s=o.map(l=>l.shape),a=P().getBool("WEBGL_PACK")?new Ag(o[0].shape,s):new Eg(o[0].shape,s);return e.runWebGLProgram(a,o,n)}var f2={kernelName:Nl,backendName:"webgl",kernelFunc:$g};function iH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o,a=n.shape.length,l=y.parseAxisParam(s,n.shape),u=l,c=S.getAxesPermutation(u,a),p=n;c!=null&&(p=ae({inputs:{x:n},backend:e,attrs:{perm:c}}),u=S.getInnerMostAxes(u.length,a)),S.assertAxesAreInnerMostDims("all",u,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,u),h=y.sizeFromShape(f),d=Q({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),g=Mr(d,d.dtype,"all",e),x;if(i){let b=S.expandShapeToKeepDim(m,l);x=Q({inputs:{x:g},backend:e,attrs:{shape:b}})}else x=Q({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),x}var h2={kernelName:Tl,backendName:"webgl",kernelFunc:iH};function aH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o,a=n.shape.length,l=y.parseAxisParam(s,n.shape),u=l,c=S.getAxesPermutation(u,a),p=n;c!=null&&(p=ae({inputs:{x:n},backend:e,attrs:{perm:c}}),u=S.getInnerMostAxes(u.length,a)),S.assertAxesAreInnerMostDims("any",u,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,u),h=y.sizeFromShape(f),d=Q({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),g=Mr(d,d.dtype,"any",e),x;if(i){let b=S.expandShapeToKeepDim(m,l);x=Q({inputs:{x:g},backend:e,attrs:{shape:b}})}else x=Q({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),x}var d2={kernelName:vl,backendName:"webgl",kernelFunc:aH};var Dg=class{constructor(t,e,o){this.variableNames=["A"];let{windowSize:n,batchSize:s,outSize:i}=t;o||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",l=o?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${n}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var Rg=class{constructor(t,e,o,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y.assert(t.length>2,()=>`Packed arg${o.charAt(0).toUpperCase()+o.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),n||this.variableNames.push("bestIndicesA");let a=this.outputShape,l=a.length,u=Et(l),c=Ce("coords",l),p,m;if(i===1){m=l+1;let $=Et(m);p=`
        ${$} sourceLocR = ${$}(${c.join()}, 0);
        ++${c[l-1]};
        ${$} sourceLocG = ${$}(${c.join()}, 0);
        ++${c[l-2]};
        ${$} sourceLocA = ${$}(${c.join()}, 0);
        --${c[l-1]};
        ${$} sourceLocB = ${$}(${c.join()}, 0);
        --${c[l-2]};`}else m=l,p=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),h="."+f[m-1],d=f.map($=>"int "+$),g=Ce("sourceLocR",m-1).concat("inIdx.r"),x=Ce("sourceLocG",m-1).concat("inIdx.g"),b=Ce("sourceLocB",m-1).concat("inIdx.b"),C=Ce("sourceLocA",m-1).concat("inIdx.a"),w=o==="max"?"greaterThan":"lessThan",I=n?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${C.join()})));`,E=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,A=n?"":`
      float getBestIndicesAChannel(${d.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${d.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${A}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function g2(r,t,e,o=null){let n=t.shape[0],s=t.shape[1];o!=null&&(n=o.shape[0],s=o.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:n,outSize:Math.ceil(s/i)},l=new Dg(a,e,o==null),u=[t];o!=null&&u.push(o);let c=r.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let p=g2(r,t,e,c);return r.disposeIntermediateTensorInfo(c),p}function x2(r,t,e,o=null){let n=o!=null?o.shape:t.shape,s=n[n.length-1],i=S.computeOptimalWindowSize(s),a=new Rg(n,i,e,o==null),l=o==null?[t]:[t,o],u=r.runWebGLProgram(a,l,"int32");if(u.shape.length===t.shape.length){let c=x2(r,t,e,u);return r.disposeIntermediateTensorInfo(u),c}return u}function Fg(r,t,e,o){let n=[e];if(S.assertAxesAreInnerMostDims("arg"+o.charAt(0).toUpperCase()+o.slice(1),n,t.shape.length),!P().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=r.texData.get(t.dataId),a=i!==null&&i.isPacked,l=t;a&&(l=r.unpackTensor(t),s.push(l));let[u,c]=S.computeOutAndReduceShapes(l.shape,n),p=y.sizeFromShape(c),m=Q({inputs:{x:l},backend:r,attrs:{shape:[-1,p]}});s.push(m);let f=g2(r,m,o);s.push(f);let h=Q({inputs:{x:f},backend:r,attrs:{shape:u}});return s.forEach(d=>r.disposeIntermediateTensorInfo(d)),h}return x2(r,t,o)}function lH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s}=o,i=y.parseAxisParam(s,n.shape),a=S.getAxesPermutation(i,n.shape.length),l=n,u=[];a!=null&&(l=ae({inputs:{x:n},backend:e,attrs:{perm:a}}),u.push(l),i=S.getInnerMostAxes(i.length,l.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=Fg(e,l,i[0],"max");return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var y2={kernelName:Bs,backendName:"webgl",kernelFunc:lH};function uH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s}=o,i=y.parseAxisParam(s,n.shape),a=S.getAxesPermutation(i,n.shape.length),l=n,u=[];a!=null&&(l=ae({inputs:{x:n},backend:e,attrs:{perm:a}}),u.push(l),i=S.getInnerMostAxes(i.length,l.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=Fg(e,l,i[0],"min");return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var b2={kernelName:Vs,backendName:"webgl",kernelFunc:uH};var cH=De+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,pH=mt({opSnippet:cH}),w2={kernelName:bn,backendName:"webgl",kernelFunc:pH};var mH=De+"return log(x + sqrt(x * x + 1.0));",fH=mt({opSnippet:mH}),C2={kernelName:wn,backendName:"webgl",kernelFunc:fH};var hH=De+`
  return atan(x);
`,dH=mt({opSnippet:hH}),I2={kernelName:Cn,backendName:"webgl",kernelFunc:dH};var gH=Ec+`
  return atan(a, b);
`,xH=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+mn+`
  return result;
`,yH=Vt({opSnippet:gH,packedOpSnippet:xH}),S2={kernelName:Sn,backendName:"webgl",kernelFunc:yH};var bH=De+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,wH=mt({opSnippet:bH}),N2={kernelName:In,backendName:"webgl",kernelFunc:wH};var Vo=class{constructor(t,e,o,n=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&o)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,f=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;let d=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,x=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,b="0.0";if(d||(b="-1.0 / 1e-20"),o){let $=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${f}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${$} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${n?s?g:x:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let C="max",w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(w="avgValue / max(count, 1.0)");let I=Math.floor(i/4)*4,E=i%4,A=`
      if (${d}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${f}, ${h});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${A}
          }

          int xC = xCCorner + ${I};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${A}
          }
        }
        setOutput(${w});
      }
    `}},ra=class{constructor(t,e,o,n=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&o)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,f=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,g=t.padInfo.front,x=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;let C=e==="avg",w="0.0";if(C||(w="-1.0 / 1e-20"),o){let L=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${x}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${d};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${L} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${n?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${h} * ${d} +
                      wR * ${d} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let I="max",E=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(E="avgValue / max(count, 1.0)");let A=Math.floor(i/4)*4,$=i%4,_=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${x}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${A}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${_}
            }

            int xC = xCCorner + ${A};
            if (${$===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${_}
            } else if (${$===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${_}
            } else if (${$===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${_}
            }
          }
        }
        setOutput(${E});
      }
    `}};function CH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t;cn(n,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=o,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=S.computePool2DInfo(n.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))return Ie({inputs:{x:n},backend:e});let p=new Vo(c,"avg",!1);return e.runWebGLProgram(p,[n],"float32")}var T2={kernelName:Gs,backendName:"webgl",kernelFunc:CH};function IH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=o,c=[1,1,1],p=S.computePool3DInfo(n.shape,s,i,c,a,l,u),m=new ra(p,"avg",!1);return e.runWebGLProgram(m,[n],"float32")}var v2={kernelName:Ws,backendName:"webgl",kernelFunc:IH};var _g=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,o=t.filterWidth,n=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,p=u-1-t.padInfo.left,m=1/(e*o);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Og=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,o=t.filterHeight,n=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,f=t.effectiveFilterWidth,h=p-1-t.padInfo.front,d=m-1-t.padInfo.top,g=f-1-t.padInfo.left,x=1/(e*o*n);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function SH(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s}=t,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=o,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,l,p,u,c),f=new Og(m);return e.runWebGLProgram(f,[n],i.dtype)}var k2={kernelName:El,backendName:"webgl",kernelFunc:SH};function NH(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s}=t,i=s;cn([n,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=o,c=S.computePool2DInfo(i.shape,a,l,1,u),p=new _g(c);return e.runWebGLProgram(p,[n],i.dtype)}var E2={kernelName:kl,backendName:"webgl",kernelFunc:NH};function TH(r){let{inputs:t,backend:e,attrs:o}=r,{a:n,b:s}=t,{transposeA:i,transposeB:a}=o;return fl({a:n,b:s,transposeA:i,transposeB:a,backend:e})}var A2={kernelName:Us,backendName:"webgl",kernelFunc:TH};var Lg=class{constructor(t,e,o,n,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,o);let a="0.0";n!=null&&(S.assertAndGetBroadcastShape(t,n),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var Pg=class{constructor(t,e,o,n,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,o);let a="vec4(0.0)";n!=null&&(S.assertAndGetBroadcastShape(t,n),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var vH=({inputs:r,backend:t,attrs:e})=>{let{x:o,mean:n,variance:s,offset:i,scale:a}=r;y.assert(n.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||n.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(a==null||n.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);let u=[o,n,s],c=null;i!=null&&(c=i.shape,u.push(i));let p=null;a!=null&&(p=a.shape,u.push(a));let m=P().getBool("WEBGL_PACK_NORMALIZATION")?new Pg(o.shape,n.shape,s.shape,c,p,l):new Lg(o.shape,n.shape,s.shape,c,p,l);return t.runWebGLProgram(m,u,u[0].dtype)},$2={kernelName:ei,backendName:"webgl",kernelFunc:vH};var zg=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=Et(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let o=kH(this.rank),n,s=t.map((i,a)=>`sourceLoc.${$0[a]} = start[${a}] + coords.${$0[a]};`);n=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${n}
        setOutput(getSource(${o}));
      }
    `}},$0=["x","y","z","w","u","v"];function kH(r){if(r===1)return"sourceLoc";if(r<=6)return $0.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var Mg=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=Et(this.rank),o=Ce("coords",this.rank),n=Ce("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${n.slice(-2).join()})`,i=`getChannel(getSource(${n.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${o[this.rank-1]} < ${t[this.rank-1]}) {
        ++${n[this.rank-1]};
        result.y = ${i};
        --${n[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${o[this.rank-1]};
      if (++${o[this.rank-2]} < ${t[this.rank-2]}) {
        ++${n[this.rank-2]};
        result.z = ${i};
        if (++${o[this.rank-1]} < ${t[this.rank-1]}) {
          ++${n[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${n[p]} = ${o[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}};function EH(r,t,e,o){let n=o.texData.get(r.dataId),s=o.makeTensorInfo(e,r.dtype),i=o.texData.get(s.dataId);Object.assign(i,n),i.refCount=1,i.shape=e,i.dtype=r.dtype;let a=Pe.computeFlatOffset(t,y.computeStrides(r.shape));n.slice&&(a+=n.slice.flatOffset),i.slice={flatOffset:a,origDataId:n.slice&&n.slice.origDataId||r.dataId};let l=o.dataRefCount.get(i.slice.origDataId)||1;return o.dataRefCount.set(i.slice.origDataId,l+1),s}function Go(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{begin:s,size:i}=o,[a,l]=Pe.parseSliceParams(n,s,i);if(Pe.assertParamsValid(n,a,l),y.sizeFromShape(l)===0)return e.makeTensorInfo(l,n.dtype,[]);if(e.shouldExecuteOnCPU([n])||n.dtype==="string"){let p=e.texData.get(n.dataId),m=I$(p.values,a,l,n.shape,n.dtype);return e.makeTensorInfo(l,n.dtype,m)}let{isPacked:u}=e.texData.get(n.dataId),c=Pe.isSliceContinous(n.shape,a,l);if(u||!c){let p=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mg(l):new zg(l),m=[a];return e.runWebGLProgram(p,[n],n.dtype,m)}return e.uploadToGPU(n.dataId),EH(n,a,l,e)}var D2={kernelName:Si,backendName:"webgl",kernelFunc:Go};var AH=r=>{let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{blockShape:s,crops:i}=o;y.assert(n.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((b,C)=>b*C),l=S.getReshaped(n.shape,s,a),u=S.getPermuted(l.length,s.length),c=S.getReshapedPermuted(n.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=[],h=Q({inputs:{x:n},backend:e,attrs:{shape:l}}),d=ae({inputs:{x:h},backend:e,attrs:{perm:u}}),g=Q({inputs:{x:d},backend:e,attrs:{shape:c}}),x=Go({inputs:{x:g},backend:e,attrs:{begin:p,size:m}});return f.push(h),f.push(d),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),x},R2={kernelName:Hs,backendName:"webgl",kernelFunc:AH};function $H(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,weights:s}=t,{size:i}=o,a=e.readSync(n.dataId),l=e.readSync(s.dataId),u=yg(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}var F2={kernelName:Al,backendName:"webgl",kernelFunc:$H};function DH(r){let{inputs:t,backend:e}=r,{s0:o,s1:n}=t,s=e.readSync(o.dataId),i=e.readSync(n.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var _2={kernelName:Sf,backendName:"webgl",kernelFunc:DH};var RH="return float(a != b);",D0=Vt({opSnippet:RH,cpuKernelImpl:f$,dtype:"bool"}),O2={kernelName:da,backendName:"webgl",kernelFunc:D0};function Rs(r){let{inputs:t,backend:e}=r,{input:o}=t,n=e.texData.get(o.dataId);return Ie({inputs:{x:n.complexTensorInfos.real},backend:e})}var L2={kernelName:Ql,backendName:"webgl",kernelFunc:Rs};var FH="return float(int(x));";function P2(r,t){let e=new Xe(r.shape,FH),o=t.runWebGLProgram(e,[r],"int32");return{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}function R0(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{dtype:s}=o;if(s==="complex64"){if(n.dtype==="complex64")return Ie({inputs:{x:n},backend:e});let i=re(n.shape),a=R0({inputs:{x:n},backend:e,attrs:{dtype:"float32"}}),l=Tr({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if(n.dtype==="complex64"){let i=Rs({inputs:{input:n},backend:e}),a=R0({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!y.hasEncodingLoss(n.dtype,s)){let i=Ie({inputs:{x:n},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(e.shouldExecuteOnCPU([n])){let i=e.texData.get(n.dataId).values,[a,l,u]=qA(i,n.shape,n.dtype,s);return e.makeTensorInfo(a,l,u)}if(s==="int32")return P2(n,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),l=D0({inputs:{a:n,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${n.dtype} to ${s}`)}var z2={kernelName:Uo,backendName:"webgl",kernelFunc:R0};var M2="return ceil(x);",_H=mt({opSnippet:M2,packedOpSnippet:M2,cpuKernelImpl:jA}),B2={kernelName:Nn,backendName:"webgl",kernelFunc:_H};var Bg=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Vg=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function OH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{clipValueMin:s,clipValueMax:i}=o,a;P().getBool("WEBGL_PACK_CLIP")?a=new Vg(n.shape):a=new Bg(n.shape);let l=[[s],[i]];return e.runWebGLProgram(a,[n],n.dtype,l)}var V2={kernelName:Tn,backendName:"webgl",kernelFunc:OH};var Gg=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function G2(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function LH(r){let{inputs:t,backend:e}=r,{x:o}=t,n=e.texData.get(o.dataId),s=new Gg(o.shape),i=[G2(o,n.complexTensorInfos.real),G2(o,n.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var W2={kernelName:Ks,backendName:"webgl",kernelFunc:LH};var Wg=class{constructor(t){this.outputShape=[],this.outputShape=S.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];let o=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];o.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let n=e.length,s=e[e.length-1];o.push(`else setOutput(getT${n}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${o.join(`
        `)}
      }
    `}};var Hg=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(t,e);let o=this.outputShape,n=o.length,s=Et(n),i=Ce("coords",n),a=["x","y","z","w","u","v"].slice(0,n);this.variableNames=t.map((d,g)=>`T${g}`);let l=new Array(t.length-1);l[0]=t[0][e];for(let d=1;d<l.length;d++)l[d]=l[d-1]+t[d][e];let u=a[e],c=a.slice(-2),p=a.join(),m=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let d=1;d<l.length;d++){let g=l[d-1];m+=`
        if (${u} < ${l[d]}  && ${u} >= ${l[d-1]}) {
          return getChannel(
            getT${d}(${Ug(a,u,g)}),
            vec2(${Ug(c,u,g)}));
        }`}let f=l.length,h=l[l.length-1];m+=`
        return getChannel(
          getT${f}(${Ug(a,u,h)}),
          vec2(${Ug(c,u,h)}));`,this.userCode=`
      float getValue(${a.map(d=>"int "+d)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[n-1]} = ${i[n-1]} + 1;
        if (${i[n-1]} < ${o[n-1]}) {
          result.g = getValue(${i});
        }

        ${i[n-2]} = ${i[n-2]} + 1;
        if (${i[n-2]} < ${o[n-2]}) {
          result.a = getValue(${i});
        }

        ${i[n-1]} = ${i[n-1]} - 1;
        if (${i[n-2]} < ${o[n-2]} &&
            ${i[n-1]} < ${o[n-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function Ug(r,t,e){let o=r.indexOf(t);return r.map((s,i)=>i===o?`${s} - ${e}`:s).join()}function hl(r){let{inputs:t,backend:e}=r,{input:o}=t,n=e.texData.get(o.dataId);return Ie({inputs:{x:n.complexTensorInfos.imag},backend:e})}var U2={kernelName:Hl,backendName:"webgl",kernelFunc:hl};function $c(r,t,e){let o=r[0].dtype;if(o==="complex64"){let f=r.map(b=>Rs({inputs:{input:b},backend:e})),h=r.map(b=>hl({inputs:{input:b},backend:e})),d=$c(f,t,e),g=$c(h,t,e),x=Tr({inputs:{real:d,imag:g},backend:e});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(g),x}let n=e.shouldExecuteOnCPU(r);if(o==="string"&&(n=!0),n){let f=r.map(w=>{let E=[-1,y.sizeFromShape(w.shape.slice(t))];return Q({inputs:{x:w},backend:e,attrs:{shape:E}})}),h=f.map(w=>({vals:e.readSync(w.dataId),shape:w.shape})),d=S.computeOutShape(f.map(w=>w.shape),1),g=f[0].shape[0]===1,x=XA(h,d,o,g),b=S.computeOutShape(r.map(w=>w.shape),t),C=e.makeTensorInfo(b,o,x);return f.forEach(w=>e.disposeIntermediateTensorInfo(w)),C}let s=r.filter(f=>y.sizeFromShape(f.shape)>0),i=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let f=i?new Xe(r[0].shape,pn):new Nr(r[0].shape,pn);return e.runWebGLProgram(f,r,o)}let a=P().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let f=[];for(let d=0;d<s.length;d+=a){let g=s.slice(d,d+a);f.push($c(g,t,e))}let h=$c(f,t,e);for(let d of f)e.disposeIntermediateTensorInfo(d);return h}if(i){let f=new Hg(s.map(h=>h.shape),t);return e.runWebGLProgram(f,s,o)}let{tensors2D:l,outShape:u}=PH(s,t,e),c=new Wg(l.map(f=>f.shape)),p=e.runWebGLProgram(c,l,o);l.forEach(f=>e.disposeIntermediateTensorInfo(f));let m=Q({inputs:{x:p},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(p),m}function PH(r,t,e){let o=S.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>Q({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:o}}function F0(r){let{inputs:t,backend:e,attrs:o}=r,{axis:n}=o,s=y.parseAxisParam(n,t[0].shape)[0],i=t.map(u=>u.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(t.map(u=>u.shape),s);if(y.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(u=>y.sizeFromShape(u.shape)>0);return l.length===1?Ie({inputs:{x:l[0]},backend:e}):$c(l,s,e)}var H2={kernelName:qs,backendName:"webgl",kernelFunc:F0};var Dc=class{constructor(t,e=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,f=t.filterWidth,h=Math.floor(t.inChannels/4)*4,d=t.inChannels%4,g=t.dataFormat==="channelsLast",x=g?1:2,b=g?2:3,C=g?3:1,w="",I="";o&&(n?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:s?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:w=`
          float activation(float x) {
            ${o}
          }
        `,I="result = activation(result);");let E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${d===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${d===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${d===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${I}
        setOutput(result);
      }
    `}},Kg=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,o=t.padInfo.top,n=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,f=t.filterWidth,h=Math.floor(t.inChannels/4)*4,d=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${o}, ${n});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${d===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${d===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${d===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Rc=class{constructor(t,e=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xt(this.outputShape.length);let i=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,p=c,m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)m+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;m+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)m+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(p+1)/2;g++){let x=g*2;if(m+=`
           xC = xCCorner + ${x*l};
           `,a===1){if(x<c&&(i%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,l===1&&x>0?m+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<c)){let b=i%2===0?y.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,l>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:m+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):b===1?m+=`
                     xC${x+1} = xTexelC${x};
                     `:m+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<c&&(i%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<c&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<c&&(m+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<c&&(m+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<c&&(m+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let f="",h="";o&&(n?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${o}
         }`:s?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${o}
         }`:f=`vec4 activation(vec4 x) {
           ${o}
         }`,h="result = activation(result);");let d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${d}
         ${h}
         setOutput(result);
       }
     `}};var qg=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Xt(this.outputShape.length);let{dataFormat:o}=e,n=he(),s=o==="channelsLast",i=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`,u="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)u+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${n.output} = result;
      }
    `}};function jg(r,t){let e=r.length;return e>=3?t?[...r.slice(0,-3),r[e-3]*r[e-2],r[e-1]]:[...r.slice(0,-3),r[e-3],r[e-2]*r[e-1]]:!t&&e===1&&r[0]>1?[r[0],1]:null}function Xg({x:r,filter:t,convInfo:e,backend:o,bias:n=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let l=r.shape,u=o.texData.get(r.dataId),c=e.inChannels,p=l[0]*l[1]*l[2],m=e.outChannels,f=e.dataFormat==="channelsLast",h=!1,d=!1,g,x=[];if(s!=null){let w=jg(s.shape,f);w!=null&&(s=Q({inputs:{x:s},backend:o,attrs:{shape:w}}),x.push(s))}if(n!=null){let w=jg(n.shape,f);w!=null&&(n=Q({inputs:{x:n},backend:o,attrs:{shape:w}}),x.push(n))}if(!((p===1||m===1)&&c>A0)&&u.isPacked&&f&&u.texture!=null&&l[2]%2!==0&&y.arraysEqual(u.shape.slice(-3),l.slice(-3))){let w=l[0]*l[1]*(l[2]+1),I={dataId:r.dataId,shape:[1,w,e.inChannels],dtype:r.dtype},E=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,y.assert(al(u.shape,I.shape),()=>`packed reshape ${u.shape} to ${I.shape} isn't free`);let A=Q({inputs:{x:t},backend:o,attrs:{shape:[1,e.inChannels,e.outChannels]}});x.push(A);let $=fl({a:I,b:A,backend:o,transposeA:h,transposeB:d,bias:n,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),_=o.texData.get($.dataId);y.assert(_.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=E,_.shape=e.outShape,g=Ie({inputs:{x:$},backend:o}),g.shape=e.outShape,x.push($)}else{let w=e.outHeight*e.outWidth,I=Q({inputs:{x:r},backend:o,attrs:{shape:f?[e.batchSize,w,e.inChannels]:[e.batchSize,e.inChannels,w]}}),E=Q({inputs:{x:t},backend:o,attrs:{shape:[1,e.inChannels,e.outChannels]}}),A=fl({a:f?I:E,b:f?E:I,transposeA:!f,transposeB:d,backend:o,bias:n,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=Q({inputs:{x:A},backend:o,attrs:{shape:e.outShape}}),x.push(I),x.push(E),x.push(A)}for(let w of x)o.disposeIntermediateTensorInfo(w);return g}function Yg({x:r,filter:t,convInfo:e,backend:o,bias:n=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:m,dataFormat:f}=e,h=f==="channelsLast",d=l*u*c,g=m*p,x=[e.batchSize,d,g],b=!0,C=!1,w=[];if(s!=null){let K=jg(s.shape,h);K!=null&&(s=Q({inputs:{x:s},backend:o,attrs:{shape:K}}),w.push(s))}if(n!=null){let K=jg(n.shape,h);K!=null&&(n=Q({inputs:{x:n},backend:o,attrs:{shape:K}}),w.push(n))}let I=Q({inputs:{x:t},backend:o,attrs:{shape:[1,d,y.sizeFromShape(t.shape)/d]}});w.push(I);let E=new qg(x,e),A=[r.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],$=o.runWebGLProgram(E,[r],"float32",A),_=Q({inputs:{x:$},backend:o,attrs:{shape:x}});w.push($),w.push(_);let L=n!=null,B=s!=null,V=a==="leakyrelu",G=a?Ds(a,!0):null,U=new Ac(h?_.shape:I.shape,h?I.shape:_.shape,h?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],b,C,L,G,B,V),W=h?[_,I]:[I,_];if(n&&W.push(n),B&&W.push(s),V){let K=o.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));W.push(K),w.push(K)}let q=o.runWebGLProgram(U,W,"float32"),Z=Q({inputs:{x:q},backend:o,attrs:{shape:e.outShape}});w.push(q);for(let K of w)o.disposeIntermediateTensorInfo(K);return Z}function zH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=o,p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(n.shape,s.shape,i,u,a,c,!1,p),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=Xg({x:n,filter:s,convInfo:m,backend:e});else if(m.strideWidth<=2&&p==="channelsLast"&&P().getBool("WEBGL_EXP_CONV")){let d=new Rc(m),g=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];f=e.runWebGLProgram(d,[n,s],"float32",g)}else if(P().getBool("WEBGL_CONV_IM2COL"))f=Yg({x:n,filter:s,convInfo:m,backend:e});else{let d=new Dc(m);f=e.runWebGLProgram(d,[n,s],"float32")}let h=Q({inputs:{x:f},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(f),h}var K2={kernelName:js,backendName:"webgl",kernelFunc:zH};var Zg=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,o=t.strideWidth,n=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${n};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${o} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Jg=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,o=t.filterWidth,n=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,l=o-1-t.padInfo.left,u=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Qg=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,o=t.strideHeight,n=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${o} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${n} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},tx=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,o=t.filterHeight,n=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=e-1-t.padInfo.front,u=o-1-t.padInfo.top,c=n-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${o}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${o} - 1 - wR;

            for (int wC = 0; wC < ${n}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${n} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function MH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,dy:s}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=o,p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(n.shape,c,i,1,a,u,!1,p),f=new Zg(m);return e.runWebGLProgram(f,[n,s],"float32")}var q2={kernelName:Dl,backendName:"webgl",kernelFunc:MH};function BH(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,filter:s}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=o,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(i,s.shape,a,1,l,c,!1,p),f=new Jg(m);return e.runWebGLProgram(f,[n,s],"float32")}var j2={kernelName:Xs,backendName:"webgl",kernelFunc:BH};function VH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s}=t,{strides:i,pad:a,dilations:l}=o,u=S.computeConv3DInfo(n.shape,s.shape,i,l,a),c=new Kg(u);return e.runWebGLProgram(c,[n,s],"float32")}var X2={kernelName:Ys,backendName:"webgl",kernelFunc:VH};function GH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,dy:s}=t,{strides:i,pad:a,filterShape:l}=o,u=S.computeConv3DInfo(n.shape,l,i,1,a),c=new Qg(u);return e.runWebGLProgram(c,[n,s],"float32")}var Y2={kernelName:Rl,backendName:"webgl",kernelFunc:GH};function WH(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,filter:s}=t,{pad:i,strides:a,inputShape:l}=o,u=S.computeConv3DInfo(l,s.shape,a,1,i),c=new tx(u);return e.runWebGLProgram(c,[n,s],"float32")}var Z2={kernelName:Fl,backendName:"webgl",kernelFunc:WH};var UH=No+`
  return cos(x);
`,HH=mt({opSnippet:UH}),J2={kernelName:vn,backendName:"webgl",kernelFunc:HH};var KH=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,qH=mt({opSnippet:KH}),Q2={kernelName:kn,backendName:"webgl",kernelFunc:qH};var ex=class{constructor(t,e,o,n,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,l,u]=t,[c]=e,[p,m]=o;this.outputShape=[c,p,m,u];let f=n==="bilinear"?1:0,[h,d]=[`${a-1}.0`,`${l-1}.0`],[g,x,b]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[C,w,I]=m>1?[`${(l-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${d} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${d}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${d} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var jH=r=>{let{inputs:t,backend:e,attrs:o}=r,{image:n,boxes:s,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=o,c=new ex(n.shape,s.shape,a,l,u);return e.runWebGLProgram(c,[n,s,i],"float32")},tD={kernelName:Ol,backendName:"webgl",kernelFunc:jH};var dl;(function(r){r.Prod="*",r.Sum="+"})(dl||(dl={}));var xf=class{constructor(t,e,o,n){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===dl.Prod?"1.0":"0.0",a=o?i:`getX(${eD(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1],u="",c="";o?(u=n?`end != ${l-1}`:"end != 0",c=n?"end + 1":"end - 1"):(u=n?`end + pow2 < ${l}`:"end >= pow2",c=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Et(s)} coords = getOutputCoords();
        int end = ${rD(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${rD(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${eD(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function eD(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function rD(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function rx(r,t,e,o,n,s){let i=t.shape.length,a=S.getAxesPermutation([o],i),l=t;a!=null&&(l=ae({inputs:{x:t},backend:e,attrs:{perm:a}}));let u=S.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${o}`);let c=l.shape[u],p=Ie({inputs:{x:l},backend:e});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let f=new xf(r,l.shape,!1,s),h=[[m]],d=p;p=e.runWebGLProgram(f,[p],p.dtype,h),e.disposeIntermediateTensorInfo(d)}if(n){let m=new xf(r,l.shape,n,s),f=p;p=e.runWebGLProgram(m,[p],p.dtype),e.disposeIntermediateTensorInfo(f)}if(a!=null){let m=S.getUndoAxesPermutation(a),f=ae({inputs:{x:p},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(l),f}return p}function XH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,exclusive:i,reverse:a}=o;return rx(dl.Prod,n,e,s,i,a)}var oD={kernelName:_l,backendName:"webgl",kernelFunc:XH};function YH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,exclusive:i,reverse:a}=o;return rx(dl.Sum,n,e,s,i,a)}var nD={kernelName:Zs,backendName:"webgl",kernelFunc:YH};function ZH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,weights:s}=t,{size:i,binaryOutput:a}=o;if(n.shape.length===1){let l=e.readSync(n.dataId),u=e.readSync(s.dataId),c=yg(l,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(n.shape.length===2){let l=e.bufferSync(n),u=e.bufferSync(s),c=KA(l,u,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n.shape.length}.`)}var sD={kernelName:Ll,backendName:"webgl",kernelFunc:ZH};var ox=class{constructor(t,e,o){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=o,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function JH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{blockSize:s,dataFormat:i}=o,a=n.shape[0],l=i==="NHWC"?n.shape[1]:n.shape[2],u=i==="NHWC"?n.shape[2]:n.shape[3],c=i==="NHWC"?n.shape[3]:n.shape[1],p=l*s,m=u*s,f=c/(s*s),h=i==="NHWC"?[a,p,m,f]:[a,f,p,m],d=new ox(h,s,i);return e.runWebGLProgram(d,[n],n.dtype)}var iD={kernelName:Pl,backendName:"webgl",kernelFunc:JH};var Fc=class{constructor(t,e=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xt(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels,u="",c="";o&&(n?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:u=`
          float activation(float x) {
            ${o}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var _c=class{constructor(t,e=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xt(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,m=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<p;x++)f+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let x=0;x<p;x++)f+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(m+1)/2;x++){let b=x*2;if(f+=`
          xC = xCCorner + ${b*u};
          `,l===1){if(b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<p)){let C=a%2===0?y.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:f+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):C===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<p&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<p&&(f+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<p&&(f+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let h="",d="";o&&(n?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:h=`vec4 activation(vec4 x) {
          ${o}
        }`,d="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${d}
        setOutput(result);
      }
    `}};function QH(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=o,c=l;c==null&&(c=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=S.computeConv2DInfo(n.shape,s.shape,i,c,a,u,!0),m;P().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new _c(p):m=new Fc(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[n,s],"float32",f)}var aD={kernelName:Js,backendName:"webgl",kernelFunc:QH};var nx=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,o=t.strideWidth,n=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${n};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${o} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},sx=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,o=t.filterWidth,n=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=o-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function tK(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,dy:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=o,p=S.computeConv2DInfo(n.shape,c,i,a,l,u,!0),m=new nx(p);return e.runWebGLProgram(m,[n,s],"float32")}var lD={kernelName:zl,backendName:"webgl",kernelFunc:tK};function eK(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,filter:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=o,p=S.computeConv2DInfo(c,s.shape,i,a,l,u,!0),m=new sx(p);return e.runWebGLProgram(m,[n,s],"float32")}var uD={kernelName:Ml,backendName:"webgl",kernelFunc:eK};var ix=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function rK(r){let{inputs:t,backend:e}=r,{x:o}=t,n=[...o.shape,...o.shape],s=y.sizeFromShape(o.shape),i=Q({inputs:{x:o},backend:e,attrs:{shape:[s]}}),a=new ix(s),l=e.runWebGLProgram(a,[i],i.dtype),u=Q({inputs:{x:l},backend:e,attrs:{shape:n}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}var cD={kernelName:Nf,backendName:"webgl",kernelFunc:rK};var ax=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:o,padInfo:n,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:p,left:m}=n;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${o}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function oK(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s}=t,{strides:i,pad:a,dilations:l}=o,u=S.computeDilation2DInfo(n.shape,s.shape,i,a,"NHWC",l),c,p=new ax(u);c=e.runWebGLProgram(p,[n,s],"float32");let m=Q({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),m}var pD={kernelName:Qs,backendName:"webgl",kernelFunc:oK};function nK(r){let{inputs:t,backend:e,attrs:o}=r,{equation:n}=o,s=t,{allDims:i,summedDims:a,idDims:l}=S.decodeEinsumEquation(n,s.length);S.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=S.getEinsumComputePath(a,l),p=c.length,m=null,f=i.length,h=[];for(let d=0;d<p;++d){for(let g of c[d]){let{permutationIndices:x,expandDims:b}=S.getEinsumPermutation(f,l[g]),C;S.isIdentityPermutation(x)?C=s[g]:(C=ae({inputs:{x:s[g]},backend:e,attrs:{perm:x}}),h.push(C));let w=C.shape.slice();for(let I=0;I<b.length;++I)w.splice(b[I],0,1);y.arraysEqual(C.shape,w)||(C=Q({inputs:{x:C},backend:e,attrs:{shape:w}}),h.push(C)),m===null?m=C:(m=df({inputs:{a:C,b:m},backend:e}),h.push(m))}d<p-1&&(u[d]>=0&&(m=ml({inputs:{x:m},backend:e,attrs:{axis:u[d]-(i.length-f),keepDims:!1}}),h.push(m)),f--)}for(let d of h)d!==m&&e.disposeIntermediateTensorInfo(d);return m}var mD={kernelName:Tf,backendName:"webgl",kernelFunc:nK};var sK="return (x >= 0.0) ? x : (exp(x) - 1.0);",iK=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,aK=mt({opSnippet:sK,packedOpSnippet:iK}),fD={kernelName:An,backendName:"webgl",kernelFunc:aK};var lK="return (b >= 1.0) ? a : a * (b + 1.0);",uK=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,cK=r=>{let{inputs:t,backend:e}=r,{dy:o,y:n}=t,s=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new So(uK,o.shape,n.shape):new Zr(lK,o.shape,n.shape);return e.runWebGLProgram(s,[o,n],o.dtype)},hD={kernelName:Bl,backendName:"webgl",kernelFunc:cK};var pK=`
  return vec4(equal(a, b));
`,mK="return float(a == b);",fK=Vt({opSnippet:mK,packedOpSnippet:pK,dtype:"bool",cpuKernelImpl:YA}),dD={kernelName:la,backendName:"webgl",kernelFunc:fK};var hK=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,dK=mt({opSnippet:hK}),gD={kernelName:$n,backendName:"webgl",kernelFunc:dK};var gK=No+`
  return exp(x);
`,xK=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_0=mt({opSnippet:gK,packedOpSnippet:xK,cpuKernelImpl:ZA,dtype:"float32"}),xD={kernelName:Dn,backendName:"webgl",kernelFunc:_0};function lx(r){let{inputs:t,attrs:e,backend:o}=r,{dim:n}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),l=n;return n<0&&(y.assert(-(i+1)<=n,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+n+1),a.splice(l,0,1),Q({inputs:{x:s},backend:o,attrs:{shape:a}})}var yD={kernelName:ti,backendName:"webgl",kernelFunc:lx};var bD="return exp(x) - 1.0;",yK=mt({opSnippet:bD,packedOpSnippet:bD,cpuKernelImpl:JA}),wD={kernelName:Rn,backendName:"webgl",kernelFunc:yK};var yf=class{constructor(t,e,o){this.variableNames=["real","imag"];let n=e[1];this.outputShape=e;let s=o?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=o?`${n}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${n});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${n}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function ux(r,t,e){let o=e.texData.get(r.dataId),n=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=n/s,a=Q({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),l=a.shape,u=new yf("real",l,t),c=new yf("imag",l,t),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:l},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:l}],m=e.runWebGLProgram(u,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),h=Tr({inputs:{real:m,imag:f},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f);let d=Q({inputs:{x:h},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(h),d}function bK(r){let{inputs:t,backend:e}=r,{input:o}=t;return ux(o,!1,e)}var CD={kernelName:Vl,backendName:"webgl",kernelFunc:bK};var cx=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Fs(r){let{backend:t,attrs:e}=r,{shape:o,value:n}=e,{dtype:s}=e;if(s=s||y.inferDtype(n),s==="string"){let i=y.getArrayFromDType(s,y.sizeFromShape(o));return i.fill(n),t.makeTensorInfo(o,s,i)}else{let i=new cx(o,n),a=[[n]];return t.runWebGLProgram(i,[],s,a)}}var ID={kernelName:Gl,backendName:"webgl",kernelFunc:Fs};var px=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var SD={kernelName:Wl,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,o=t,n=new px(e.shape);return o.runWebGLProgram(n,[e],e.dtype)}};var ND="return floor(x);",wK=mt({opSnippet:ND,packedOpSnippet:ND,cpuKernelImpl:QA}),TD={kernelName:Fn,backendName:"webgl",kernelFunc:wK};var CK=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,IK=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,SK=Vt({opSnippet:CK,packedOpSnippet:IK,dtype:"int32"}),vD={kernelName:_n,backendName:"webgl",kernelFunc:SK};var mx=class{constructor(t){this.variableNames=["A"];let e=he(),[o,n]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}.0, ${o}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var fx=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=he(),[o,n]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${n}.0, ${o}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var kD={kernelName:J0,backendName:"webgl",kernelFunc:NK},Oc,O0=P().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function NK(r){let{inputs:t,backend:e,attrs:o}=r,{pixels:n}=t,{numChannels:s}=o,i=typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement,[l,u]=i?[n.videoWidth,n.videoHeight]:[n.width,n.height],c=[u,l],p=[u,l,s];if(a||i){let d=P().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Oc==null||d!==O0)&&(O0=d,Oc=document.createElement("canvas").getContext("2d",{willReadFrequently:O0})),Oc.canvas.width=l,Oc.canvas.height=u,Oc.drawImage(n,0,0,l,u),n=Oc.canvas}let m=e.makeTensorInfo(c,"int32");e.texData.get(m.dataId).usage=or.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),n);let f=P().getBool("WEBGL_PACK")?new fx(p):new mx(p),h=e.runWebGLProgram(f,[m],"int32");return e.disposeData(m.dataId),h}function TK(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:h}=o,d=S.convertConv2DDataFormat(c),g=S.computeConv2DInfo(n.shape,s.shape,l,p,u,m,!1,d),x,b=[],C=i!=null,w=a!=null,I=f==="leakyrelu",E=()=>{let $=[n,s],_=(L,B)=>{if(B==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){let V=Q({inputs:{x:L},backend:e,attrs:{shape:[L.shape[0],1,1]}});return b.push(V),V}return L};if(C&&$.push(_(i,c)),w&&$.push(_(a,c)),I){let L=e.makeTensorInfo([],"float32",y.createScalarValue(h,"float32"));$.push(L),b.push(L)}return $};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=Xg({x:n,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:h});else if(g.strideWidth<=2&&d==="channelsLast"&&P().getBool("WEBGL_EXP_CONV")){let $=f?Ds(f,!0):null,_=new Rc(g,C,$,w,I),L=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],B=E();x=e.runWebGLProgram(_,B,"float32",L)}else if(P().getBool("WEBGL_CONV_IM2COL"))x=Yg({x:n,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:h});else{let $=f?Ds(f,!1):null,_=new Dc(g,C,$,w,I),L=E();x=e.runWebGLProgram(_,L,"float32")}let A=Q({inputs:{x},backend:e,attrs:{shape:g.outShape}});return b.push(x),b.forEach($=>e.disposeIntermediateTensorInfo($)),A}var ED={kernelName:xa,backendName:"webgl",kernelFunc:TK};function vK(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=o,h=[],d=c;d==null&&(d=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(l,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${d}'`);let g=S.computeConv2DInfo(n.shape,s.shape,l,d,u,p,!0),x=P().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=m?Ds(m,x):null,C=[n,s],w=i!=null,I=a!=null,E=m==="leakyrelu";if(w&&C.push(i),I&&C.push(a),E){let L=e.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));C.push(L),h.push(L)}let A;x?A=new _c(g,w,b,I,E):A=new Fc(g,w,b,I,E);let $=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],_=e.runWebGLProgram(A,C,"float32",$);return h.forEach(L=>e.disposeIntermediateTensorInfo(L)),_}var AD={kernelName:ya,backendName:"webgl",kernelFunc:vK};var hx=class{constructor(t,e,o,n){this.sliceDim=t,this.strides=e,this.paramsShape=n,this.variableNames=["x","indices"],this.outputShape=o;let s=Et(o.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function kK(r){let{inputs:t,backend:e}=r,{params:o,indices:n}=t,s=n.shape,i=s[s.length-1],a=y.sizeFromShape(o.shape),[l,u,c,p]=S.prepareAndValidate(o,n),m=Q({inputs:{x:n},backend:e,attrs:{shape:[u,i]}}),f=Q({inputs:{x:o},backend:e,attrs:{shape:[y.sizeFromShape(o.shape)/c,c]}});if(e.shouldExecuteOnCPU([o,n])||o.dtype==="string"){let x=e.readSync(n.dataId),b=e.bufferSync(o),C=t$(x,b,o.dtype,u,i,c,p,o.shape,a);return e.makeTensorInfo(l,o.dtype,C.values)}let h=new hx(i,p,[u,c],o.shape),d=e.runWebGLProgram(h,[f,m],f.dtype),g=Q({inputs:{x:d},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),g}var $D={kernelName:vf,backendName:"webgl",kernelFunc:kK};var dx=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let o=Et(this.rank),n=EK(t,2);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${n}));
      }
    `}};function EK(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let n=0;n<r.length;n++)n===2?o.push("index"):o.push(`${e[n]}`);return o.join()}function L0(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,indices:s}=t,{axis:i,batchDims:a}=o,l=y.parseAxisParam(i,n.shape)[0];if(P().get("DEBUG")){let b=e.readSync(s.dataId),C=n.shape[l];for(let w=0;w<b.length;++w){let I=b[w];y.assert(I<=C-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${C-1}]`)}}let u=S.segment_util.collectGatherOpShapeInfo(n,s,l,a),c=y.sizeFromShape(s.shape),p=[],m=Q({inputs:{x:n},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=Q({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(m),p.push(f);let h=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([n,s])||n.dtype==="string"){let b=e.bufferSync(f),C=e.bufferSync(m),w=e$(C,b,h);return p.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(u.outputShape,w.dtype,w.values)}let d=new dx(m.shape,h),g=e.runWebGLProgram(d,[m,f],m.dtype);p.push(g);let x=Q({inputs:{x:g},backend:e,attrs:{shape:u.outputShape}});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}var DD={kernelName:ri,backendName:"webgl",kernelFunc:L0};var AK="return float(a > b);",$K=`
  return vec4(greaterThan(a, b));
`,DK=Vt({opSnippet:AK,packedOpSnippet:$K,cpuKernelImpl:r$,dtype:"bool"}),RD={kernelName:ua,backendName:"webgl",kernelFunc:DK};var RK="return float(a >= b);",FK=`
  return vec4(greaterThanEqual(a, b));
`,_K=Vt({opSnippet:RK,packedOpSnippet:FK,dtype:"bool",cpuKernelImpl:o$}),FD={kernelName:On,backendName:"webgl",kernelFunc:_K};function OK(r){let{inputs:t,backend:e}=r,{input:o}=t;return ux(o,!0,e)}var _D={kernelName:Ul,backendName:"webgl",kernelFunc:OK};var LK="return float(!isnan(x) && !isinf(x));",PK=mt({opSnippet:LK,dtype:"bool"}),OD={kernelName:Ln,backendName:"webgl",kernelFunc:PK};var zK="return float(isinf(x));",MK=mt({opSnippet:zK,dtype:"bool"}),LD={kernelName:Pn,backendName:"webgl",kernelFunc:MK};var BK="return float(isnan(x));",VK=mt({opSnippet:BK,dtype:"bool"}),PD={kernelName:zn,backendName:"webgl",kernelFunc:VK};var GK="return float(a < b);",WK=`
  return vec4(lessThan(a, b));
`,UK=Vt({opSnippet:GK,packedOpSnippet:WK,cpuKernelImpl:n$,dtype:"bool"}),zD={kernelName:ca,backendName:"webgl",kernelFunc:UK};var HK="return float(a <= b);",KK=`
  return vec4(lessThanEqual(a, b));
`,qK=Vt({opSnippet:HK,packedOpSnippet:KK,cpuKernelImpl:s$,dtype:"bool"}),MD={kernelName:pa,backendName:"webgl",kernelFunc:qK};function jK(r){let{backend:t,attrs:e}=r,{start:o,stop:n,num:s}=e,i=i$(o,n,s);return t.makeTensorInfo([i.length],"float32",i)}var BD={kernelName:kf,backendName:"webgl",kernelFunc:jK};var XK=No+`
  return x < 0.0 ? 0./0. : log(x);
`,YK=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ZK=mt({opSnippet:XK,packedOpSnippet:YK,cpuKernelImpl:a$}),VD={kernelName:Mn,backendName:"webgl",kernelFunc:ZK};var JK=No+`
  return log(1.0 + x);
`,QK=mt({opSnippet:JK}),GD={kernelName:Bn,backendName:"webgl",kernelFunc:QK};var tq="return float(a >= 1.0 && b >= 1.0);",eq=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,rq=Vt({opSnippet:tq,packedOpSnippet:eq,dtype:"bool"}),WD={kernelName:ma,backendName:"webgl",kernelFunc:rq};var oq="return float(!(x >= 1.0));",nq=mt({opSnippet:oq}),UD={kernelName:fa,backendName:"webgl",kernelFunc:nq};var sq="return float(a >= 1.0 || b >= 1.0);",iq=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,aq=Vt({opSnippet:sq,packedOpSnippet:iq,dtype:"bool"}),HD={kernelName:ha,backendName:"webgl",kernelFunc:aq};var gx=class{constructor(t,e,o,n,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=t[3]-1;this.outputShape=t;let l,u=`float(${o}) + float(${n}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};var xx=class{constructor(t,e,o,n,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=t[3]-1;this.outputShape=t;let l,u=`float(${o}) + float(${n}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}};var lq=r=>{let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{depthRadius:s,bias:i,alpha:a,beta:l}=o,u=P().getBool("WEBGL_PACK_NORMALIZATION")?new xx(n.shape,s,i,a,l):new gx(n.shape,s,i,a,l);return e.runWebGLProgram(u,[n],n.dtype)},KD={kernelName:ni,backendName:"webgl",kernelFunc:lq};var yx=class{constructor(t,e,o,n,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=o,this.alpha=n,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${n}) * norm + float(${o});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${n})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var uq=r=>{let{inputs:t,backend:e,attrs:o}=r,{x:n,y:s,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=o,p=new yx(n.shape,a,l,u,c);return e.runWebGLProgram(p,[n,s,i],n.dtype)},qD={kernelName:Kl,backendName:"webgl",kernelFunc:uq};function jD(r,t,e,o){let n=y.sizeFromShape(t),i=y.sizeFromShape(r.shape)/n,a=Q({inputs:{x:r},attrs:{shape:[i,n]},backend:o}),l=Mr(a,r.dtype,"max",o),u=Q({inputs:{x:l},attrs:{shape:e},backend:o});return o.disposeIntermediateTensorInfo(a),o.disposeIntermediateTensorInfo(l),u}function P0(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{reductionIndices:s,keepDims:i}=o,a=n.shape.length,l=y.parseAxisParam(s,n.shape),u=l,c=S.getAxesPermutation(u,a),p=c!=null,m=e.shouldExecuteOnCPU([n]),f=n;if(p){if(m){let C=e.texData.get(f.dataId).values,w=new Array(a);for(let A=0;A<w.length;A++)w[A]=n.shape[c[A]];let I=cl(C,n.shape,n.dtype,c,w);f=e.makeTensorInfo(w,n.dtype);let E=e.texData.get(f.dataId);E.values=I}else f=ea(n,c,e);u=S.getInnerMostAxes(u.length,a)}S.assertAxesAreInnerMostDims("max",u,a);let[h,d]=S.computeOutAndReduceShapes(f.shape,u),g=h;i&&(g=S.expandShapeToKeepDim(h,l));let x;if(m){let C=e.texData.get(f.dataId).values,w=l$(C,y.sizeFromShape(d),g,n.dtype);x=e.makeTensorInfo(g,n.dtype);let I=e.texData.get(x.dataId);I.values=w}else x=jD(f,d,g,e);return p&&e.disposeIntermediateTensorInfo(f),x}var XD={kernelName:si,backendName:"webgl",kernelFunc:P0};var cq=Ec+`
  return max(a, b);
`,pq=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+mn+`
  return result;
`,mq=Vt({opSnippet:cq,packedOpSnippet:pq,cpuKernelImpl:u$}),YD={kernelName:Vn,backendName:"webgl",kernelFunc:mq};function fq(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t;cn(n,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=o,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=S.computePool2DInfo(n.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))return Ie({inputs:{x:n},backend:e});let p=new Vo(c,"max",!1);return e.runWebGLProgram(p,[n],n.dtype)}var ZD={kernelName:ii,backendName:"webgl",kernelFunc:fq};function hq(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{filterSize:s,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=o,c=[1,1,1],p=S.computePool3DInfo(n.shape,s,i,c,a,u,l),m=new ra(p,"max",!1);return e.runWebGLProgram(m,[n],n.dtype)}var JD={kernelName:ai,backendName:"webgl",kernelFunc:hq};var bx=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,o=t.strideWidth,n=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,l=i-1-t.padInfo.left,u=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${n}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},wx=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,o=t.strideHeight,n=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=l-1-t.padInfo.front,m=u-1-t.padInfo.top,f=c-1-t.padInfo.left,h=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${n}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function dq(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s}=t,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=o,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,l,p,u,c),f=new ra(m,"max",!0),h=e.runWebGLProgram(f,[i],i.dtype),d=new wx(m),g=e.runWebGLProgram(d,[n,h],i.dtype);return e.disposeIntermediateTensorInfo(h),g}var QD={kernelName:jl,backendName:"webgl",kernelFunc:dq};function gq(r){let{inputs:t,backend:e,attrs:o}=r,{dy:n,input:s,output:i}=t,a=s;cn([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=o,m=S.computePool2DInfo(a.shape,l,u,1,c,p),f=!0,h=new Vo(m,"max",f),d=e.runWebGLProgram(h,[a],a.dtype),g=new bx(m),x=e.runWebGLProgram(g,[n,d],a.dtype);return e.disposeIntermediateTensorInfo(d),x}var tR={kernelName:ql,backendName:"webgl",kernelFunc:gq};function eR(r,t,e,o){let n=new Vo(e,"max",!1),s=o.runWebGLProgram(n,[r],"float32");n=new Vo(e,"max",!0,!0,t);let i=o.runWebGLProgram(n,[r],"float32");return[s,i]}var rR={kernelName:Ef,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:o}=r,{filterSize:n,strides:s,pad:i,includeBatchInIndex:a}=t,l=e;y.assert(o.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.shape.length}.`);let u=[1,1];y.assert(S.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=S.computePool2DInfo(o.shape,n,s,u,i),[p,m]=eR(o,a,c,l);return[p,m]}};function oR(r,t,e,o){let n=y.sizeFromShape(t),i=y.sizeFromShape(r.shape)/n,a=Q({inputs:{x:r},attrs:{shape:[i,n]},backend:o}),l=Mr(a,"float32","mean",o),u=Q({inputs:{x:l},attrs:{shape:e},backend:o});return o.disposeIntermediateTensorInfo(a),o.disposeIntermediateTensorInfo(l),u}var nR={kernelName:li,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:o}=r,{keepDims:n,axis:s}=t,i=e,a=o.shape.length,l=y.parseAxisParam(s,o.shape),u=l,c=S.getAxesPermutation(u,a),p=c!=null,m=i.shouldExecuteOnCPU([o]),f=[],h=o;if(p){if(m){let w=i.texData.get(h.dataId).values,I=new Array(a);for(let $=0;$<I.length;$++)I[$]=o.shape[c[$]];let E=cl(w,o.shape,o.dtype,c,I);h=i.makeTensorInfo(I,o.dtype);let A=i.texData.get(h.dataId);A.values=E}else h=ea(o,c,i);f.push(h),u=S.getInnerMostAxes(u.length,a)}S.assertAxesAreInnerMostDims("sum",u,a);let[d,g]=S.computeOutAndReduceShapes(h.shape,u),x=d;n&&(x=S.expandShapeToKeepDim(d,l));let b=oR(h,g,x,i);for(let C of f)i.disposeIntermediateTensorInfo(C);return b}};function xq(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o,a=n.shape.length,l=y.parseAxisParam(s,n.shape),u=l,c=S.getAxesPermutation(u,a),p=n;c!=null&&(p=ae({inputs:{x:n},backend:e,attrs:{perm:c}}),u=S.getInnerMostAxes(u.length,n.shape.length)),S.assertAxesAreInnerMostDims("min",u,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,u),h=y.sizeFromShape(f),d=Q({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),g=Mr(d,d.dtype,"min",e),x;if(i){let b=S.expandShapeToKeepDim(m,l);x=Q({inputs:{x:g},backend:e,attrs:{shape:b}})}else x=Q({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),x}var sR={kernelName:ui,backendName:"webgl",kernelFunc:xq};var yq=Ec+`
  return min(a, b);
`,bq=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+mn+`
  return result;
`,wq=Vt({opSnippet:yq,packedOpSnippet:bq,cpuKernelImpl:c$}),iR={kernelName:Gn,backendName:"webgl",kernelFunc:wq};var Cx=class{constructor(t,e,o){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);let n=t.length,s=Et(n),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n),u=o==="reflect"?0:1;if(n===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${n}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};var Ix=class{constructor(t,e,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((h,d)=>h[0]+t[d]+h[1]);let n=t.length,s=Et(n),i=e.map(h=>h[0]).join(","),a=e.map((h,d)=>h[0]+t[d]).join(","),l=Ce("rc",n),u=Ce("source",n),c=`${l[n-1]} < ${this.outputShape[n-1]}`,p=n===1?"source":`vec2(${u.slice(-2).join()})`,m=o==="reflect"?0:1,f="";if(n===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[n-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[n-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
        rc = outputLoc;
        ${l[n-2]} += 1;
        if(${l[n-2]} < ${this.outputShape[n-2]}) {
          ${h}
          result[2] = getChannel(getX(${u.join()}), ${p});
          ${l[n-1]} += 1;
          if(${c}) {
            ${h}
            result[3] = getChannel(getX(${u.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var Cq=({inputs:r,backend:t,attrs:e})=>{let{x:o}=r,{paddings:n,mode:s}=e,i=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ix(o.shape,n,s):new Cx(o.shape,n,s);return t.runWebGLProgram(i,[o],o.dtype)},aR={kernelName:ci,backendName:"webgl",kernelFunc:Cq};var Iq=`if (b == 0.0) return NAN;
  return mod(a, b);`,Sq=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+mn+`
  return result;
`,Nq=Vt({opSnippet:Iq,packedOpSnippet:Sq}),lR={kernelName:Wn,backendName:"webgl",kernelFunc:Nq};var Sx=class{constructor(t,e,o){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,o],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var Tq=`
if (a == b) {
  return 1.0;
};
return a / b;`,vq=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,z0=Vt({opSnippet:Tq,packedOpSnippet:vq,checkOutOfBounds:!0}),uR={kernelName:En,backendName:"webgl",kernelFunc:z0};var cR="return a - b;",M0=Vt({opSnippet:cR,packedOpSnippet:cR,supportsComplex:!0,cpuKernelImpl:$$}),pR={kernelName:ss,backendName:"webgl",kernelFunc:M0};function B0(r){let{inputs:t,backend:e,attrs:o}=r,{logits:n}=t,{dim:s}=o,i=y.parseAxisParam([s],n.shape),a=P0({inputs:{x:n},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=S.expandShapeToKeepDim(a.shape,i),u=Q({inputs:{x:a},backend:e,attrs:{shape:l}}),c=M0({inputs:{a:n,b:u},backend:e}),p=_0({inputs:{x:c},backend:e}),m=ml({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),f=Q({inputs:{x:m},backend:e,attrs:{shape:l}}),h=z0({inputs:{a:p,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),h}var mR={kernelName:ki,backendName:"webgl",kernelFunc:B0};function kq(r){let{inputs:t,backend:e,attrs:o}=r,{logits:n}=t,{numSamples:s,seed:i,normalized:a}=o,l=a?n:B0({inputs:{logits:n},backend:e,attrs:{dim:n.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new Sx(u,c,s),m=[[i]],f=e.runWebGLProgram(p,[l],"int32",m);return a||e.disposeIntermediateTensorInfo(l),f}var fR={kernelName:Af,backendName:"webgl",kernelFunc:kq};var Eq=De+`
  return -x;
`,Aq=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function $q(r){let{inputs:t,backend:e}=r,{x:o}=t;if(e.shouldExecuteOnCPU([o])){let s=e.texData.get(o.dataId),[i,a]=m$(s.values,o.shape,o.dtype);return e.makeTensorInfo(a,o.dtype,i)}let n;return P().getBool("WEBGL_PACK_UNARY_OPERATIONS")?n=new Nr(o.shape,Aq):n=new Xe(o.shape,Eq),e.runWebGLProgram(n,[o],o.dtype)}var hR={kernelName:pi,backendName:"webgl",kernelFunc:$q};var Dq=tr.nonMaxSuppressionV3Impl;function Rq(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:o}=r,{boxes:n,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=o,u=e.readSync(n.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=Dq(u,c,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var dR={kernelName:Xl,backendName:"webgl",kernelFunc:Rq};var Fq=tr.nonMaxSuppressionV4Impl;function _q(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:o}=r,{boxes:n,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=o,c=e.readSync(n.dataId),p=e.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=Fq(c,p,i,a,l,u);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var gR={kernelName:Yl,backendName:"webgl",kernelFunc:_q};var Oq=tr.nonMaxSuppressionV5Impl;function Lq(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:o}=r,{boxes:n,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=o,c=e.readSync(n.dataId),p=e.readSync(s.dataId),m=i,f=a,h=l,d=u,{selectedIndices:g,selectedScores:x}=Oq(c,p,m,f,h,d);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var xR={kernelName:Zl,backendName:"webgl",kernelFunc:Lq};var Nx=class{constructor(t,e,o,n){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${n}), float(${o}),
                      float(index == coords.y)));
      }
    `}};var Pq=r=>{let{inputs:t,backend:e,attrs:o}=r,{indices:n}=t,{dtype:s,depth:i,onValue:a,offValue:l}=o,u=y.sizeFromShape(n.shape),c=new Nx(u,i,a,l),p=Q({inputs:{x:n},backend:e,attrs:{shape:[u]}}),m=e.runWebGLProgram(c,[p],s);e.disposeIntermediateTensorInfo(p);let f=[...n.shape,i],h=Q({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(m),h},yR={kernelName:fi,backendName:"webgl",kernelFunc:Pq};function bf(r){let{inputs:t,backend:e}=r,{x:o}=t;if(o.dtype==="complex64"){let n=Rs({inputs:{input:o},backend:e}),s=bf({inputs:{x:n},backend:e}),i=hl({inputs:{input:o},backend:e}),a=bf({inputs:{x:i},backend:e}),l=Tr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return Fs({attrs:{shape:o.shape,dtype:o.dtype,value:o.dtype==="string"?"":0},backend:e})}var bR={kernelName:$i,backendName:"webgl",kernelFunc:bf};function wR(r){let{inputs:t,backend:e}=r,{x:o}=t;if(o.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(o.dtype==="complex64"){let n=Rs({inputs:{input:o},backend:e}),s=wR({inputs:{x:n},backend:e}),i=hl({inputs:{input:o},backend:e}),a=bf({inputs:{x:i},backend:e}),l=Tr({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return Fs({attrs:{shape:o.shape,dtype:o.dtype,value:1},backend:e})}var CR={kernelName:mi,backendName:"webgl",kernelFunc:wR};function zq(r){let{inputs:t,backend:e,attrs:o}=r,{axis:n}=o;if(t.length===1)return lx({inputs:{input:t[0]},backend:e,attrs:{dim:n}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=t.map(c=>{let p=lx({inputs:{input:c},backend:e,attrs:{dim:n}});return a.push(p),p}),u=F0({inputs:l,backend:e,attrs:{axis:n}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}var IR={kernelName:hi,backendName:"webgl",kernelFunc:zq};var Tx=class{constructor(t,e,o){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);let n=t.length,s=Et(n),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n);if(n===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};var vx=class{constructor(t,e,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((d,g)=>d[0]+t[g]+d[1]);let n=t.length,s=Et(n),i=e.map(d=>d[0]).join(","),a=e.map((d,g)=>d[0]+t[g]).join(","),l=Ce("rc",n),u=Ce("source",n),c=`${l[n-1]} < ${this.outputShape[n-1]}`,p=n===1?"source":`vec2(${u.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${l[n-1]} += 1;
       if(${c}) {
      `,n===1?"":`}
       rc = outputLoc;
       ${l[n-2]} += 1;
       if(${l[n-2]} < ${this.outputShape[n-2]}) {`,n===1?"":`  ${l[n-1]} += 1;
         if(${c}) {`],f=n===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let d=0,g=n===1?2:4;d<g;d++)h+=`
        ${m[d]}
        if (${f}) {
          result[${d}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${d}] = getChannel(getX(${u.join()}), ${p});
        }
      `;h+=n===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}};var V0=r=>{let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{paddings:s,constantValue:i}=o;if(y.sizeFromShape(n.shape)===0){let u=s.map((c,p)=>c[0]+n.shape[p]+c[1]);return Fs({backend:e,attrs:{shape:u,value:i,dtype:n.dtype}})}let a=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vx(n.shape,s,i):new Tx(n.shape,s,i),l=[[i]];return e.runWebGLProgram(a,[n],n.dtype,l)},SR={kernelName:di,backendName:"webgl",kernelFunc:V0};var Mq=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Bq=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+mn+`
  return result;
`,Vq=Vt({opSnippet:Mq,packedOpSnippet:Bq}),NR={kernelName:Hn,backendName:"webgl",kernelFunc:Vq};function Gq(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{axis:s,keepDims:i}=o,a=n.shape.length,l=[],u=y.parseAxisParam(s,n.shape),c=u,p=S.getAxesPermutation(c,a),m=n;p!=null&&(m=ae({inputs:{x:n},backend:e,attrs:{perm:p}}),c=S.getInnerMostAxes(c.length,a),l.push(m)),S.assertAxesAreInnerMostDims("prod",c,a);let f;if(e.shouldExecuteOnCPU([m])){let h=e.texData.get(m.dataId).values,{outVals:d,outShape:g,outDtype:x}=h$(m.shape,m.dtype,h,c);f=e.makeTensorInfo(g,x,d)}else{let[h,d]=S.computeOutAndReduceShapes(m.shape,c),g=y.sizeFromShape(d),x=Q({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}}),b=Na(n.dtype),C=Mr(x,b,"prod",e);f=Q({inputs:{x:C},backend:e,attrs:{shape:h}}),l.push(x),l.push(C)}if(i){l.push(f);let h=S.expandShapeToKeepDim(f.shape,u);f=Q({inputs:{x:f},backend:e,attrs:{shape:h}})}return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),f}var TR={kernelName:xi,backendName:"webgl",kernelFunc:Gq};function Wq(r){let{inputs:t,backend:e,attrs:o}=r,{paramsNestedSplits:n,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=o,l=n.map(x=>e.readSync(x.dataId)),u=n.map(x=>x.shape),c=e.readSync(s.dataId),p=e.readSync(i.dataId),[m,f,h]=d$(l,u,c,s.shape,s.dtype,p,i.shape,a),d=m.map(x=>e.makeTensorInfo([x.length],"int32",x)),g=e.makeTensorInfo(h,s.dtype,f);return d.concat([g])}var vR={kernelName:$f,backendName:"webgl",kernelFunc:Wq};function Uq(r){let{inputs:t,backend:e}=r,{starts:o,limits:n,deltas:s}=t,i=e.readSync(o.dataId),a=e.readSync(n.dataId),l=e.readSync(s.dataId),[u,c]=g$(i,o.shape,o.dtype,a,n.shape,l,s.shape),p=e.makeTensorInfo([u.length],"int32",u),m=e.makeTensorInfo([c.length],o.dtype,c);return[p,m]}var kR={kernelName:Df,backendName:"webgl",kernelFunc:Uq};function Hq(r){let{inputs:t,backend:e,attrs:o}=r,{shape:n,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=o,u=e.readSync(n.dataId),c=e.readSync(s.dataId),p=e.readSync(i.dataId),m=a.map(g=>e.readSync(g.dataId)),f=a.map(g=>g.shape),[h,d]=x$(u,n.shape,c,s.shape,s.dtype,p,i.shape,m,f,l);return e.makeTensorInfo(h,s.dtype,d)}var ER={kernelName:Rf,backendName:"webgl",kernelFunc:Hq};var G0=r=>{let{backend:t,attrs:e}=r,{start:o,stop:n,step:s,dtype:i}=e,a=y$(o,n,s,i);return t.makeTensorInfo([a.length],i,a)},AR={kernelName:Jl,backendName:"webgl",kernelFunc:G0};var Kq="return 1.0 / x;",qq=mt({opSnippet:Kq}),$R={kernelName:Kn,backendName:"webgl",kernelFunc:qq};var jq=De+`
  return (x < 0.0) ? 0.0 : x;
`,Xq=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Yq=mt({opSnippet:jq,packedOpSnippet:Xq}),DR={kernelName:qn,backendName:"webgl",kernelFunc:Yq};var Zq=De+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Jq=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qq=mt({opSnippet:Zq,packedOpSnippet:Jq}),RR={kernelName:jn,backendName:"webgl",kernelFunc:Qq};var kx=class{constructor(t,e,o,n,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,o,u];let c=[n&&e>1?a-1:a,n&&o>1?l-1:l],p=[n&&e>1?e-1:e,n&&o>1?o-1:o],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var Ex=class{constructor(t,e,o,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,o,u];let c=[n&&e>1?a-1:a,n&&o>1?l-1:l],p=[n&&e>1?e-1:e,n&&o>1?o-1:o],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${o-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function tj(r){let{inputs:t,backend:e,attrs:o}=r,{images:n}=t,{alignCorners:s,halfPixelCenters:i,size:a}=o,[l,u]=a,c=P().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ex(n.shape,l,u,s,i):new kx(n.shape,l,u,s,i);return e.runWebGLProgram(c,[n],"float32")}var FR={kernelName:wi,backendName:"webgl",kernelFunc:tj};var Ax=class{constructor(t,e,o){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,n,s]=e,[,i,a]=t,l=[o&&i>1?n-1:n,o&&a>1?s-1:s],u=[o&&i>1?i-1:i,o&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],m=1/c,f=1/p,h=Math.ceil(m)*2+2,d=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${d});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${n-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function ej(r){let{inputs:t,backend:e,attrs:o}=r,{images:n,dy:s}=t,{alignCorners:i}=o,a=new Ax(s.shape,n.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var _R={kernelName:eu,backendName:"webgl",kernelFunc:ej};var $x=class{constructor(t,e,o,n,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,o,u];let c=[n&&e>1?a-1:a,n&&o>1?l-1:l],p=[n&&e>1?e-1:e,n&&o>1?o-1:o],m=n?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var Dx=class{constructor(t,e,o,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,o,u];let c=[n&&e>1?a-1:a,n&&o>1?l-1:l],p=[n&&e>1?e-1:e,n&&o>1?o-1:o],m=n?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${o-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function rj(r){let{inputs:t,backend:e,attrs:o}=r,{images:n}=t,{alignCorners:s,halfPixelCenters:i,size:a}=o,[l,u]=a,c=P().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Dx(n.shape,l,u,s,i):new $x(n.shape,l,u,s,i);return e.runWebGLProgram(c,[n],n.dtype)}var OR={kernelName:bi,backendName:"webgl",kernelFunc:rj};var Rx=class{constructor(t,e,o){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,n,s]=e,[,i,a]=t,l=[o&&i>1?n-1:n,o&&a>1?s-1:s],u=[o&&i>1?i-1:i,o&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],m=1/c,f=1/p,h=Math.ceil(m)*2+2,d=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${d});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${n}) - 1),
                ${o} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${o} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function oj(r){let{inputs:t,backend:e,attrs:o}=r,{images:n,dy:s}=t,{alignCorners:i}=o,a=new Rx(s.shape,n.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var LR={kernelName:tu,backendName:"webgl",kernelFunc:oj};var Fx=class{constructor(t,e){this.variableNames=["x"];let o=t.length;if(o>4)throw new Error(`WebGL backend: Reverse of rank-${o} tensor is not yet supported`);if(this.outputShape=t,o===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let n=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,l)=>n(l)).join(","),i=Et(o);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var _x=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let o=t.length;if(o>4)throw new Error(`WebGL backend: Reverse of rank-${o} tensor is not yet supported`);this.outputShape=t;let n=Ce("rc",o),s=`${n[o-1]} + 1 < ${this.outputShape[o-1]}`,i=`${n[o-2]} + 1 < ${this.outputShape[o-2]}`,a=Et(o);o===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(n.slice())};
          if(${s}){
            result.g = ${u(n.slice())};
          }
          if(${i}) {
            result.b = ${c(n.slice())};
            if(${s}) {
              result.a = ${p(n.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(h){return m(h)}function u(h){return h[o-1]="("+h[o-1]+" + 1)",m(h)}function c(h){return h[o-2]="("+h[o-2]+" + 1)",m(h)}function p(h){return h[o-1]="("+h[o-1]+" + 1)",h[o-2]="("+h[o-2]+" + 1)",m(h)}function m(h){let d=t.map((b,C)=>f(C,h)),g=d.join(","),x=d.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function f(h,d){return e.indexOf(h)!==-1&&t[h]!==1?`${t[h]} - ${d[h]} - 1`:`${d[h]}`}}};function nj(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{dims:s}=o,i=n.shape.length,a=y.parseAxisParam(s,n.shape);if(i===0)return Ie({inputs:{x:n},backend:e});let l=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _x(n.shape,a):new Fx(n.shape,a);return e.runWebGLProgram(l,[n],n.dtype)}var PR={kernelName:Ci,backendName:"webgl",kernelFunc:nj};var Ox=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let o=t[1],n=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${n} && coordY >= 0 && coordY < ${o}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var zR={kernelName:au,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:o}=r,{radians:n,fillValue:s,center:i}=t,a=e,l=new Ox(o.shape,s),[u,c]=S.getImageCenter(i,o.shape[1],o.shape[2]),p=[[u,c,Math.sin(n),Math.cos(n)]];return a.runWebGLProgram(l,[o],o.dtype,p)}};var sj=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,ij=mt({opSnippet:sj}),MR={kernelName:Xn,backendName:"webgl",kernelFunc:ij};var aj="return inversesqrt(x);",lj=mt({opSnippet:aj,cpuKernelImpl:b$}),BR={kernelName:Yn,backendName:"webgl",kernelFunc:lj};var Lc=class{constructor(t,e,o,n,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let l=Et(s.length),u=Et(i.length),c="";o===1?c="i":o===2&&(c="i, j");let p=`getIndices(${c})`,m="";n===1?m="i":n===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,h=e>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${h};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function uj(r){let{inputs:t,backend:e,attrs:o}=r,{indices:n,updates:s}=t,{shape:i}=o,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=S.calculateShapes(s,n,i),m=[p/u,u];if(p===0)return e.makeTensorInfo(i,n.dtype);let f=Q({inputs:{x:n},backend:e,attrs:{shape:[l,a]}}),h=Q({inputs:{x:s},backend:e,attrs:{shape:[l,u]}}),d=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new Lc(l,a,f.shape.length,h.shape.length,c,m),x=e.runWebGLProgram(g,[h,f,d],h.dtype),b=Q({inputs:{x},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(d),b}var VR={kernelName:Ff,backendName:"webgl",kernelFunc:uj};var Lx=class{constructor(t,e,o,n){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,o];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=P().getNumber("WEBGL_VERSION")===2?s:i,l=n==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function cj(r){let{inputs:t,backend:e,attrs:o}=r,{sortedSequence:n,values:s}=t,{side:i}=o,a=new Lx(n.shape[0],n.shape[1],s.shape[1],i),l=[[n.shape[1]]];return e.runWebGLProgram(a,[n,s],"int32",l)}var GR={kernelName:_f,backendName:"webgl",kernelFunc:cj};var Px=class{constructor(t,e,o){this.variableNames=["c","a","b"],this.outputShape=e;let n,s;if(o>4)throw Error(`Where for rank ${o} is not yet supported`);if(o===1)s="resRC",n="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<t&&l.push(`${a[c]}`);n=l.join(),s=u.join()}let i=Et(o);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${n});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function pj(r){let{inputs:t,backend:e}=r,{condition:o,t:n,e:s}=t,i=new Px(o.shape.length,n.shape,n.shape.length);return e.runWebGLProgram(i,[o,n,s],Te(n.dtype,s.dtype))}var WR={kernelName:Ii,backendName:"webgl",kernelFunc:pj};var mj=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,fj=mt({opSnippet:mj}),UR={kernelName:Zn,backendName:"webgl",kernelFunc:fj};var hj=No+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,dj=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gj=mt({opSnippet:hj,packedOpSnippet:dj,cpuKernelImpl:C$}),HR={kernelName:es,backendName:"webgl",kernelFunc:gj};var xj=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,yj=mt({opSnippet:xj}),KR={kernelName:ts,backendName:"webgl",kernelFunc:yj};var bj=No+`
  return sin(x);
`,wj=mt({opSnippet:bj}),qR={kernelName:Jn,backendName:"webgl",kernelFunc:wj};var Cj=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Ij=mt({opSnippet:Cj}),jR={kernelName:Qn,backendName:"webgl",kernelFunc:Ij};var Sj=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Nj=mt({opSnippet:Sj}),XR={kernelName:rs,backendName:"webgl",kernelFunc:Nj};var Tj=r=>{let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{blockShape:s,paddings:i}=o;y.assert(n.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,b)=>x*b),l=[[0,0]];l.push(...i);for(let x=1+s.length;x<n.shape.length;++x)l.push([0,0]);let u=[],c=V0({inputs:{x:n},backend:e,attrs:{paddings:l,constantValue:0}}),p=S.getReshaped(c.shape,s,a,!1),m=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(c.shape,s,a,!1),h=Q({inputs:{x:c},backend:e,attrs:{shape:p}}),d=ae({inputs:{x:h},backend:e,attrs:{perm:m}}),g=Q({inputs:{x:d},backend:e,attrs:{shape:f}});return u.push(c),u.push(h),u.push(d),u.forEach(x=>e.disposeIntermediateTensorInfo(x)),g},YR={kernelName:Ti,backendName:"webgl",kernelFunc:Tj};function vj(r){let{inputs:t,backend:e}=r,{indices:o,values:n,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${o.shape}`);if(n.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${n.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(o.dataId),l=e.readSync(n.dataId),u=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,m,f,h,d]=S$(a,o.shape,o.dtype,l,n.dtype,u,c);return[e.makeTensorInfo(m,o.dtype,p),e.makeTensorInfo([m[0]],n.dtype,f),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}var ZR={kernelName:Of,backendName:"webgl",kernelFunc:vj};function kj(r){let{inputs:t,backend:e}=r,{inputIndices:o,inputShape:n,newShape:s}=t;if(o.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${o.shape}`);if(n.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${n.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(n.dataId)),a=e.readSync(o.dataId),l=Array.from(e.readSync(s.dataId)),[u,c,p]=N$(a,o.shape,o.dtype,i,l);return[e.makeTensorInfo(c,o.dtype,u),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var JR={kernelName:Lf,backendName:"webgl",kernelFunc:kj};function Ej(r){let{inputs:t,backend:e}=r,{data:o,indices:n,segmentIds:s}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(o.dataId),a=e.readSync(n.dataId),l=e.readSync(s.dataId),[u,c]=wg(i,o.shape,o.dtype,a,l,!0);return e.makeTensorInfo(c,o.dtype,u)}var QR={kernelName:Pf,backendName:"webgl",kernelFunc:Ej};function Aj(r){let{inputs:t,backend:e}=r,{data:o,indices:n,segmentIds:s}=t;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(o.dataId),a=e.readSync(n.dataId),l=e.readSync(s.dataId),[u,c]=wg(i,o.shape,o.dtype,a,l);return e.makeTensorInfo(c,o.dtype,u)}var tF={kernelName:zf,backendName:"webgl",kernelFunc:Aj};function $j(r){let{inputs:t,backend:e,attrs:o}=r,{sparseIndices:n,sparseValues:s,defaultValue:i}=t,{outputShape:a}=o,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,n,a),f=!1;if(s.dtype==="string"){let x=e.bufferSync(n),b=e.bufferSync(s),C=y.decodeString(e.readSync(i.dataId)[0]),w=w$(x,b,a,m,c,u,l,p,C,f);return e.makeTensorInfo(a,w.dtype,w.values)}let h=new Lc(u,l,n.shape.length,s.shape.length,p,[m,1],f),d=e.runWebGLProgram(h,[s,n,i],s.dtype),g=Q({inputs:{x:d},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(d),g}var eF={kernelName:Mf,backendName:"webgl",kernelFunc:$j};function Dj(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{numOrSizeSplits:s,axis:i}=o,a=y.parseAxisParam(i,n.shape)[0],l=S.prepareSplitSize(n,s,a),u=n.shape.length,c=new Array(u).fill(0),p=n.shape.slice();return l.map(m=>{let f=[...p];f[a]=m;let h=Go({inputs:{x:n},backend:e,attrs:{begin:c,size:f}});return c[a]+=m,h})}var rF={kernelName:vi,backendName:"webgl",kernelFunc:Dj};var oF="return sqrt(x);",Rj=mt({opSnippet:oF,packedOpSnippet:oF,cpuKernelImpl:T$}),nF={kernelName:os,backendName:"webgl",kernelFunc:Rj};var Fj="return x * x;",_j=mt({opSnippet:Fj}),sF={kernelName:ru,backendName:"webgl",kernelFunc:_j};var iF="return (a - b) * (a - b);",Oj=Vt({opSnippet:iF,packedOpSnippet:iF}),aF={kernelName:ns,backendName:"webgl",kernelFunc:Oj};function Lj({inputs:r,attrs:t,backend:e}){let{x:o}=r,n=De+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Xe(o.shape,n);return e.runWebGLProgram(s,[o],o.dtype)}var lF={kernelName:ls,backendName:"webgl",kernelFunc:Lj};var zx=class{constructor(t,e,o){this.variableNames=["x"],this.outputShape=o;let n=o.length,s=Et(o.length),i=Et(o.length),a="";if(n===1)a="coords * strides + begin";else{let l=0;a=o.map((u,c)=>(l++,o.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function Pj(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=o,{finalShapeSparse:f,finalShape:h,isIdentity:d,sliceDim0:g,isSimpleSlice:x,begin:b,end:C,strides:w}=Pe.sliceInfo(n.shape,s,i,a,l,u,c,p,m),I;if(d)I=Q({inputs:{x:n},backend:e,attrs:{shape:h}});else if(g||x){y.assert(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);let A=Pe.computeOutShape(b,C,w),$=Go({inputs:{x:n},backend:e,attrs:{begin:b,size:A}});I=Q({inputs:{x:$},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo($)}else if(e.shouldExecuteOnCPU([n])){let $=e.readSync(n.dataId),_=ft(n.shape,n.dtype,$),L=v$(f,_,w,b);I=e.makeTensorInfo(h,n.dtype,L.values)}else{let $=new zx(b,w,f);I=e.runWebGLProgram($,[n],n.dtype)}let E=Q({inputs:{x:I},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(I),E}var uF={kernelName:ou,backendName:"webgl",kernelFunc:Pj};function zj(r){let{inputs:t,backend:e,attrs:o}=r,{separator:n,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=o,{data:c,dataSplits:p}=t,m=e.readSync(c.dataId),f=e.readSync(p.dataId),[h,d]=k$(m,f,n,s,i,a,l,u);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",d)]}var cF={kernelName:Bf,backendName:"webgl",kernelFunc:zj};function Mj(r){let{inputs:t,backend:e,attrs:o}=r,{skipEmpty:n}=o,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),l=e.readSync(i.dataId)[0],[u,c,p]=E$(a,l,n),m=c.length;return[e.makeTensorInfo([m,2],"int32",u),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var pF={kernelName:Vf,backendName:"webgl",kernelFunc:Mj};function Bj(r){let{inputs:t,backend:e,attrs:o}=r,{numBuckets:n}=o,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(n<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=A$(i,n);return e.makeTensorInfo(s.shape,"int32",a)}var mF={kernelName:Gf,backendName:"webgl",kernelFunc:Bj};var Vj="return tan(x);",Gj=mt({opSnippet:Vj}),fF={kernelName:is,backendName:"webgl",kernelFunc:Gj};var Wj=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Uj=mt({opSnippet:Wj}),hF={kernelName:as,backendName:"webgl",kernelFunc:Uj};var Mx=class{constructor(t,e){this.variableNames=["A"];let o=new Array(t.length);for(let i=0;i<o.length;i++)o[i]=t[i]*e[i];this.outputShape=o,this.rank=o.length;let n=Et(this.rank),s=Hj(t);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Hj(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],o=[];for(let n=0;n<r.length;n++)o.push(`imod(${e[n]}, ${r[n]})`);return o.join()}function W0(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{reps:s}=o;if(n.dtype==="string"||n.shape.length>5){let l=e.readSync(n.dataId),u=n.dtype==="string"?l.map(m=>y.decodeString(m)):l,c=ft(n.shape,n.dtype,u),p=D$(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new Mx(n.shape,s);return e.runWebGLProgram(i,[n],n.dtype)}var dF={kernelName:Ko,backendName:"webgl",kernelFunc:W0};var Bx=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Vx=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function gl(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function gF(r){let t=1;for(;t<r;)t*=2;return t}function Kj(r){let{inputs:t,backend:e,attrs:o}=r,{x:n}=t,{k:s,sorted:i}=o,a=P().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=P().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=n.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([n])||c<a||s>l){let L=e.readSync(n.dataId),[B,V]=R$(L,u,n.dtype,s,i);return[e.makeTensorInfo(B.shape,B.dtype,B.values),e.makeTensorInfo(V.shape,V.dtype,V.values)]}if(s===0)return u[u.length-1]=0,[e.makeTensorInfo(u,n.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(c===1)return[n,Fs({attrs:{shape:u,dtype:"int32",value:0},backend:e})];let p=e.texData.get(n.dataId),m=p!==null&&p.isPacked,f=m?e.unpackTensor(n):n,d=y.sizeFromShape(u)/c,g=Q({inputs:{x:f},attrs:{shape:[d,c]},backend:e});m&&gl(e,f);let x=gF(s),b=gF(c),C=null,w=()=>C===null?[g,g]:[g,C],I=(L,B,V)=>{let G=w(),U=new Bx(V),q=[[c],[C===null?1:0],[Number.NEGATIVE_INFINITY],[L],[B]],Z=C;C=e.runWebGLProgram(U,G,"int32",q),gl(e,Z)};for(let L=1;L<x;L*=2){let B=L*2;for(let V=L;V>=1;V/=2)I(B,V,[d,b])}for(let L=b;L>x;L/=2){let B=w(),V=new Vx([d,L/2]),U=[[c],[C===null?1:0],[x]],W=C;C=e.runWebGLProgram(V,B,"int32",U),gl(e,W);let q=x/2,Z=q*2;for(let K=q;K>=1;K/=2)I(Z,K,C.shape)}let E=C;C=Go({inputs:{x:C},backend:e,attrs:{begin:0,size:[d,s]}}),gl(e,E);let A=L0({inputs:{x:g,indices:C},backend:e,attrs:{axis:1,batchDims:1}});gl(e,g);let $=u.slice(0,-1);$.push(s),E=C,C=Q({inputs:{x:C},attrs:{shape:$},backend:e}),gl(e,E);let _=A;return A=Q({inputs:{x:A},attrs:{shape:$},backend:e}),gl(e,_),[A,C]}var xF={kernelName:nu,backendName:"webgl",kernelFunc:Kj};var Gx=class{constructor(t,e,o,n,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=o==="nearest"?1:2,l;switch(n){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function qj(r){let{inputs:t,backend:e,attrs:o}=r,{image:n,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=o,[c,p,m,f]=n.shape,[h,d]=u!=null?u:[p,m],g=[c,h,d,f],x=new Gx(p,m,i,a,l,g);return e.runWebGLProgram(x,[n,s],"float32")}var yF={kernelName:su,backendName:"webgl",kernelFunc:qj};function jj(r){let{inputs:t,attrs:e,backend:o}=r,{axis:n}=e,{x:s}=t;cn(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=o.readSync(s.dataId),{outputValues:a,outputShape:l,indices:u}=F$(i,n,s.shape,s.dtype);return[o.makeTensorInfo(l,s.dtype,a),o.makeTensorInfo([u.length],"int32",u)]}var bF={kernelName:iu,backendName:"webgl",kernelFunc:jj};function Xj(r){let{inputs:t,backend:e,attrs:o}=r,{value:n}=t,{axis:s}=o;s<0&&(s+=n.shape.length);let i=n,a=i.shape.length,l=n.shape[s],u=new Array(a-1),c=0;for(let d=0;d<a;d++)d!==s&&(u[c++]=i.shape[d]);let p=[],m=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let h=new Array(l);for(let d=0;d<h.length;d++){m[s]=d;let g=Go({inputs:{x:i},backend:e,attrs:{begin:m,size:f}}),x=Q({inputs:{x:g},backend:e,attrs:{shape:u}});h[d]=x,p.push(g)}return p.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}var wF={kernelName:Ei,backendName:"webgl",kernelFunc:Xj};var Wx=class{constructor(t,e){this.variableNames=["x","segmentIds"];let o=t.windowSize,n=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/o);this.outputShape=[n,a];let l="0.0",u="sumValue",c=Math.floor(o/4)*4,p=o%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%o>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%o>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${o}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${u});
      }
    `}};function Yj(r){let{inputs:t,backend:e,attrs:o}=r,{x:n,segmentIds:s}=t,{numSegments:i}=o,a=n.shape.length,l=[],u=0,c=S.getAxesPermutation([u],a),p=n;c!=null&&(p=ae({inputs:{x:n},backend:e,attrs:{perm:c}}),l.push(p),u=S.getInnerMostAxes(1,a)[0]);let m=S.segment_util.computeOutShape(p.shape,u,i),f=y.sizeFromShape([p.shape[u]]),h=Q({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});l.push(h);let d=Na(n.dtype),g=(w,I,E,A,$)=>{let _=w.shape[0],L=w.shape[1],B=S.segment_util.segOpComputeOptimalWindowSize(L,$),V={windowSize:B,inSize:L,batchSize:_,numSegments:$},G=new Wx(V,I),U=e.compileAndRun(G,[w,E],A);if(l.push(U),U.shape[1]===$)return U;let W=G0({backend:e,attrs:{start:0,stop:$,step:1,dtype:"float32"}}),q=W0({inputs:{x:W},backend:e,attrs:{reps:[L/B]}});return l.push(W),l.push(q),g(U,I,q,A,$)},x=g(h,"unsortedSegmentSum",s,d,i),b=Q({inputs:{x},backend:e,attrs:{shape:m}}),C=b;if(c!=null){l.push(b);let w=S.getUndoAxesPermutation(c);C=ae({inputs:{x:C},backend:e,attrs:{perm:w}})}return l.forEach(w=>e.disposeIntermediateTensorInfo(w)),C}var CF={kernelName:Ai,backendName:"webgl",kernelFunc:Yj};var Zj=[i2,l2,u2,c2,m2,f2,h2,d2,y2,b2,w2,C2,I2,S2,N2,T2,v2,k2,E2,A2,$2,R2,F2,_2,z2,B2,V2,Y$,W2,H2,K2,q2,j2,X2,Y2,Z2,J2,Q2,tD,oD,nD,sD,iD,aD,lD,uD,cD,pD,mD,fD,hD,dD,gD,xD,yD,wD,CD,ID,SD,TD,vD,kD,ED,AD,$D,DD,RD,FD,X$,_D,U2,OD,LD,PD,Z$,zD,MD,BD,VD,GD,WD,UD,HD,KD,qD,XD,YD,ZD,JD,QD,tR,rR,nR,sR,iR,aR,lR,fR,t2,hR,dR,gR,xR,O2,yR,CR,IR,SR,NR,J$,TR,vR,kR,ER,AR,L2,uR,$R,DR,RR,r2,FR,_R,OR,LR,PR,zR,MR,BR,VR,GR,WR,UR,HR,KR,qR,jR,D2,mR,XR,YR,ZR,JR,QR,tF,eF,rF,nF,sF,aF,lF,uF,cF,pF,mF,pR,n2,fF,hF,dF,xF,yF,s2,bF,wF,CF,bR];for(let r of Zj)Uf(r);var Qj=()=>(console.log(Oo),1),IF=Qj;window.handwriting=IF;})();
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** @license See the LICENSE file. */
//# sourceMappingURL=toolcool-handwriting.min.js.map
